<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WAIP Auth Simulation</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
body {
  font-family: system-ui, sans-serif;
  max-width: 600px;
  margin: 30px auto;
  padding: 20px;
  line-height: 1.6;
}
button {
  padding: 10px 16px;
  border-radius: 8px;
  border: none;
  background: #3b82f6;
  color: white;
  font-size: 15px;
  cursor: pointer;
}
input {
  width: 100%;
  padding: 10px;
  margin-bottom: 12px;
  font-size: 15px;
}
pre {
  background: #f1f5f9;
  padding: 12px;
  border-radius: 6px;
  font-size: 13px;
  overflow-x: auto;
}
.section {
  border: 1px solid #ddd;
  padding: 20px;
  border-radius: 12px;
  margin-bottom: 20px;
}
</style>
</head>
<body>

<h2>WAIP Authentication Simulation</h2>
<p>This simulates the entire protocol: registration, challenge, WebAuthn operation, verification, and JWT issuance.</p>

<div class="section">
  <h3>1. Sign Up</h3>
  <input id="username" placeholder="username">
  <button onclick="signup()">Register Passkey</button>
  <pre id="signupLog"></pre>
</div>

<div class="section">
  <h3>2. Login</h3>
  <button onclick="login()">Authenticate with Passkey</button>
  <pre id="loginLog"></pre>
</div>

<div class="section">
  <h3>Mock Backend Storage</h3>
  <pre id="serverState">{}</pre>
</div>

<script>
/* --------------------------------------------
    MOCK BACKEND
-------------------------------------------- */

const mockDB = {}; // username -> { credentialId, publicKeyJwk }

function updateServerState() {
  document.getElementById("serverState").textContent =
    JSON.stringify(mockDB, null, 2);
}

/* --------------------------------------------
    HELPERS
-------------------------------------------- */

function bufToB64(buf) {
  return btoa(String.fromCharCode(...new Uint8Array(buf)))
    .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

function b64ToBuf(b64) {
  b64 = b64.replace(/-/g, "+").replace(/_/g, "/");
  const pad = "=".repeat((4 - b64.length % 4) % 4);
  const str = atob(b64 + pad);
  const buf = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) buf[i] = str.charCodeAt(i);
  return buf.buffer;
}

/**
 * Convert a DER-encoded ECDSA signature (WebAuthn gives this)
 * into raw r||s format (WebCrypto expects this).
 *
 * Assumes P-256 → r and s are 32 bytes each after padding.
 */
function derToRawEcdsaSignature(derSig, keySize = 32) {
  const bytes = new Uint8Array(derSig);

  if (bytes[0] !== 0x30) {
    throw new Error("Invalid DER signature (no SEQUENCE)");
  }

  let offset = 1;
  let seqLen = bytes[offset++];

  if (seqLen & 0x80) {
    // Long-form length; read the next (seqLen & 0x7f) bytes
    const numLenBytes = seqLen & 0x7f;
    seqLen = 0;
    for (let i = 0; i < numLenBytes; i++) {
      seqLen = (seqLen << 8) | bytes[offset++];
    }
  }

  if (bytes[offset++] !== 0x02) {
    throw new Error("Invalid DER signature (no INTEGER for r)");
  }

  let rLen = bytes[offset++];
  let r = bytes.slice(offset, offset + rLen);
  offset += rLen;

  if (bytes[offset++] !== 0x02) {
    throw new Error("Invalid DER signature (no INTEGER for s)");
  }

  let sLen = bytes[offset++];
  let s = bytes.slice(offset, offset + sLen);

  // Strip leading zeros (if any), then left-pad to keySize
  function padTo(b, size) {
    // Strip leading 0x00
    while (b.length > 1 && b[0] === 0x00) {
      b = b.subarray(1);
    }
    if (b.length > size) {
      throw new Error("Invalid ECDSA signature length");
    }
    const out = new Uint8Array(size);
    out.set(b, size - b.length);
    return out;
  }

  const rPadded = padTo(r, keySize);
  const sPadded = padTo(s, keySize);

  const raw = new Uint8Array(keySize * 2);
  raw.set(rPadded, 0);
  raw.set(sPadded, keySize);
  return raw.buffer;
}

/* --------------------------------------------
    SIGNUP (REGISTRATION)
-------------------------------------------- */

async function signup() {
  const username = document.getElementById("username").value.trim();
  const log = document.getElementById("signupLog");
  log.textContent = "";

  if (!username) {
    log.textContent = "Error: enter username";
    return;
  }

  // Backend generates registration challenge
  const challenge = crypto.getRandomValues(new Uint8Array(32));

  const publicKey = {
    challenge: challenge.buffer,
    rp: { name: "WAIP Auth Demo", id: window.location.hostname },
    user: {
      id: crypto.getRandomValues(new Uint8Array(16)),
      name: username,
      displayName: username
    },
    pubKeyCredParams: [{ type: "public-key", alg: -7 }], // ES256
    authenticatorSelection: { userVerification: "required" }
  };

  // Browser creates passkey
  const cred = await navigator.credentials.create({ publicKey });

  if (!cred) {
    log.textContent = "Passkey creation cancelled or failed.";
    return;
  }

  // Extract public key via WebAuthn built-in method (DER-encoded SPKI)
  const publicKeyDER = cred.response.getPublicKey();
  if (!publicKeyDER) {
    log.textContent = "Browser did not provide public key.";
    return;
  }

  // Convert public key to JWK
  const publicKeyObj = await crypto.subtle.importKey(
    "spki",
    publicKeyDER,
    { name: "ECDSA", namedCurve: "P-256" },
    true,
    ["verify"]
  );

  const publicKeyJwk = await crypto.subtle.exportKey("jwk", publicKeyObj);

  // Save credentialId + publicKey to mock backend
  mockDB[username] = {
    credentialId: bufToB64(cred.rawId),
    publicKeyJwk
  };

  updateServerState();
  log.textContent = "Passkey registered.\nCredentialId: " + mockDB[username].credentialId;
}

/* --------------------------------------------
    LOGIN (AUTHENTICATION)
-------------------------------------------- */

async function login() {
  const username = document.getElementById("username").value.trim();
  const log = document.getElementById("loginLog");
  log.textContent = "";

  const record = mockDB[username];
  if (!record) {
    log.textContent = "User not registered.";
    return;
  }

  // Backend generates challenge
  const challenge = crypto.getRandomValues(new Uint8Array(32));

  const publicKey = {
    challenge: challenge.buffer,
    allowCredentials: [{
      id: b64ToBuf(record.credentialId),
      type: "public-key"
    }],
    userVerification: "required"
  };

  const assertion = await navigator.credentials.get({ publicKey });

  if (!assertion) {
    log.textContent = "Authentication cancelled or failed.";
    return;
  }

  const clientDataJSON = assertion.response.clientDataJSON;
  const authenticatorData = assertion.response.authenticatorData;
  const signatureDER = assertion.response.signature;

  // Parse client data to verify challenge
  const clientData = JSON.parse(new TextDecoder().decode(clientDataJSON));
  if (clientData.challenge !== bufToB64(challenge.buffer)) {
    log.textContent = "Challenge mismatch!";
    return;
  }

  // Reconstruct public key from stored JWK
  const key = await crypto.subtle.importKey(
    "jwk",
    record.publicKeyJwk,
    { name: "ECDSA", namedCurve: "P-256" },
    false,
    ["verify"]
  );

  // Data that was signed = authenticatorData || SHA256(clientDataJSON)
  const clientDataHash = await crypto.subtle.digest("SHA-256", clientDataJSON);

  const authBytes = new Uint8Array(authenticatorData);
  const hashBytes = new Uint8Array(clientDataHash);
  const toSign = new Uint8Array(authBytes.length + hashBytes.length);
  toSign.set(authBytes, 0);
  toSign.set(hashBytes, authBytes.length);

  // Convert DER signature → raw r||s for WebCrypto
  const rawSig = derToRawEcdsaSignature(signatureDER, 32);

  // Verify signature
  const ok = await crypto.subtle.verify(
    { name: "ECDSA", hash: "SHA-256" },
    key,
    rawSig,
    toSign
  );

  if (!ok) {
    log.textContent = "Signature invalid.";
    return;
  }

  // Mock JWT
  const jwt = "fake.jwt." + btoa(username);

  log.textContent = "Login successful!\nJWT:\n" + jwt;
}
</script>

</body>
</html>

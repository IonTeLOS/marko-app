<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WAIP Auth Simulation</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
body {
  font-family: system-ui, sans-serif;
  max-width: 600px;
  margin: 30px auto;
  padding: 20px;
  line-height: 1.6;
}
button {
  padding: 10px 16px;
  border-radius: 8px;
  border: none;
  background: #3b82f6;
  color: white;
  font-size: 15px;
  cursor: pointer;
}
input {
  width: 100%;
  padding: 10px;
  margin-bottom: 12px;
  font-size: 15px;
}
pre {
  background: #f1f5f9;
  padding: 12px;
  border-radius: 6px;
  font-size: 13px;
  overflow-x: auto;
}
.section {
  border: 1px solid #ddd;
  padding: 20px;
  border-radius: 12px;
  margin-bottom: 20px;
}
</style>
</head>
<body>

<h2>WAIP Authentication Simulation</h2>
<p>This simulates the entire protocol: registration, challenge, WebAuthn operation, verification, and JWT issuance.</p>

<div class="section">
  <h3>1. Sign Up</h3>
  <input id="username" placeholder="username">
  <button onclick="signup()">Register Passkey</button>
  <pre id="signupLog"></pre>
</div>

<div class="section">
  <h3>2. Login</h3>
  <button onclick="login()">Authenticate with Passkey</button>
  <pre id="loginLog"></pre>
</div>

<div class="section">
  <h3>Mock Backend Storage</h3>
  <pre id="serverState">{}</pre>
</div>

<script>
/* --------------------------------------------
    MOCK BACKEND
-------------------------------------------- */

const mockDB = {}; // username -> { credentialId, publicKeyJwk }

function updateServerState() {
  document.getElementById("serverState").textContent =
    JSON.stringify(mockDB, null, 2);
}

/* --------------------------------------------
    HELPERS
-------------------------------------------- */

function bufToB64(buf) {
  return btoa(String.fromCharCode(...new Uint8Array(buf)))
    .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

function b64ToBuf(b64) {
  b64 = b64.replace(/-/g, "+").replace(/_/g, "/");
  const pad = "=".repeat((4 - b64.length % 4) % 4);
  const str = atob(b64 + pad);
  const buf = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) buf[i] = str.charCodeAt(i);
  return buf.buffer;
}

/* --------------------------------------------
    SIGNUP (REGISTRATION)
-------------------------------------------- */

async function signup() {
  const username = document.getElementById("username").value.trim();
  const log = document.getElementById("signupLog");
  log.textContent = "";

  if (!username) {
    log.textContent = "Error: enter username";
    return;
  }

  // Backend generates registration challenge
  const challenge = crypto.getRandomValues(new Uint8Array(32));

  const publicKey = {
    challenge,
    rp: { name: "WAIP Auth Demo", id: window.location.hostname },
    user: {
      id: crypto.getRandomValues(new Uint8Array(16)),
      name: username,
      displayName: username
    },
    pubKeyCredParams: [{ type: "public-key", alg: -7 }],
    authenticatorSelection: { userVerification: "required" }
  };

  // Browser creates passkey
  const cred = await navigator.credentials.create({ publicKey });

  // Extract public key via WebAuthn built-in method (DER-encoded)
  const publicKeyDER = cred.response.getPublicKey();
  if (!publicKeyDER) {
    log.textContent = "Browser did not provide public key.";
    return;
  }

  // Convert public key to JWK
  const publicKeyObj = await crypto.subtle.importKey(
    "spki",
    publicKeyDER,
    { name: "ECDSA", namedCurve: "P-256" },
    true,
    ["verify"]
  );

  const publicKeyJwk = await crypto.subtle.exportKey("jwk", publicKeyObj);

  // Save credentialId + publicKey to mock backend
  mockDB[username] = {
    credentialId: bufToB64(cred.rawId),
    publicKeyJwk
  };

  updateServerState();
  log.textContent = "Passkey registered.\nCredentialId: " + mockDB[username].credentialId;
}

/* --------------------------------------------
    LOGIN (AUTHENTICATION)
-------------------------------------------- */

async function login() {
  const username = document.getElementById("username").value.trim();
  const log = document.getElementById("loginLog");
  log.textContent = "";

  const record = mockDB[username];
  if (!record) {
    log.textContent = "User not registered.";
    return;
  }

  const challenge = crypto.getRandomValues(new Uint8Array(32));

  const publicKey = {
    challenge,
    allowCredentials: [{
      id: b64ToBuf(record.credentialId),
      type: "public-key"
    }],
    userVerification: "required"
  };

  const assertion = await navigator.credentials.get({ publicKey });

  const clientDataJSON = assertion.response.clientDataJSON;
  const authenticatorData = assertion.response.authenticatorData;
  const signature = assertion.response.signature;

  // Parse client data to verify challenge
  const clientData = JSON.parse(new TextDecoder().decode(clientDataJSON));
  if (clientData.challenge !== bufToB64(challenge)) {
    log.textContent = "Challenge mismatch!";
    return;
  }

  // Reconstruct public key
  const key = await crypto.subtle.importKey(
    "jwk",
    record.publicKeyJwk,
    { name: "ECDSA", namedCurve: "P-256" },
    false,
    ["verify"]
  );

  // Data that was signed = authenticatorData || clientDataJSON
  const toSign = new Uint8Array([
    ...new Uint8Array(authenticatorData),
    ...new Uint8Array(clientDataJSON)
  ]);

  const ok = await crypto.subtle.verify(
    { name: "ECDSA", hash: "SHA-256" },
    key,
    signature,
    toSign
  );

  if (!ok) {
    log.textContent = "Signature invalid.";
    return;
  }

  // Mock JWT
  const jwt = "fake.jwt." + btoa(username);

  log.textContent = "Login successful!\nJWT:\n" + jwt;
}
</script>

</body>
</html>

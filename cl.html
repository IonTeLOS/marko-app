<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Privacy-First Analytics</title>
  <!-- countries-and-timezones (~9 KB) - kept as fallback -->
  <script
    src="https://cdn.jsdelivr.net/gh/manuelmhtr/countries-and-timezones@latest/dist/index.min.js"
    type="text/javascript"
    crossorigin="anonymous"></script>
</head>
<body>
  <script>
    /**
 * Privacy-First Analytics with Cloudflare Trace Integration
 * 
 * This module collects minimal, non-identifiable data for analytics purposes.
 * Data is structured with short keys to minimize storage requirements:
 * - p: page path (derived from hostname & pathname)
 * - c: country code (from Cloudflare trace, with timezone-based fallback)
 * - l: language code (from browser)
 * - os: operating system (Windows, Android, iOS, etc.)
 * - ff: form factor (Mobile, Tablet, Desktop)
 * - q: quarter/part of day (morning, afternoon, evening, night)
 * - t: server timestamp
 * - ct: client ISO-8601 timestamp
 * 
 * Optional parameters:
 * - ip: IP address (from Cloudflare trace)
 * - ua: User agent string (from Cloudflare trace and browser)
 */

    /**
     * Determines part of day based on current hour
     * @returns {string} 'night', 'morning', 'afternoon', or 'evening'
     */
    function getPartOfDay() {
      const h = new Date().getHours();
      if (h < 6)   return 'night';
      if (h < 12)  return 'morning';
      if (h < 18)  return 'afternoon';
      return 'evening';
    }

    /**
     * Determines device type from User Agent string
     * Used as fallback if Cloudflare data is unavailable
     * @param {string} ua - Browser user agent string
     * @returns {string} Device type category
     */
    function getDeviceType(ua) {
      if (/Mobi|Android|iPhone|iPod/.test(ua)) return 'Mobile';
      if (/iPad|Tablet/.test(ua))              return 'Tablet';
      return 'Desktop';
    }
    
    /**
     * Extracts operating system from User Agent string
     * @param {string} uaString - Browser user agent string
     * @returns {string} Operating system name
     */
    function extractOS(uaString) {
      // Common OS patterns
      if (/Windows/.test(uaString)) return 'Windows';
      if (/Android/.test(uaString)) return 'Android';
      if (/iPhone|iPad|iPod/.test(uaString)) return 'iOS';
      if (/Mac OS X/.test(uaString)) return 'MacOS';
      if (/Linux/.test(uaString)) return 'Linux';
      if (/CrOS/.test(uaString)) return 'ChromeOS';
      return 'Unknown';
    }

    /**
     * Creates a path key from hostname and pathname
     * Used to determine which collection to write analytics data to
     * @returns {string} Path key for data storage
     */
    function getPathKey() {
      // Handle subdomain if present
      const host = window.location.hostname.split('.');
      const hasSub = host.length > 2;
      const sub = hasSub ? host.slice(0, host.length - 2).join('.') : '';
      
      // Get pathname segments and replace tildes with forward slashes
      let p = window.location.pathname.replace(/~/g, '/').split('/').filter(Boolean).join('/');
      if (!p) p = 'home';
      
      // Combine subdomain (if exists) with path
      return sub ? `${sub}/${p}` : p;
    }

    /**
     * Parse Cloudflare trace response into an object
     * @param {string} traceText - Raw text response from Cloudflare trace endpoint
     * @returns {Object} Parsed key-value pairs
     */
    function parseCloudflareTrace(traceText) {
      const trace = {};
      // Split by new lines and extract key-value pairs
      traceText.split('\n').forEach(line => {
        const parts = line.split('=');
        if (parts.length === 2) {
          trace[parts[0]] = parts[1];
        }
      });
      return trace;
    }

    /**
     * Get ISO-8601 formatted timestamp for current time
     * Used as fallback if server timestamp isn't available
     * @returns {string} ISO-8601 formatted timestamp
     */
    function getISOTimestamp() {
      return new Date().toISOString();
    }
    
    // Cache DOM selectors and other frequently used values
    const navigatorUA = navigator.userAgent;
    const browserLang = navigator.language || navigator.userLanguage || 'und';

    /**
     * Main analytics collection and submission function
     * @param {Object} options - Optional parameters
     * @param {boolean} options.includeIP - Whether to include IP address (default: false)
     * @param {boolean} options.includeBrowser - Whether to include browser info (default: false)
     * @returns {Promise} Promise that resolves when analytics are submitted
     */
    async function collectAndSubmitAnalytics(options = {}) {
      const { includeIP = false, includeBrowser = false } = options;
      
      // Get browser language
      const language = browserLang;
      
      // Get part of day
      const partOfDay = getPartOfDay();
      
      // Path key for collection name
      const path = getPathKey();
      
      try {
        // Fetch Cloudflare trace data
        const traceResponse = await fetch('https://cloudflare.com/cdn-cgi/trace');
        const traceText = await traceResponse.text();
        const trace = parseCloudflareTrace(traceText);
        
        // Extract actual OS from user agent
        function extractOS(uaString) {
          // Common OS patterns
          if (/Windows/.test(uaString)) return 'Windows';
          if (/Android/.test(uaString)) return 'Android';
          if (/iPhone|iPad|iPod/.test(uaString)) return 'iOS';
          if (/Mac OS X/.test(uaString)) return 'MacOS';
          if (/Linux/.test(uaString)) return 'Linux';
          if (/CrOS/.test(uaString)) return 'ChromeOS';
          return 'Unknown';
        }
        
        // Build analytics payload with shortened key names
        const payload = {
          p: path,                // path
          c: trace.loc || 'XX',   // country
          l: language,            // language
          os: extractOS(trace.uag || navigatorUA), // deviceOS
          ff: getDeviceType(navigatorUA),  // formFactor
          q: partOfDay,           // quarter of day
          t: { '.sv': 'timestamp' }, // server timestamp
          ct: getISOTimestamp()   // client timestamp (ISO-8601)
        };
        
        // Add optional fields if requested
        if (includeIP && trace.ip) {
          payload.ip = trace.ip;
        }
        
        if (includeBrowser) {
          payload.browser = trace.uag || navigator.userAgent;
        }
        
        // ðŸš€ Send to RTDB via REST
        const response = await fetch(`https://marko-be9a9-default-rtdb.firebaseio.com/raw/${path}.json`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        
        console.log('Analytics submitted successfully');
        return response;
      } catch (error) {
        console.error('Error submitting analytics:', error);
        
        // Fallback: still log data even if Cloudflare fetch fails
        try {
          // Get timezone â†’ country as fallback
          const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || '';
          const tzInfo = (typeof ct !== 'undefined' && ct.getTimezone)
            ? ct.getTimezone(tz)
            : null;
          const country = (tzInfo && tzInfo.countries.length)
            ? tzInfo.countries[0]
            : 'XX';
          
          // Create fallback payload with shortened key names
          const fallbackPayload = {
            p: path,              // path
            c: country,           // country
            l: language,          // language
            os: extractOS(navigatorUA), // deviceOS
            ff: getDeviceType(navigatorUA), // formFactor
            q: partOfDay,         // quarter of day
            t: { '.sv': 'timestamp' }, // server timestamp
            ct: getISOTimestamp() // client timestamp (ISO-8601)
          };
          
          // Add optional fields with shortened key names
          if (includeIP) {
            fallbackPayload.ip = null;
          }
          
          if (includeBrowser) {
            fallbackPayload.ua = navigatorUA; // userAgent
          }
          
          // ðŸš€ Try sending fallback data
          return fetch(`https://marko-be9a9-default-rtdb.firebaseio.com/${path}.json`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(fallbackPayload)
          });
        } catch (fallbackError) {
          console.error('Fallback analytics submission failed:', fallbackError);
          throw fallbackError;
        }
      }
    }

    // Execute analytics collection when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      // Default usage - no IP or browser info
      // collectAndSubmitAnalytics();
      
      // Example with options:
      collectAndSubmitAnalytics({ includeIP: true, includeBrowser: true });
    });
  </script>
</body>
</html>

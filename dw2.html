<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Decrypt Arweave Protected Content</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/localforage/dist/localforage.min.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      padding: 30px;
      max-width: 700px;
      width: 100%;
    }
    h1 { font-size: 22px; margin-bottom: 10px; color: #1a202c; }
    p { color: #4a5568; margin-bottom: 15px; font-size: 14px; }
    .input-group { margin-bottom: 16px; }
    .input-group label {
      display: block; margin-bottom: 6px; font-weight: 600;
      color: #4a5568; font-size: 13px;
    }
    .input-group input {
      width: 100%; padding: 10px; border-radius: 8px;
      border: 2px solid #e2e8f0; font-size: 14px; font-family: inherit;
    }
    .input-group input:focus { outline: none; border-color: #667eea; }
    .btn {
      padding: 10px 18px; border-radius: 8px; border: none;
      background: #667eea; color: white; font-weight: 600;
      cursor: pointer; font-size: 14px; gap: 6px;
    }
    #output {
      margin-top: 20px; padding: 12px;
      border-radius: 8px; background: #f8f9fa;
      font-family: 'Courier New', monospace;
      font-size: 13px; white-space: pre-wrap;
      max-height: 350px; overflow-y: auto;
      display:none;
    }
    .status {
      margin-top: 15px; padding: 12px; border-radius: 8px; font-size: 13px;
    }
    .status-info { background: #cfe2ff; color: #084298; }
    .status-success { background: #d1e7dd; color: #0f5132; }
    .status-error { background: #f8d7da; color: #842029; }
  </style>
</head>
<body>

<div class="container">
  <h1>üîê Decrypt Arweave Protected Content</h1>
  <p>
    Supports all Arweave wallet encryption formats:<br>
    ‚Ä¢ <code>{ enc: "pw" }</code> ‚Äî password encrypted<br>
    ‚Ä¢ <code>{ enc: "self" }</code> ‚Äî encrypted for your own wallet<br>
    ‚Ä¢ <code>{ enc: "recipient" }</code> ‚Äî encrypted specifically for you via ECDH
  </p>

  <div class="input-group">
    <label for="arweave-url">Arweave URL</label>
    <input id="arweave-url" type="text" placeholder="https://arweave.net/&lt;TXID&gt;">
  </div>

  <div class="input-group">
    <label for="password">Password (only for <code>enc: "pw"</code>)</label>
    <input id="password" type="text" placeholder="Leave empty for self/recipient">
  </div>

  <button class="btn" id="decrypt-btn" onclick="startDecrypt()">üîì Decrypt</button>
  <div id="status"></div>
  <div id="output"></div>
</div>

<script>
// ---------- Storage (same as wallet) ----------
const WalletStorage = {
  async get(key) { return localforage.getItem("biowallet:" + key); }
};

// ---------- Helpers ----------
function setStatus(msg, type="info") {
  const el = document.getElementById("status");
  el.className = "status status-" + type;
  el.innerHTML = msg;
}
function hexToBytes(hex) {
  const u = new Uint8Array(hex.length/2);
  for (let i=0;i<u.length;i++) u[i]=parseInt(hex.substr(i*2,2),16);
  return u;
}
const CryptoHelper = {
  async decrypt(enc, key) {
    const ct = hexToBytes(enc.ciphertext);
    const iv = hexToBytes(enc.iv);
    const raw = await crypto.subtle.decrypt({name:"AES-GCM",iv}, key, ct);
    return JSON.parse(new TextDecoder().decode(raw));
  }
};

// ---------- WebAuthn PRF ----------
const WebAuthnHelper = {
  async authenticate(credHex) {
    const challenge=crypto.getRandomValues(new Uint8Array(32));
    await navigator.credentials.get({
      publicKey:{
        challenge,
        allowCredentials:[{id:hexToBytes(credHex),type:"public-key"}],
        userVerification:"required"
      }
    });
    return true;
  },

  async evaluatePrf(credHex, saltBytes) {
    const challenge=crypto.getRandomValues(new Uint8Array(32));
    const res=await navigator.credentials.get({
      publicKey:{
        challenge,
        allowCredentials:[{id:hexToBytes(credHex),type:"public-key"}],
        userVerification:"required",
        extensions:{prf:{eval:{first:saltBytes}}}
      }
    });
    const out=res.getClientExtensionResults().prf.results.first;
    return new Uint8Array(out);
  }
};

// ---------- MAIN ----------
async function startDecrypt() {
  const url = document.getElementById("arweave-url").value.trim();
  const password = document.getElementById("password").value.trim();
  const output = document.getElementById("output");
  output.style.display="none";
  output.textContent="";

  if (!url) return setStatus("‚ùå Enter Arweave URL","error");

  setStatus("Fetching Arweave content‚Ä¶","info");

  try {
    const res=await fetch(url);
    if (!res.ok) throw new Error("HTTP "+res.status);
    const text=await res.text();
    const blob=JSON.parse(text);

    if (!blob.enc) throw new Error("Missing enc field");
    if (!blob.data) throw new Error("Missing data field");

    const encType=blob.enc;

    // ---------- PASSWORD ----------
    if (encType==="pw") {
      if (!password) throw new Error("Password required");
      if (!blob.salt) throw new Error("Missing salt");

      setStatus("Deriving password key‚Ä¶","info");

      const baseKey=await crypto.subtle.importKey(
        "raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]
      );
      const aesKey=await crypto.subtle.deriveKey({
        name:"PBKDF2",salt:hexToBytes(blob.salt),iterations:100000,hash:"SHA-256"
      }, baseKey, {name:"AES-GCM",length:256}, false, ["decrypt"]);

      const dec=await CryptoHelper.decrypt(blob.data,aesKey);
      output.textContent=(dec.text??JSON.stringify(dec,null,2));
      output.style.display="block";
      return setStatus("‚úÖ Decrypted (password)","success");
    }

    // ---------- SELF / RECIPIENT ----------
    const credentialId=await WalletStorage.get("credentialId");
    const keyMode=await WalletStorage.get("keyMode");
    if (!credentialId || !keyMode) throw new Error("Wallet not unlocked on this device");

    // SELF MODE
    if (encType==="self") {
      let aesKey=null;

      if (keyMode==="prf") {
        const salt=await WalletStorage.get("prfSaltHex");
        const prf=await WebAuthnHelper.evaluatePrf(credentialId, hexToBytes(salt));

        // HKDF expand PRF
        const hkdfKey = await crypto.subtle.importKey("raw", prf, "HKDF", false, ["deriveKey"]);
        aesKey = await crypto.subtle.deriveKey({
          name:"HKDF",
          hash:"SHA-256",
          salt: hexToBytes(salt),
          info: new Uint8Array([])
        }, hkdfKey, {name:"AES-GCM", length:256}, false, ["decrypt"]);

      } else {
        await WebAuthnHelper.authenticate(credentialId);
        const hex=await WalletStorage.get("aesKeyHex");
        aesKey=await crypto.subtle.importKey("raw",hexToBytes(hex),"AES-GCM",false,["decrypt"]);
      }

      const dec=await CryptoHelper.decrypt(blob.data,aesKey);
      output.textContent=(dec.text??JSON.stringify(dec,null,2));
      output.style.display="block";
      return setStatus("‚úÖ Decrypted (self)","success");
    }

// ---------- RECIPIENT MODE (dual: self OR recipient) ----------
// ---------- RECIPIENT MODE (dual: self OR recipient) ----------
if (encType === "recipient") {

  if (!blob.fromPub) throw new Error("Missing sender ephemeral key");

  // Detect dual-encryption format (new) vs old single format
  const hasSelf = blob.data && blob.data.self;

  // ---- AUTHENTICATE ONCE IN WRAPPED MODE (avoid double prompts) ----
  let cachedWrappedAesKey = null;

  if (keyMode === "wrapped") {
    await WebAuthnHelper.authenticate(credentialId);
    const aesHex = await WalletStorage.get("aesKeyHex");
    if (!aesHex) throw new Error("Missing local AES key (wrapped mode)");

    cachedWrappedAesKey = await crypto.subtle.importKey(
      "raw",
      hexToBytes(aesHex),
      "AES-GCM",
      false,
      ["encrypt", "decrypt"]
    );
  }

  // =====================================================================
  // 1) TRY SELF-DECRYPTION FIRST (if present in data.self)
  // =====================================================================
  if (hasSelf) {
    try {
      let aesKeySelf = null;

      if (keyMode === "prf") {
        const salt = await WalletStorage.get("prfSaltHex");
        if (!salt) throw new Error("Missing PRF salt for self decryption");

        const prf = await WebAuthnHelper.evaluatePrf(
          credentialId,
          hexToBytes(salt)
        );

        const hkdfKey = await crypto.subtle.importKey(
          "raw",
          prf,
          "HKDF",
          false,
          ["deriveKey"]
        );

        aesKeySelf = await crypto.subtle.deriveKey(
          {
            name: "HKDF",
            hash: "SHA-256",
            salt: hexToBytes(salt),
            info: new Uint8Array([])
          },
          hkdfKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["decrypt"]
        );
      } else {
        // wrapped mode ‚Üí reuse cached key
        aesKeySelf = cachedWrappedAesKey;
      }

      const decSelf = await CryptoHelper.decrypt(blob.data.self, aesKeySelf);
      output.textContent = (decSelf.text ?? JSON.stringify(decSelf, null, 2));
      output.style.display = "block";
      return setStatus("‚úÖ Decrypted (self)", "success");

    } catch (errSelf) {
      console.warn("Self decrypt failed; falling back to recipient ECDH path:", errSelf);
      // Continue to recipient decrypt
    }
  }

  // =====================================================================
  // 2) FALLBACK ‚Äî DECRYPT AS RECIPIENT (old + new message formats)
  // =====================================================================

  const encPrivBlobStr = await WalletStorage.get("encPrivKeyEncrypted");
  if (!encPrivBlobStr) throw new Error("Missing encrypted ECDH private key (encPrivKeyEncrypted)");

  const encPrivBlob = JSON.parse(encPrivBlobStr);

  let aesKey = null;

  if (keyMode === "prf") {
    const salt = await WalletStorage.get("prfSaltHex");
    if (!salt) throw new Error("Missing PRF salt");

    const prf = await WebAuthnHelper.evaluatePrf(
      credentialId,
      hexToBytes(salt)
    );

    const hkdfKey = await crypto.subtle.importKey(
      "raw",
      prf,
      "HKDF",
      false,
      ["deriveKey"]
    );

    aesKey = await crypto.subtle.deriveKey(
      {
        name: "HKDF",
        hash: "SHA-256",
        salt: hexToBytes(salt),
        info: new Uint8Array([])
      },
      hkdfKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["decrypt"]
    );
  } else {
    // wrapped mode ‚Üí reuse cached AES key instead of asking twice
    aesKey = cachedWrappedAesKey;
  }

  // Decrypt the stored ECDH private key
  const { ecdh: privJwk } = await CryptoHelper.decrypt(encPrivBlob, aesKey);

  const privKey = await crypto.subtle.importKey(
    "jwk",
    privJwk,
    { name: "ECDH", namedCurve: "P-256" },
    false,
    ["deriveBits"]
  );

  const senderRaw = Uint8Array.from(atob(blob.fromPub), c => c.charCodeAt(0));
  const senderPub = await crypto.subtle.importKey(
    "raw",
    senderRaw,
    { name: "ECDH", namedCurve: "P-256" },
    false,
    []
  );

  setStatus("Deriving shared secret‚Ä¶", "info");

  const bits = await crypto.subtle.deriveBits(
    { name: "ECDH", public: senderPub },
    privKey,
    256
  );

  const aesKeyRecipient = await crypto.subtle.importKey(
    "raw",
    bits,
    "AES-GCM",
    false,
    ["decrypt"]
  );

  // Support both new format (data.recipient) and old format (data)
  const encryptedPayload =
    (blob.data && blob.data.recipient)
      ? blob.data.recipient
      : blob.data;

  const dec = await CryptoHelper.decrypt(encryptedPayload, aesKeyRecipient);

if (dec.file) {
    const bytes = hexToBytes(dec.file);
    const blobFile = new Blob([bytes]);

    // Try to detect type (optional: look at dec.mime if you stored it)
    // Otherwise let browser guess
    const url = URL.createObjectURL(blobFile);

    // Determine if file is previewable
    const header = new Uint8Array(bytes.subarray(0, 8));
    const isPNG  = header[0] === 0x89 && header[1] === 0x50;
    const isJPG  = header[0] === 0xFF && header[1] === 0xD8;
    const isGIF  = header[0] === 0x47 && header[1] === 0x49;
    const isWebP = (header[0] === 0x52 && header[1] === 0x49 && header[2] === 0x46);
    const isText = (() => {
        for (let i = 0; i < Math.min(bytes.length, 300); i++) {
            if (bytes[i] === 0) return false; // null byte ‚Üí binary
        }
        return true;
    })();

    output.style.display = "block";

    if (isPNG || isJPG || isGIF || isWebP) {
        // --- IMAGE PREVIEW ---
        output.innerHTML = `<img src="${url}" style="max-width:100%; max-height:400px; border-radius:8px;" />`;
        return setStatus("üñºÔ∏è Image displayed", "success");
    }

    if (isText) {
        // --- TEXT PREVIEW ---
        const text = new TextDecoder().decode(bytes);
        output.textContent = text;
        return setStatus("üìÑ Text displayed", "success");
    }

    // --- Fallback: download file ---
    const link = document.createElement("a");
    link.href = url;
    link.download = "download.bin";
    link.click();

    output.textContent = "Downloaded unsupported file.";
    return setStatus("‚¨áÔ∏è File downloaded", "success");

} else {
    // Normal text decrypt
    output.textContent = (dec.text ?? JSON.stringify(dec,null,2));
    output.style.display = "block";
    return setStatus("‚úÖ Decrypted (text)", "success");
  }

}

    throw new Error("Unsupported encryption type: "+encType);

  } catch (err) {
    console.error(err);
    setStatus("‚ùå "+err.message,"error");
  }
}

// ---------- Autofill from URL hash ----------
(function init() {
  const url=new URL(window.location.href);
  const link=url.searchParams.get("link") || url.searchParams.get("url");
  if (link) document.getElementById("arweave-url").value=link;

  const hash=window.location.hash;
  if (hash.length>1) {
    try { document.getElementById("password").value=decodeURIComponent(hash.slice(1)); }
    catch { document.getElementById("password").value=hash.slice(1); }
  }
})();
</script>


</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Decrypt Arweave Protected Content</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/localforage/dist/localforage.min.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      padding: 30px;
      max-width: 700px;
      width: 100%;
    }
    h1 { font-size: 22px; margin-bottom: 10px; color: #1a202c; }
    p { color: #4a5568; margin-bottom: 15px; font-size: 14px; }
    .input-group { margin-bottom: 16px; }
    .input-group label {
      display: block; margin-bottom: 6px; font-weight: 600;
      color: #4a5568; font-size: 13px;
    }
    .input-group input {
      width: 100%; padding: 10px; border-radius: 8px;
      border: 2px solid #e2e8f0; font-size: 14px; font-family: inherit;
    }
    .input-group input:focus { outline: none; border-color: #667eea; }
    .btn {
      padding: 10px 18px; border-radius: 8px; border: none;
      background: #667eea; color: white; font-weight: 600;
      cursor: pointer; font-size: 14px; gap: 6px;
    }
    #output {
      margin-top: 20px; padding: 12px;
      border-radius: 8px; background: #f8f9fa;
      font-family: 'Courier New', monospace;
      font-size: 13px; white-space: pre-wrap;
      max-height: 350px; overflow-y: auto;
      display:none;
    }
    .status {
      margin-top: 15px; padding: 12px; border-radius: 8px; font-size: 13px;
    }
    .status-info { background: #cfe2ff; color: #084298; }
    .status-success { background: #d1e7dd; color: #0f5132; }
    .status-error { background: #f8d7da; color: #842029; }
  </style>
</head>
<body>

<div class="container">
  <h1>üîê Decrypt Arweave Protected Content</h1>
  <p>
    Supports all Arweave wallet encryption formats:<br>
    ‚Ä¢ <code>{ enc: "pw" }</code> ‚Äî password encrypted<br>
    ‚Ä¢ <code>{ enc: "self" }</code> ‚Äî encrypted for your own wallet<br>
    ‚Ä¢ <code>{ enc: "recipient" }</code> ‚Äî encrypted specifically for you via ECDH
  </p>

  <div class="input-group">
    <label for="arweave-url">Arweave URL</label>
    <input id="arweave-url" type="text" placeholder="https://arweave.net/&lt;TXID&gt;">
  </div>

  <div class="input-group">
    <label for="password">Password (only for <code>enc: "pw"</code>)</label>
    <input id="password" type="text" placeholder="Leave empty for self/recipient">
  </div>

  <button class="btn" id="decrypt-btn" onclick="startDecrypt()">üîì Decrypt</button>
  <div id="status"></div>
  <div id="output"></div>
</div>

<script>
// ---------- Storage (same as wallet) ----------
const WalletStorage = {
  async get(key) { return localforage.getItem("biowallet:" + key); }
};

// ---------- Helpers ----------
function setStatus(msg, type="info") {
  const el = document.getElementById("status");
  el.className = "status status-" + type;
  el.innerHTML = msg;
}
function hexToBytes(hex) {
  const u = new Uint8Array(hex.length/2);
  for (let i=0;i<u.length;i++) u[i]=parseInt(hex.substr(i*2,2),16);
  return u;
}
const CryptoHelper = {
  async decrypt(enc, key) {
    const ct = hexToBytes(enc.ciphertext);
    const iv = hexToBytes(enc.iv);
    const raw = await crypto.subtle.decrypt({name:"AES-GCM",iv}, key, ct);
    return JSON.parse(new TextDecoder().decode(raw));
  }
};

// ---------- WebAuthn PRF ----------
const WebAuthnHelper = {
  async authenticate(credHex) {
    const challenge=crypto.getRandomValues(new Uint8Array(32));
    await navigator.credentials.get({
      publicKey:{
        challenge,
        allowCredentials:[{id:hexToBytes(credHex),type:"public-key"}],
        userVerification:"required"
      }
    });
    return true;
  },

  async evaluatePrf(credHex, saltBytes) {
    const challenge=crypto.getRandomValues(new Uint8Array(32));
    const res=await navigator.credentials.get({
      publicKey:{
        challenge,
        allowCredentials:[{id:hexToBytes(credHex),type:"public-key"}],
        userVerification:"required",
        extensions:{prf:{eval:{first:saltBytes}}}
      }
    });
    const out=res.getClientExtensionResults().prf.results.first;
    return new Uint8Array(out);
  }
};

// ---------- MAIN ----------
async function startDecrypt() {
  const url = document.getElementById("arweave-url").value.trim();
  const password = document.getElementById("password").value.trim();
  const output = document.getElementById("output");
  output.style.display="none";
  output.textContent="";

  if (!url) return setStatus("‚ùå Enter Arweave URL","error");

  setStatus("Fetching Arweave content‚Ä¶","info");

  try {
    const res=await fetch(url);
    if (!res.ok) throw new Error("HTTP "+res.status);
    const text=await res.text();
    const blob=JSON.parse(text);

    if (!blob.enc) throw new Error("Missing enc field");
    if (!blob.data) throw new Error("Missing data field");

    const encType=blob.enc;

    // ---------- PASSWORD ----------
    if (encType==="pw") {
      if (!password) throw new Error("Password required");
      if (!blob.salt) throw new Error("Missing salt");

      setStatus("Deriving password key‚Ä¶","info");

      const baseKey=await crypto.subtle.importKey(
        "raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]
      );
      const aesKey=await crypto.subtle.deriveKey({
        name:"PBKDF2",salt:hexToBytes(blob.salt),iterations:100000,hash:"SHA-256"
      }, baseKey, {name:"AES-GCM",length:256}, false, ["decrypt"]);

      const dec=await CryptoHelper.decrypt(blob.data,aesKey);
      output.textContent=(dec.text??JSON.stringify(dec,null,2));
      output.style.display="block";
      return setStatus("‚úÖ Decrypted (password)","success");
    }

    // ---------- SELF / RECIPIENT ----------
    const credentialId=await WalletStorage.get("credentialId");
    const keyMode=await WalletStorage.get("keyMode");
    if (!credentialId || !keyMode) throw new Error("Wallet not unlocked on this device");

    // SELF MODE
    if (encType==="self") {
      let aesKey=null;

      if (keyMode==="prf") {
        const salt=await WalletStorage.get("prfSaltHex");
        const prf=await WebAuthnHelper.evaluatePrf(credentialId, hexToBytes(salt));

        // HKDF expand PRF
        const hkdfKey = await crypto.subtle.importKey("raw", prf, "HKDF", false, ["deriveKey"]);
        aesKey = await crypto.subtle.deriveKey({
          name:"HKDF",
          hash:"SHA-256",
          salt: hexToBytes(salt),
          info: new Uint8Array([])
        }, hkdfKey, {name:"AES-GCM", length:256}, false, ["decrypt"]);

      } else {
        await WebAuthnHelper.authenticate(credentialId);
        const hex=await WalletStorage.get("aesKeyHex");
        aesKey=await crypto.subtle.importKey("raw",hexToBytes(hex),"AES-GCM",false,["decrypt"]);
      }

      const dec=await CryptoHelper.decrypt(blob.data,aesKey);
      output.textContent=(dec.text??JSON.stringify(dec,null,2));
      output.style.display="block";
      return setStatus("‚úÖ Decrypted (self)","success");
    }

    // ---------- RECIPIENT MODE USING ENCRYPTED ECDH KEY ----------
    if (encType==="recipient") {

      if (!blob.fromPub) throw new Error("Missing sender ephemeral key");

      const encPrivBlobStr = await WalletStorage.get("encPrivKeyEncrypted");
      if (!encPrivBlobStr) throw new Error("Missing encrypted ECDH private key (encPrivKeyEncrypted)");

      const encPrivBlob = JSON.parse(encPrivBlobStr);

      let aesKey=null;

      // ---- PRF MODE ----
      if (keyMode === "prf") {
        const salt = await WalletStorage.get("prfSaltHex");
        const prf = await WebAuthnHelper.evaluatePrf(credentialId, hexToBytes(salt));

        const hkdfKey = await crypto.subtle.importKey("raw", prf, "HKDF", false, ["deriveKey"]);
        aesKey = await crypto.subtle.deriveKey({
          name:"HKDF",
          hash:"SHA-256",
          salt: hexToBytes(salt),
          info: new Uint8Array([])
        }, hkdfKey, {name:"AES-GCM", length:256}, false, ["decrypt"]);

      } else {
        // ---- WRAPPED MODE ----
        await WebAuthnHelper.authenticate(credentialId);
        const aesHex = await WalletStorage.get("aesKeyHex");
        aesKey = await crypto.subtle.importKey("raw", hexToBytes(aesHex), "AES-GCM", false, ["decrypt"]);
      }

      // Decrypt stored private ECDH key
      const { ecdh: privJwk } = await CryptoHelper.decrypt(encPrivBlob, aesKey);

      // Import private key
      const privKey = await crypto.subtle.importKey(
        "jwk",
        privJwk,
        { name:"ECDH", namedCurve:"P-256" },
        false,
        ["deriveBits"]
      );

      // Import sender ephemeral key
      const senderRaw = Uint8Array.from(atob(blob.fromPub), c=>c.charCodeAt(0));
      const senderPub = await crypto.subtle.importKey(
        "raw",
        senderRaw,
        { name:"ECDH", namedCurve:"P-256" },
        false,
        []
      );

      setStatus("Deriving shared secret‚Ä¶","info");

      const bits = await crypto.subtle.deriveBits(
        { name:"ECDH", public: senderPub },
        privKey,
        256
      );

      const aesKeyRecipient = await crypto.subtle.importKey(
        "raw", bits, "AES-GCM", false, ["decrypt"]
      );

      const dec = await CryptoHelper.decrypt(blob.data, aesKeyRecipient);

      output.textContent = (dec.text ?? JSON.stringify(dec,null,2));
      output.style.display="block";
      return setStatus("‚úÖ Decrypted (recipient)","success");
    }

    throw new Error("Unsupported encryption type: "+encType);

  } catch (err) {
    console.error(err);
    setStatus("‚ùå "+err.message,"error");
  }
}

// ---------- Autofill from URL hash ----------
(function init() {
  const url=new URL(window.location.href);
  const link=url.searchParams.get("link") || url.searchParams.get("url");
  if (link) document.getElementById("arweave-url").value=link;

  const hash=window.location.hash;
  if (hash.length>1) {
    try { document.getElementById("password").value=decodeURIComponent(hash.slice(1)); }
    catch { document.getElementById("password").value=hash.slice(1); }
  }
})();
</script>


</body>
</html>

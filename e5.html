<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>USDC Polygon Wallet</title>
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
  <script src="https://unpkg.com/arweave@1.15.5/bundles/web.bundle.js"></script>
  <script src="https://unpkg.com/localforage/dist/localforage.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --md-sys-color-primary: #6750A4;
      --md-sys-color-on-primary: #ffffff;
      --md-sys-color-primary-container: #EADDFF;
      --md-sys-color-on-primary-container: #21005D;
      --md-sys-color-secondary: #625B71;
      --md-sys-color-on-secondary: #ffffff;
      --md-sys-color-secondary-container: #E8DEF8;
      --md-sys-color-surface: #FFFBFE;
      --md-sys-color-on-surface: #1C1B1F;
      --md-sys-color-surface-variant: #E7E0EC;
      --md-sys-color-on-surface-variant: #49454F;
      --md-sys-color-outline: #79747E;
      --md-sys-color-error: #B3261E;
      --radius-lg: 28px;
      --radius-md: 18px;
      --radius-sm: 12px;
      --elev-1: 0 1px 2px rgba(0, 0, 0, 0.12);
      --elev-2: 0 3px 6px rgba(0, 0, 0, 0.16);
      --elev-3: 0 6px 10px rgba(0, 0, 0, 0.20);
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --md-sys-color-primary: #D0BCFF;
        --md-sys-color-on-primary: #381E72;
        --md-sys-color-primary-container: #4F378B;
        --md-sys-color-on-primary-container: #EADDFF;
        --md-sys-color-secondary: #CCC2DC;
        --md-sys-color-on-secondary: #332D41;
        --md-sys-color-secondary-container: #4A4458;
        --md-sys-color-surface: #1C1B1F;
        --md-sys-color-on-surface: #E6E1E5;
        --md-sys-color-surface-variant: #49454F;
        --md-sys-color-on-surface-variant: #CAC4D0;
        --md-sys-color-outline: #938F99;
        --md-sys-color-error: #F2B8B5;
      }
    }
    body {
      background: var(--md-sys-color-surface);
      color: var(--md-sys-color-on-surface);
      font-family: "Roboto", system-ui, sans-serif;
      padding: 32px 16px 80px;
      display: flex;
      justify-content: center;
    }
    .container {
      width: 100%;
      max-width: 860px;
      background: var(--md-sys-color-surface);
      border-radius: var(--radius-lg);
      padding: 36px;
      box-shadow: var(--elev-2);
    }
    .header h1 {
      text-align: center;
      font-size: 32px;
      margin-bottom: 16px;
    }
    .security-badge {
      background: var(--md-sys-color-surface-variant);
      color: var(--md-sys-color-on-surface-variant);
      padding: 18px;
      border-radius: var(--radius-md);
      font-size: 15px;
      margin-bottom: 36px;
      border: 1px solid var(--md-sys-color-outline);
    }
    .btn {
      width: 100%;
      padding: 16px;
      border-radius: var(--radius-md);
      font-size: 16px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 12px 0;
      transition: background 0.2s, transform 0.1s;
      box-shadow: var(--elev-1);
    }
    .btn-primary {
      background: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
    }
    .btn-secondary {
      background: var(--md-sys-color-secondary-container);
      color: var(--md-sys-color-on-secondary-container);
    }
    .btn-danger {
      background: var(--md-sys-color-error);
      color: white;
    }
    .btn-success {
      background: #4CAF50;
      color: white;
    }
    .btn:hover:not(:disabled) {
      transform: scale(1.01);
      filter: brightness(1.05);
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .input-group {
      margin-bottom: 24px;
    }
    .input-group label {
      display: block;
      margin-bottom: 6px;
      font-size: 14px;
      font-weight: 500;
    }
    .input-group input,
    .input-group textarea,
    .input-group select {
      width: 100%;
      padding: 14px;
      border-radius: var(--radius-md);
      border: 1px solid var(--md-sys-color-outline);
      background: var(--md-sys-color-surface-variant);
      color: var(--md-sys-color-on-surface);
      font-size: 16px;
    }
    .status {
      padding: 18px;
      border-radius: var(--radius-md);
      margin-top: 20px;
      font-size: 15px;
      line-height: 1.4;
      font-weight: 500;
    }
    .status-info {
      background: rgba(100, 150, 255, 0.18);
      color: var(--md-sys-color-on-surface);
    }
    .status-success {
      background: rgba(0, 200, 83, 0.18);
      color: #0d4d0d;
    }
    .status-error {
      background: rgba(255, 82, 82, 0.18);
      color: #7b0000;
    }
    .tabs {
      display: flex;
      gap: 6px;
      border-bottom: 2px solid var(--md-sys-color-outline);
      margin-bottom: 20px;
      overflow-x: auto;
    }
    .tab {
      padding: 12px 18px;
      border: none;
      background: none;
      cursor: pointer;
      font-size: 15px;
      color: var(--md-sys-color-on-surface);
      border-bottom: 3px solid transparent;
      transition: all 0.25s;
      border-radius: var(--radius-sm);
      white-space: nowrap;
    }
    .tab.active {
      color: var(--md-sys-color-primary);
      border-bottom-color: var(--md-sys-color-primary);
      font-weight: 600;
    }
    .wallet-info {
      background: var(--md-sys-color-surface-variant);
      padding: 20px;
      border-radius: var(--radius-md);
      margin-bottom: 20px;
      box-shadow: var(--elev-1);
    }
    .wallet-info-label {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--md-sys-color-on-surface-variant);
    }
    .wallet-info-value {
      font-family: monospace;
      padding: 10px;
      background: var(--md-sys-color-surface);
      border-radius: var(--radius-sm);
      word-break: break-all;
      font-size: 13px;
    }
    .balance-card {
      background: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
      padding: 26px;
      border-radius: var(--radius-lg);
      text-align: center;
      margin-bottom: 28px;
      box-shadow: var(--elev-3);
    }
    .balance-amount {
      font-size: 44px;
      font-weight: 700;
      margin-top: 6px;
    }
    .balance-secondary {
      font-size: 24px;
      font-weight: 600;
      margin-top: 12px;
      opacity: 0.9;
    }
    .hidden {
      display: none !important;
    }
    .material-symbols-rounded {
      font-family: 'Material Symbols Rounded';
      font-weight: normal;
      font-style: normal;
      font-size: 24px;
      line-height: 1;
      letter-spacing: normal;
      text-transform: none;
      display: inline-block;
      white-space: nowrap;
      word-wrap: normal;
      direction: ltr;
      -webkit-font-smoothing: antialiased;
    }
    pre {
      background: var(--md-sys-color-surface);
      border-radius: var(--radius-sm);
      padding: 10px;
      font-size: 12px;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üí≥ USDC Polygon Wallet</h1>
    </div>
    <div class="security-badge">
      <strong>Non-Custodial + Passkey Protected</strong>
      Your EVM private key is generated in your browser, encrypted behind WebAuthn, and backed up to Arweave. Funds live only on Polygon in native USDC.
    </div>
    <div id="landing-screen">
      <button class="btn btn-primary" onclick="showCreateScreen()">
        <span class="material-symbols-rounded">add_circle</span>
        Create New Wallet
      </button>
      <button class="btn btn-secondary" onclick="showUnlockScreen()">
        <span class="material-symbols-rounded">lock_open</span>
        Unlock Existing Wallet
      </button>
    </div>
    <div id="create-screen" class="hidden">
      <h2 style="margin-bottom: 20px;">Create Wallet</h2>
      <div class="input-group">
        <label for="username">Username (label only, not on-chain)</label>
        <input type="text" id="username" placeholder="Enter username">
      </div>
      <button class="btn btn-primary" onclick="createWallet()" id="create-btn">
        <span class="material-symbols-rounded">add_circle</span>
        Create Wallet
      </button>
      <button class="btn btn-secondary" onclick="showLanding()">
        <span class="material-symbols-rounded">arrow_back</span>
        Back
      </button>
      <div id="create-status"></div>
    </div>
    <div id="unlock-screen" class="hidden">
      <h2 style="margin-bottom: 20px;">Unlock Wallet</h2>
      <button class="btn btn-primary" onclick="unlockWallet()" id="unlock-btn">
        <span class="material-symbols-rounded">lock_open</span>
        Unlock with Biometrics
      </button>
      <button class="btn btn-secondary" onclick="showLanding()">
        <span class="material-symbols-rounded">arrow_back</span>
        Back
      </button>
      <div id="unlock-status"></div>
    </div>
    <div id="wallet-screen" class="hidden">
      <h2 style="margin-bottom: 20px;">Wallet Active (Polygon ¬∑ USDC)</h2>
      <div class="balance-card">
        <div class="balance-label">Balance</div>
        <div class="balance-amount" id="balance-display">--</div>
        <div class="balance-secondary" id="balance-secondary">USDC on Polygon</div>
        <button class="btn" onclick="refreshBalance()" style="background: rgba(255,255,255,0.2); margin: 12px auto 0; width: auto; padding: 8px 20px;">
          <span class="material-symbols-rounded">refresh</span>
          Refresh
        </button>
      </div>
      <div class="wallet-info">
        <div class="wallet-info-item">
          <div class="wallet-info-label">EVM Address (Polygon)</div>
          <div class="wallet-info-value" id="wallet-address"></div>
        </div>
      </div>
      <div class="tabs">
        <button class="tab active" onclick="showTab('send')">
          <span class="material-symbols-rounded">send</span>
          Send
        </button>
        <button class="tab" onclick="showTab('sign')">
          <span class="material-symbols-rounded">edit_note</span>
          Sign
        </button>
      </div>
      <!-- SEND TAB -->
      <div id="send-tab" class="tab-content">
        <div class="input-group">
          <label for="send-address">Recipient Address</label>
          <input type="text" id="send-address" placeholder="0x...">
        </div>
        <div class="input-group">
          <label for="send-amount" id="send-amount-label">Amount (USDC)</label>
          <input type="number" id="send-amount" placeholder="0.10" step="0.000001" min="0">
        </div>
        <button class="btn btn-primary" onclick="sendTransaction()">
          <span class="material-symbols-rounded">send</span>
          Send USDC
        </button>
      </div>
      <!-- SIGN TAB -->
      <div id="sign-tab" class="tab-content hidden">
        <p style="margin-bottom: 8px; color: var(--md-sys-color-on-surface-variant); font-size: 14px;">
          Manual EIP-191 signing. External apps can also request EIP-191 and EIP-712 signatures via URL parameters.
        </p>
        <div class="input-group">
          <label for="sign-message">Message to Sign (EIP-191)</label>
          <textarea id="sign-message" placeholder="Enter message to sign..."></textarea>
        </div>
        <button class="btn btn-primary" onclick="signEvmMessage()">
          <span class="material-symbols-rounded">edit_note</span>
          Sign Message
        </button>
        <!-- External EIP-712 Request Panel -->
        <div id="typeddata-request" class="wallet-info hidden" style="margin-top: 20px;">
          <div class="wallet-info-item">
            <div class="wallet-info-label">External EIP-712 Sign Request</div>
            <div class="wallet-info-value">
              <pre id="typeddata-json"></pre>
            </div>
          </div>
          <div style="display:flex; gap:10px; margin-top:10px; flex-wrap:wrap;">
            <button class="btn btn-success" style="flex:1;" onclick="approveEip712Request()">
              <span class="material-symbols-rounded">check_circle</span>
              Approve EIP-712 Signature
            </button>
            <button class="btn btn-secondary" style="flex:1;" onclick="rejectEip712Request()">
              <span class="material-symbols-rounded">cancel</span>
              Reject
            </button>
          </div>
        </div>
        <!-- Signature Display -->
        <div id="signature-container" class="wallet-info hidden" style="margin-top: 20px;">
          <div class="wallet-info-item">
            <div class="wallet-info-label">Last Signed Payload</div>
            <div class="wallet-info-value" id="signed-message"></div>
          </div>
          <div class="wallet-info-item">
            <div class="wallet-info-label">Signature (hex)</div>
            <div class="wallet-info-value" id="signature-value"></div>
          </div>
          <div class="wallet-info-item">
            <div class="wallet-info-label">Signer Address</div>
            <div class="wallet-info-value" id="signer-address"></div>
          </div>
        </div>
        <div class="button-group" style="margin-top: 12px;">
          <button class="btn btn-secondary" onclick="copyEvmSignature()">
            <span class="material-symbols-rounded">content_copy</span>
            Copy JSON
          </button>
          <button class="btn btn-success" onclick="verifyEvmSignature()">
            <span class="material-symbols-rounded">check_circle</span>
            Verify Signature
          </button>
        </div>
      </div>
      <div class="button-group" style="margin-top: 20px;">
        <button class="btn btn-success" onclick="exportKeys()">
          <span class="material-symbols-rounded">download</span>
          Export Keys
        </button>
        <button class="btn btn-danger" onclick="lockWallet()">
          <span class="material-symbols-rounded">lock</span>
          Lock Wallet
        </button>
      </div>
      <div id="wallet-status"></div>
    </div>
  </div>
<script>
// ============================================================================
// CONFIG
// ============================================================================
const CLOUD_FUNCTION_URL = 'https://marko-app.netlify.app/.netlify/functions/arload';
const WALLET_APP_NAME = 'USDC-Polygon-Wallet-v1';
// Polygon RPC + native USDC contract
const POLYGON_RPC = 'https://polygon-rpc.com';
// USDC native on Polygon PoS (Circle)
const USDC_CONTRACT = '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359';
// Pimlico bundler for ERC-4337 UserOperations
const PIMLICO_API_KEY = "pim_Do9VqKL2LXkrvzz5xcmNS9";
const BUNDLER_URL = `https://api.pimlico.io/v2/137/rpc?apikey=${PIMLICO_API_KEY}`;// Replace with your Pimlico API key
const ENTRY_POINT = '0x4337084d9e255ff0702461cf8895ce9e3b5ff108'; // ERC-4337 EntryPoint v0.7 on Polygon
const DESIGNATION = '0xe6Cae83BdE06E4c305530e199D7217f42808555B'; // SimpleAccount implementation for EIP-7702
const CHAIN_ID = 137;
// Minimal ERC20 ABI
const ERC20_ABI = [
  "function balanceOf(address owner) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function transfer(address to, uint256 amount) returns (bool)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function symbol() view returns (string)"
];
// SimpleAccount ABI
const ACCOUNT_ABI = [
  "function execute(address dest, uint256 value, bytes calldata func) external",
  "function executeBatch(tuple(address dest, uint256 value, bytes calldata func)[] calldata _calls) external"
];
// EntryPoint ABI for getNonce
const ENTRY_POINT_ABI = [
  "function getNonce(address sender, uint192 key) view returns (uint256)"
];
let arweave = null;
let evmProvider = null;
let evmWallet = null; // This is the owner signer for the smart account
let arweaveWallet = null;
// Pending external requests
let pendingEvmSignRequest = null; // EIP-191
let pendingEvmTxRequest = null; // send USDC
let pendingEvmTypedDataRequest = null; // EIP-712
let lastEvmSignature = null;
// Initialize libs
try {
  if (window.Arweave) {
    arweave = Arweave.init({ host: 'arweave.net', port: 443, protocol: 'https' });
  }
  evmProvider = new ethers.providers.JsonRpcProvider(POLYGON_RPC);
} catch (e) {
  console.error('Initialization error:', e);
}
// ============================================================================
// Storage
// ============================================================================
const WalletStorage = {
  async get(key) {
    return localStorage.getItem('mcwallet:' + key);
  },
  async set(key, value) {
    localStorage.setItem('mcwallet:' + key, value);
  },
  async remove(key) {
    localStorage.removeItem('mcwallet:' + key);
  }
};
// ============================================================================
// Helpers
// ============================================================================
function bytesToHex(bytes) {
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}
function hexToBytes(hex) {
  const clean = hex.startsWith('0x') ? hex.slice(2) : hex;
  const bytes = new Uint8Array(clean.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(clean.substr(i * 2, 2), 16);
  }
  return bytes;
}
// Bundler RPC helper
async function bundlerRpc(method, params) {
  const response = await fetch(BUNDLER_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: 1,
      method,
      params
    })
  });
  const { result, error } = await response.json();
  if (error) throw new Error(error.message || 'Bundler RPC error');
  return result;
}
// Local userOpHash computation for v0.7
function computeUserOpHash(userOp) {
  const initCode = userOp.factory + userOp.factoryData.slice(2);
  const paymasterAndData = userOp.paymaster + userOp.paymasterData.slice(2) + ethers.utils.hexZeroPad(userOp.paymasterVerificationGasLimit, 16).slice(2) + ethers.utils.hexZeroPad(userOp.paymasterPostOpGasLimit, 16).slice(2);
  const packed = ethers.utils.defaultAbiCoder.encode(
    ['address', 'uint256', 'bytes32', 'bytes32',
     'uint256', 'uint256', 'uint256',
     'uint256', 'uint256',
     'bytes32'],
    [userOp.sender, userOp.nonce, ethers.utils.keccak256('0x' + initCode), ethers.utils.keccak256(userOp.callData),
     userOp.callGasLimit, userOp.verificationGasLimit, userOp.preVerificationGas,
     userOp.maxFeePerGas, userOp.maxPriorityFeePerGas,
     ethers.utils.keccak256('0x' + paymasterAndData)]
  );
  const hash = ethers.utils.keccak256(packed);
  const enc = ethers.utils.defaultAbiCoder.encode(
    ['bytes32', 'address', 'uint256'],
    [hash, ENTRY_POINT, CHAIN_ID]
  );
  return ethers.utils.keccak256(enc);
}
// ============================================================================
// WebAuthn Helper
// ============================================================================
const WebAuthnHelper = {
  async register(username) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    const prfSalt = crypto.getRandomValues(new Uint8Array(32));
    const credential = await navigator.credentials.create({
      publicKey: {
        challenge,
        rp: { name: 'USDCPolygon', id: window.location.hostname },
        user: {
          id: crypto.getRandomValues(new Uint8Array(16)),
          name: username,
          displayName: username
        },
        pubKeyCredParams: [{ alg: -7, type: 'public-key' }],
        authenticatorSelection: {
          authenticatorAttachment: 'platform',
          userVerification: 'required'
        },
        timeout: 60000,
        extensions: { prf: { eval: { first: prfSalt } } }
      }
    });
    const credentialIdHex = bytesToHex(new Uint8Array(credential.rawId));
    let prfKeyHex = null;
    if (typeof credential.getClientExtensionResults === 'function') {
      const ext = credential.getClientExtensionResults();
      if (ext?.prf?.results?.first) {
        prfKeyHex = bytesToHex(new Uint8Array(ext.prf.results.first));
      }
    }
    return {
      credentialId: credentialIdHex,
      prfKeyHex,
      prfSaltHex: bytesToHex(prfSalt)
    };
  },
  async authenticate(credentialIdHex) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    await navigator.credentials.get({
      publicKey: {
        challenge,
        allowCredentials: [{ id: hexToBytes(credentialIdHex), type: 'public-key' }],
        userVerification: 'required',
        timeout: 60000
      }
    });
    return true;
  },
  async evaluatePrf(credentialIdHex, saltBytes) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    const assertion = await navigator.credentials.get({
      publicKey: {
        challenge,
        allowCredentials: [{ id: hexToBytes(credentialIdHex), type: 'public-key' }],
        userVerification: 'required',
        timeout: 60000,
        extensions: { prf: { eval: { first: saltBytes } } }
      }
    });
    const ext = assertion.getClientExtensionResults?.();
    if (!ext?.prf?.results?.first) {
      throw new Error('PRF extension not available');
    }
    return new Uint8Array(ext.prf.results.first);
  }
};
// ============================================================================
// Crypto Helper
// ============================================================================
const CryptoHelper = {
  async encrypt(data, key) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      new TextEncoder().encode(JSON.stringify(data))
    );
    return {
      ciphertext: bytesToHex(new Uint8Array(encrypted)),
      iv: bytesToHex(iv)
    };
  },
  async decrypt(encryptedData, key) {
    const ciphertext = hexToBytes(encryptedData.ciphertext);
    const iv = hexToBytes(encryptedData.iv);
    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      key,
      ciphertext
    );
    return JSON.parse(new TextDecoder().decode(decrypted));
  }
};
// ============================================================================
// Upload to cloud function (Arweave backup only)
// ============================================================================
async function uploadToCloudFunction(data, tags) {
  const response = await fetch(CLOUD_FUNCTION_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      content: JSON.stringify(data),
      isBase64: false,
      encrypt: false,
      extraTags: tags
    })
  });
  const result = await response.json();
  if (!response.ok || !result.success) {
    throw new Error(result.message || 'Upload failed');
  }
  return result;
}
// ============================================================================
// Wallet Core
// ============================================================================
const WalletCore = {
  async createWallet(username) {
    if (!arweave) throw new Error('Arweave not loaded');
    const { credentialId, prfKeyHex, prfSaltHex } = await WebAuthnHelper.register(username);
    // Generate Arweave + EVM wallet
    const arJwk = await arweave.wallets.generate();
    const evmMnemonic = ethers.Wallet.createRandom().mnemonic.phrase;
    const evmPrivateKey = ethers.Wallet.fromMnemonic(evmMnemonic).privateKey;
    const evmAddress = ethers.Wallet.fromMnemonic(evmMnemonic).address;
    // Derive AES key from WebAuthn PRF or random fallback
    let aesKey;
    let keyMode;
    if (prfKeyHex) {
      keyMode = 'prf';
      const prfBytes = hexToBytes(prfKeyHex);
      const hkdfKey = await crypto.subtle.importKey(
        "raw", prfBytes, "HKDF", false, ["deriveKey"]
      );
      aesKey = await crypto.subtle.deriveKey(
        {
          name: "HKDF",
          hash: "SHA-256",
          salt: hexToBytes(prfSaltHex),
          info: new Uint8Array([]),
        },
        hkdfKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    } else {
      keyMode = 'wrapped';
      const rawKey = crypto.getRandomValues(new Uint8Array(32));
      aesKey = await crypto.subtle.importKey(
        'raw', rawKey, 'AES-GCM', false, ['encrypt', 'decrypt']
      );
      await WalletStorage.set('aesKeyHex', bytesToHex(rawKey));
    }
    const keysToBackup = {
      arweaveJwk: arJwk,
      evmPrivateKey,
      evmMnemonic
    };
    const encrypted = await CryptoHelper.encrypt(keysToBackup, aesKey);
    const arAddress = await arweave.wallets.jwkToAddress(arJwk);
    const meta = {
      version: '1',
      keyMode,
      credentialId,
      prfSaltHex: keyMode === 'prf' ? prfSaltHex : null,
      username: username || '',
      arweaveAddress: arAddress,
      evmAddress
    };
    const backupPayload = { meta, encrypted };
    const tags = {
      'App-Name': WALLET_APP_NAME,
      'User-Arweave-Address': arAddress,
      'User-EVM-Address': evmAddress,
      'User-Name': username || '',
      'Wallet-KeyMode': keyMode,
      'Timestamp': Date.now().toString()
    };
    const uploadResult = await uploadToCloudFunction(backupPayload, tags);
    const txId = uploadResult.arweaveId;
    // Persist small metadata locally
    await WalletStorage.set('credentialId', credentialId);
    await WalletStorage.set('arweaveAddress', arAddress);
    await WalletStorage.set('evmAddress', evmAddress);
    await WalletStorage.set('backupTxId', txId);
    await WalletStorage.set('keyMode', keyMode);
    await WalletStorage.set('username', username || '');
    if (keyMode === 'prf' && prfSaltHex) {
      await WalletStorage.set('prfSaltHex', prfSaltHex);
    }
    // Set in-memory wallets
    arweaveWallet = arJwk;
    evmWallet = new ethers.Wallet(evmPrivateKey, evmProvider);
    return {
      arweaveAddress: arAddress,
      evmAddress,
      backupTxId: txId
    };
  },
  async unlockWallet() {
    const credentialId = await WalletStorage.get('credentialId');
    const backupTxId = await WalletStorage.get('backupTxId');
    if (!credentialId || !backupTxId) {
      throw new Error('No wallet data found');
    }
    const res = await fetch(`https://arweave.net/${backupTxId}`);
    if (!res.ok) throw new Error('Failed to fetch wallet backup');
    const encryptedBlob = await res.json();
    const meta = encryptedBlob.meta || {};
    let keyMode = await WalletStorage.get('keyMode') || meta.keyMode;
    if (!keyMode) throw new Error('Missing key mode');
    let aesKey;
    if (keyMode === 'prf') {
      const prfSaltHex = await WalletStorage.get('prfSaltHex') || meta.prfSaltHex;
      if (!prfSaltHex) throw new Error('Missing PRF salt');
      const prfBytes = await WebAuthnHelper.evaluatePrf(
        credentialId, hexToBytes(prfSaltHex)
      );
      const hkdfKey = await crypto.subtle.importKey(
        "raw", prfBytes, "HKDF", false, ["deriveKey"]
      );
      aesKey = await crypto.subtle.deriveKey(
        {
          name: "HKDF",
          hash: "SHA-256",
          salt: hexToBytes(prfSaltHex),
          info: new Uint8Array([]),
        },
        hkdfKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    } else {
      const aesKeyHex = await WalletStorage.get('aesKeyHex');
      if (!aesKeyHex) throw new Error('Missing AES key');
      await WebAuthnHelper.authenticate(credentialId);
      aesKey = await crypto.subtle.importKey(
        'raw', hexToBytes(aesKeyHex), 'AES-GCM', false, ['encrypt', 'decrypt']
      );
    }
    const decrypted = await CryptoHelper.decrypt(encryptedBlob.encrypted, aesKey);
    arweaveWallet = decrypted.arweaveJwk;
    evmWallet = new ethers.Wallet(decrypted.evmPrivateKey, evmProvider);
    const arAddress = await arweave.wallets.jwkToAddress(arweaveWallet);
    const evmAddress = evmWallet.address;
    await WalletStorage.set('arweaveAddress', arAddress);
    await WalletStorage.set('evmAddress', evmAddress);
    return {
      arweaveAddress: arAddress,
      evmAddress,
      backupTxId
    };
  },
  async getUSDCBalance() {
    if (!evmWallet) throw new Error('EVM wallet not loaded');
    const contract = new ethers.Contract(USDC_CONTRACT, ERC20_ABI, evmProvider);
    const balance = await contract.balanceOf(evmWallet.address);
    const decimals = await contract.decimals();
    return ethers.utils.formatUnits(balance, decimals);
  },
  async sendUSDC(toAddress, amount) {
    if (!evmWallet) throw new Error('EVM wallet not loaded');
    const sender = evmWallet.address;
    const entryPoint = new ethers.Contract(ENTRY_POINT, ENTRY_POINT_ABI, evmProvider);
    const nonce = await entryPoint.getNonce(sender, 0);
    const account = new ethers.Contract(sender, ACCOUNT_ABI, evmProvider); // Dummy for interface
    const usdc = new ethers.Contract(USDC_CONTRACT, ERC20_ABI, evmProvider);
    const decimals = await usdc.decimals();
    const amountWei = ethers.utils.parseUnits(amount.toString(), decimals);
    const dummyPaymaster = '0x0000000000000000000000000000000000000000';
    const approveCalldata = usdc.interface.encodeFunctionData('approve', [dummyPaymaster, ethers.constants.MaxUint256]);
    const transferCalldata = usdc.interface.encodeFunctionData('transfer', [toAddress, amountWei]);
    const calls = [
      { dest: USDC_CONTRACT, value: '0x0', func: approveCalldata },
      { dest: USDC_CONTRACT, value: '0x0', func: transferCalldata }
    ];
    const callData = account.interface.encodeFunctionData('executeBatch', [calls]);
    let userOp = {
      sender,
      nonce: nonce.toHexString(),
      factory: '0x0000000000000000000000000000000000000000',
      factoryData: '0x',
      callData,
      callGasLimit: '0x0',
      verificationGasLimit: '0x0',
      preVerificationGas: '0x0',
      maxFeePerGas: '0x0',
      maxPriorityFeePerGas: '0x0',
      paymaster: '0x0000000000000000000000000000000000000000',
      paymasterVerificationGasLimit: '0x0',
      paymasterPostOpGasLimit: '0x0',
      paymasterData: '0x',
      signature: '0x'
    };
    const gasPrice = await bundlerRpc('pimlico_getUserOperationGasPrice', []);
    userOp.maxFeePerGas = gasPrice.fast.maxFeePerGas;
    userOp.maxPriorityFeePerGas = gasPrice.fast.maxPriorityFeePerGas;
    let estimate = await bundlerRpc('eth_estimateUserOperationGas', [userOp, ENTRY_POINT]);
    userOp.callGasLimit = estimate.callGasLimit;
    userOp.verificationGasLimit = estimate.verificationGasLimit;
    userOp.preVerificationGas = estimate.preVerificationGas;
    const sponsorshipInfo = {
      mode: 'erc20',
      token: USDC_CONTRACT
    };
    let sponsorResult = await bundlerRpc('pm_sponsorUserOperation', [userOp, ENTRY_POINT, sponsorshipInfo]);
    userOp.paymaster = sponsorResult.paymaster;
    userOp.paymasterData = sponsorResult.paymasterData;
    userOp.paymasterVerificationGasLimit = sponsorResult.paymasterVerificationGasLimit;
    userOp.paymasterPostOpGasLimit = sponsorResult.paymasterPostOpGasLimit;
    if (sponsorResult.callGasLimit) userOp.callGasLimit = sponsorResult.callGasLimit;
    if (sponsorResult.verificationGasLimit) userOp.verificationGasLimit = sponsorResult.verificationGasLimit;
    if (sponsorResult.preVerificationGas) userOp.preVerificationGas = sponsorResult.preVerificationGas;
    // Update approve to the actual paymaster
    const approveCalldataUpdated = usdc.interface.encodeFunctionData('approve', [userOp.paymaster, ethers.constants.MaxUint256]);
    const callsUpdated = [
      { dest: USDC_CONTRACT, value: '0x0', func: approveCalldataUpdated },
      { dest: USDC_CONTRACT, value: '0x0', func: transferCalldata }
    ];
    userOp.callData = account.interface.encodeFunctionData('executeBatch', [callsUpdated]);
    // Re-estimate
    estimate = await bundlerRpc('eth_estimateUserOperationGas', [userOp, ENTRY_POINT]);
    userOp.callGasLimit = estimate.callGasLimit;
    userOp.verificationGasLimit = estimate.verificationGasLimit;
    userOp.preVerificationGas = estimate.preVerificationGas;
    sponsorResult = await bundlerRpc('pm_sponsorUserOperation', [userOp, ENTRY_POINT, sponsorshipInfo]);
    userOp.paymaster = sponsorResult.paymaster;
    userOp.paymasterData = sponsorResult.paymasterData;
    userOp.paymasterVerificationGasLimit = sponsorResult.paymasterVerificationGasLimit;
    userOp.paymasterPostOpGasLimit = sponsorResult.paymasterPostOpGasLimit;
    if (sponsorResult.callGasLimit) userOp.callGasLimit = sponsorResult.callGasLimit;
    if (sponsorResult.verificationGasLimit) userOp.verificationGasLimit = sponsorResult.verificationGasLimit;
    if (sponsorResult.preVerificationGas) userOp.preVerificationGas = sponsorResult.preVerificationGas;
    // Compute userOpHash
    const userOpHash = computeUserOpHash(userOp);
    // Sign EIP-7702 authorization
    const txNonce = await evmProvider.getTransactionCount(sender, 'pending');
    const domain = {
      chainId: CHAIN_ID,
      verifyingContract: sender
    };
    const types = {
      SetCodeAuthorization: [
        { name: 'nonce', type: 'uint256' },
        { name: 'designation', type: 'address' }
      ]
    };
    const value = {
      nonce: txNonce,
      designation: DESIGNATION
    };
    const authSig = await evmWallet._signTypedData(domain, types, value);
    const v = parseInt(authSig.slice(-2), 16);
    const yParity = v - 27;
    const r = authSig.slice(2, 66);
    const s = authSig.slice(66, 130);
    const authorizationTuple = [DESIGNATION, yParity, '0x' + r, '0x' + s];
    const encodedAuthorizations = ethers.utils.defaultAbiCoder.encode(
      ['tuple(address designation, uint8 yParity, bytes32 r, bytes32 s)[]'],
      [[authorizationTuple]]
    );
    // Owner signature over userOpHash
    const ownerSig = await evmWallet.signMessage(ethers.utils.arrayify(userOpHash));
    // Full signature: 0x03 + encoded authorizations + ownerSig
    const prefix = '0x03';
    const fullSignature = prefix + encodedAuthorizations.slice(2) + ownerSig.slice(2);
    userOp.signature = fullSignature;
    // Send userOp
    const opHash = await bundlerRpc('eth_sendUserOperation', [userOp, ENTRY_POINT]);
    let receipt = null;
    while (!receipt) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      receipt = await bundlerRpc('eth_getUserOperationReceipt', [opHash]);
    }
    return receipt.receipt.transactionHash;
  }
};
// ============================================================================
// UI Helpers
// ============================================================================
function showScreen(screenId) {
  ['landing-screen', 'create-screen', 'unlock-screen', 'wallet-screen'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  });
  const target = document.getElementById(screenId);
  if (target) target.classList.remove('hidden');
}
function showLanding() {
  showScreen('landing-screen');
}
function showCreateScreen() {
  showScreen('create-screen');
  setStatus('create-status', '', 'info');
}
function showUnlockScreen() {
  showScreen('unlock-screen');
  setStatus('unlock-status', '', 'info');
}
function showTab(tabName) {
  document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
  const allTabs = document.querySelectorAll('.tabs .tab');
  allTabs.forEach(btn => {
    if (btn.textContent.toLowerCase().includes(tabName)) {
      btn.classList.add('active');
    }
  });
  ['send-tab', 'sign-tab'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  });
  const target = document.getElementById(`${tabName}-tab`);
  if (target) target.classList.remove('hidden');
}
function setStatus(elementId, message, type = 'info') {
  const element = document.getElementById(elementId);
  if (!element) return;
  if (!message) {
    element.innerHTML = '';
    return;
  }
  element.innerHTML = `<div class="status status-${type}">${message}</div>`;
}
// Initialize wallet UI with EVM address + balance
async function initWalletUI() {
  const evmAddress = await WalletStorage.get('evmAddress');
  const addrEl = document.getElementById('wallet-address');
  if (addrEl) addrEl.textContent = evmAddress || '--';
  await refreshBalance();
}
// ============================================================================
// URL Request Parsing (sign + send)
// ============================================================================
function parseUrlRequests() {
  try {
    const url = new URL(window.location.href);
    const params = url.searchParams;
    // --- EIP-191 sign request ---
    const signMessage =
      params.get('signMessage') ||
      params.get('sign') ||
      params.get('messageToSign');
    if (signMessage) {
      pendingEvmSignRequest = {
        message: decodeURIComponent(signMessage),
        origin: params.get('origin') || params.get('app') || url.origin,
        callbackUrl: params.get('callback') || params.get('redirect') || null
      };
    }
    // --- EIP-712 typed data sign request ---
    const typedDataParam =
      params.get('typedData') ||
      params.get('eip712') ||
      params.get('signTypedData');
    if (typedDataParam) {
      try {
        const decoded = decodeURIComponent(typedDataParam);
        const parsed = JSON.parse(decoded);
        pendingEvmTypedDataRequest = {
          typedData: parsed,
          origin: params.get('origin') || params.get('app') || url.origin,
          callbackUrl: params.get('callback') || params.get('redirect') || null
        };
      } catch (e) {
        console.warn('Failed to parse EIP-712 typedData URL param:', e);
      }
    }
    // --- USDC transfer request ---
    const chain = (params.get('chain') || '').toLowerCase();
    if (!chain || chain === 'polygon' || chain === 'evm') {
      const to = params.get('to') || params.get('address');
      const amount = params.get('amount');
      const token = (params.get('token') || 'USDC').toUpperCase();
      const autoSend = params.get('autoSend') === '1' || params.get('autoSend') === 'true';
      if (to && amount) {
        pendingEvmTxRequest = {
          to,
          amount,
          token,
          autoSend,
          callbackUrl: params.get('txCallback') || null
        };
      }
    }
  } catch (e) {
    console.warn('Failed to parse URL params:', e);
  }
}
// Apply pending sign / send requests after wallet is ready
async function applyPendingRequests() {
  // Signing first
  if (pendingEvmSignRequest) {
    const { message, origin } = pendingEvmSignRequest;
    showScreen('wallet-screen');
    await initWalletUI();
    showTab('sign');
    const msgEl = document.getElementById('sign-message');
    if (msgEl) msgEl.value = message;
    setStatus(
      'wallet-status',
      `üîó External sign request from <strong>${origin}</strong>. Review the message and click "Sign Message".`,
      'info'
    );
  }
  if (pendingEvmTypedDataRequest) {
    const { typedData, origin } = pendingEvmTypedDataRequest;
    showScreen('wallet-screen');
    await initWalletUI();
    showTab('sign');
    const tdEl = document.getElementById('typeddata-json');
    if (tdEl) {
      tdEl.textContent = JSON.stringify(typedData, null, 2);
    }
    const container = document.getElementById('typeddata-request');
    if (container) container.classList.remove('hidden');
    setStatus(
      'wallet-status',
      `üîó External EIP-712 sign request from <strong>${origin}</strong>. Review and approve or reject.`,
      'info'
    );
  }
  // Payment request
  if (pendingEvmTxRequest) {
    const { to, amount, token, autoSend } = pendingEvmTxRequest;
    showScreen('wallet-screen');
    await initWalletUI();
    showTab('send');
    const addrInput = document.getElementById('send-address');
    const amtInput = document.getElementById('send-amount');
    if (addrInput) addrInput.value = to;
    if (amtInput) amtInput.value = amount;
    setStatus(
      'wallet-status',
      `üîó External payment request loaded for ${amount} ${token} to ${to}. Review and press "Send".`,
      'info'
    );
    if (autoSend) {
      try {
        await sendTransaction();
      } catch (e) {
        console.error('Auto-send failed:', e);
      }
    }
  }
}
// ============================================================================
// Core UI Actions
// ============================================================================
async function createWallet() {
  const username = document.getElementById('username').value.trim();
  if (!username) {
    setStatus('create-status', 'Please enter a username', 'error');
    return;
  }
  const btn = document.getElementById('create-btn');
  btn.disabled = true;
  setStatus('create-status', 'Creating wallet...', 'info');
  try {
    const result = await WalletCore.createWallet(username);
    showScreen('wallet-screen');
    await initWalletUI();
    setStatus(
      'wallet-status',
      `‚úÖ Wallet created!<br>Polygon (USDC) address: ${result.evmAddress}`,
      'success'
    );
    await applyPendingRequests();
  } catch (error) {
    console.error(error);
    setStatus('create-status', `‚ùå Error: ${error.message}`, 'error');
  } finally {
    btn.disabled = false;
  }
}
async function unlockWallet() {
  const btn = document.getElementById('unlock-btn');
  btn.disabled = true;
  setStatus('unlock-status', 'Unlocking wallet...', 'info');
  try {
    await WalletCore.unlockWallet();
    showScreen('wallet-screen');
    await initWalletUI();
    setStatus('wallet-status', '‚úÖ Wallet unlocked!', 'success');
    await applyPendingRequests();
  } catch (error) {
    console.error(error);
    setStatus('unlock-status', `‚ùå Error: ${error.message}`, 'error');
  } finally {
    btn.disabled = false;
  }
}
async function refreshBalance() {
  try {
    const usdcBalance = await WalletCore.getUSDCBalance();
    document.getElementById('balance-display').textContent =
      `${parseFloat(usdcBalance).toFixed(2)} USDC`;
    document.getElementById('balance-secondary').textContent = 'Polygon Network';
  } catch (err) {
    console.error(err);
    document.getElementById('balance-display').textContent = 'Error';
  }
}
// ============================================================================
// Signing
// ============================================================================
async function signEvmMessage() {
  const msg = document.getElementById('sign-message').value.trim();
  if (!msg) {
    setStatus('wallet-status', '‚ùå Please enter a message to sign', 'error');
    return;
  }
  if (!evmWallet) {
    setStatus('wallet-status', '‚ùå EVM wallet not loaded. Unlock first.', 'error');
    return;
  }
  try {
    setStatus('wallet-status', 'Signing message with Polygon wallet‚Ä¶', 'info');
    const signature = await evmWallet.signMessage(msg);
    const address = evmWallet.address;
    lastEvmSignature = {
      type: 'EIP191',
      message: msg,
      signature,
      address
    };
    document.getElementById('signed-message').textContent = msg;
    document.getElementById('signature-value').textContent = signature;
    document.getElementById('signer-address').textContent = address;
    document.getElementById('signature-container').classList.remove('hidden');
    setStatus('wallet-status', '‚úÖ Message signed', 'success');
    // Optional callback for EIP-191
    if (pendingEvmSignRequest && pendingEvmSignRequest.callbackUrl) {
      try {
        const url = new URL(pendingEvmSignRequest.callbackUrl);
        url.searchParams.set('signature', signature);
        url.searchParams.set('address', address);
        url.searchParams.set('sigType', 'EIP191');
        window.location.href = url.toString();
      } catch (e) {
        console.warn('Callback redirect failed:', e);
      }
    }
    // Clear pending sign request once handled
    pendingEvmSignRequest = null;
  } catch (error) {
    console.error(error);
    setStatus('wallet-status', `‚ùå Error while signing: ${error.message}`, 'error');
  }
}
async function approveEip712Request() {
  if (!pendingEvmTypedDataRequest) {
    setStatus('wallet-status', '‚ùå No EIP-712 request pending', 'error');
    return;
  }
  if (!evmWallet) {
    setStatus('wallet-status', '‚ùå EVM wallet not loaded. Unlock first.', 'error');
    return;
  }
  const { typedData, callbackUrl } = pendingEvmTypedDataRequest;
  try {
    setStatus('wallet-status', 'Signing EIP-712 typed data‚Ä¶', 'info');
    const domain = typedData.domain || {};
    const types = { ...(typedData.types || {}) };
    const primaryType = typedData.primaryType;
    const message = typedData.message || {};
    delete types.EIP712Domain;
    const signature = await evmWallet._signTypedData(domain, types, message);
    const address = evmWallet.address;
    lastEvmSignature = {
      type: 'EIP712',
      typedData,
      primaryType,
      signature,
      address
    };
    document.getElementById('signed-message').textContent =
      JSON.stringify({ domain, primaryType, message }, null, 2);
    document.getElementById('signature-value').textContent = signature;
    document.getElementById('signer-address').textContent = address;
    document.getElementById('signature-container').classList.remove('hidden');
    const reqBox = document.getElementById('typeddata-request');
    if (reqBox) reqBox.classList.add('hidden');
    setStatus('wallet-status', '‚úÖ EIP-712 typed data signed', 'success');
    if (callbackUrl) {
      try {
        const url = new URL(callbackUrl);
        url.searchParams.set('signature', signature);
        url.searchParams.set('address', address);
        url.searchParams.set('sigType', 'EIP712');
        window.location.href = url.toString();
      } catch (e) {
        console.warn('Callback redirect failed:', e);
      }
    }
    pendingEvmTypedDataRequest = null;
  } catch (error) {
    console.error(error);
    setStatus('wallet-status', `‚ùå Error while signing typed data: ${error.message}`, 'error');
  }
}
function rejectEip712Request() {
  pendingEvmTypedDataRequest = null;
  const reqBox = document.getElementById('typeddata-request');
  if (reqBox) reqBox.classList.add('hidden');
  setStatus('wallet-status', 'EIP-712 request rejected by user.', 'info');
}
function copyEvmSignature() {
  if (!lastEvmSignature) {
    setStatus('wallet-status', '‚ùå Nothing to copy yet', 'error');
    return;
  }
  const payload = JSON.stringify(lastEvmSignature, null, 2);
  navigator.clipboard.writeText(payload).then(() => {
    setStatus('wallet-status', '‚úÖ Signature JSON copied to clipboard', 'success');
  }).catch(err => {
    console.error(err);
    setStatus('wallet-status', '‚ùå Failed to copy to clipboard', 'error');
  });
}
async function verifyEvmSignature() {
  if (!lastEvmSignature) {
    setStatus('wallet-status', '‚ùå No signature to verify', 'error');
    return;
  }
  try {
    setStatus('wallet-status', 'Verifying signature‚Ä¶', 'info');
    let recovered;
    if (lastEvmSignature.type === 'EIP191') {
      recovered = ethers.utils.verifyMessage(
        lastEvmSignature.message,
        lastEvmSignature.signature
      );
    } else if (lastEvmSignature.type === 'EIP712') {
      const { typedData, signature } = lastEvmSignature;
      const domain = typedData.domain || {};
      const types = { ...(typedData.types || {}) };
      const primaryType = typedData.primaryType;
      const message = typedData.message || {};
      delete types.EIP712Domain;
      recovered = ethers.utils.verifyTypedData(domain, types, message, signature);
    }
    if (!recovered) {
      setStatus('wallet-status', '‚ùå Unable to recover signer from signature', 'error');
      return;
    }
    if (recovered.toLowerCase() === lastEvmSignature.address.toLowerCase()) {
      setStatus(
        'wallet-status',
        `‚úÖ Signature is VALID. Recovered signer: ${recovered}`,
        'success'
      );
    } else {
      setStatus(
        'wallet-status',
        `‚ö†Ô∏è Signature valid but signer ${recovered} does not match stored address ${lastEvmSignature.address}`,
        'error'
      );
    }
  } catch (error) {
    console.error(error);
    setStatus('wallet-status', `‚ùå Verification error: ${error.message}`, 'error');
  }
}
// ============================================================================
// Sending USDC (EOA-based for now)
// ============================================================================
async function sendTransaction() {
  const toAddress = document.getElementById('send-address').value.trim();
  const amount = document.getElementById('send-amount').value;
  if (!toAddress || !amount || parseFloat(amount) <= 0) {
    setStatus('wallet-status', '‚ùå Please enter valid recipient and amount', 'error');
    return;
  }
  if (!evmWallet) {
    setStatus('wallet-status', '‚ùå EVM wallet not loaded. Unlock first.', 'error');
    return;
  }
  setStatus('wallet-status', 'Sending Polygon USDC transaction...', 'info');
  try {
    const txId = await WalletCore.sendUSDC(toAddress, amount);
    setStatus(
      'wallet-status',
      `‚úÖ USDC sent! TX: <a href="https://polygonscan.com/tx/${txId}" target="_blank">${txId.substring(0, 20)}...</a>`,
      'success'
    );
    document.getElementById('send-address').value = '';
    document.getElementById('send-amount').value = '';
    setTimeout(refreshBalance, 2000);
    if (pendingEvmTxRequest && pendingEvmTxRequest.callbackUrl) {
      try {
        const url = new URL(pendingEvmTxRequest.callbackUrl);
        url.searchParams.set('txHash', txId);
        window.location.href = url.toString();
      } catch (e) {
        console.warn('TX callback redirect failed:', e);
      }
    }
    pendingEvmTxRequest = null;
  } catch (error) {
    console.error(error);
    setStatus('wallet-status', `‚ùå Error: ${error.message}`, 'error');
  }
}
// ============================================================================
// Export / Lock
// ============================================================================
function exportKeys() {
  if (!arweaveWallet || !evmWallet) {
    setStatus('wallet-status', '‚ùå No wallet loaded', 'error');
    return;
  }
  const exportData = {
    arweave: arweaveWallet,
    evm: {
      privateKey: evmWallet.privateKey,
      address: evmWallet.address
    }
  };
  const dataStr = JSON.stringify(exportData, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'usdc-polygon-wallet-keys.json';
  link.click();
  URL.revokeObjectURL(url);
  setStatus('wallet-status', '‚úÖ Keys exported! Keep them safe!', 'success');
}
function lockWallet() {
  arweaveWallet = null;
  evmWallet = null;
  pendingEvmSignRequest = null;
  pendingEvmTxRequest = null;
  pendingEvmTypedDataRequest = null;
  lastEvmSignature = null;
  showLanding();
}
// ============================================================================
// Global bindings
// ============================================================================
window.showCreateScreen = showCreateScreen;
window.showUnlockScreen = showUnlockScreen;
window.showLanding = showLanding;
window.createWallet = createWallet;
window.unlockWallet = unlockWallet;
window.sendTransaction = sendTransaction;
window.refreshBalance = refreshBalance;
window.exportKeys = exportKeys;
window.lockWallet = lockWallet;
window.showTab = showTab;
window.signEvmMessage = signEvmMessage;
window.copyEvmSignature = copyEvmSignature;
window.verifyEvmSignature = verifyEvmSignature;
window.approveEip712Request = approveEip712Request;
window.rejectEip712Request = rejectEip712Request;
// Parse URL on load
parseUrlRequests();
</script>
</body>
</html>


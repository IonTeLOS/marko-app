<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Secure Filebin Uploader</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen p-4">
<div class="max-w-3xl mx-auto space-y-6">

  <!-- Upload Card -->
  <div class="bg-white rounded-xl shadow p-6 space-y-4">
    <h1 class="text-xl font-semibold">Upload to Filebin</h1>
    <input type="file" id="fileInput" class="block w-full text-sm" />
    <textarea id="textInput" placeholder="Or paste text here (saved as note.txt)" class="w-full border rounded p-2 text-sm" rows="4"></textarea>
    <div class="flex items-center gap-2">
      <input type="checkbox" id="encryptCheckbox" />
      <label for="encryptCheckbox" class="text-sm">Encrypt file (AES-GCM)</label>
    </div>
    <div id="message" class="text-sm text-amber-600 hidden"></div>
    <button id="uploadBtn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Upload</button>
  </div>

  <!-- Uploads List -->
  <div class="bg-white rounded-xl shadow p-6 space-y-4">
    <h2 class="text-lg font-semibold">Recent uploads</h2>
    <div id="uploadsList" class="space-y-3"></div>
    <button id="showMoreBtn" class="text-sm text-blue-600 hidden">Show more</button>
  </div>
</div>

<script>
/* ================= Utilities ================= */
const uploadsKey = "filebin_uploads";

function uuid() { return crypto.randomUUID(); }
function humanTime(ts) { return new Date(ts).toLocaleString(); }
function saveUploads(list) { localStorage.setItem(uploadsKey, JSON.stringify(list)); }
function loadUploads() { return JSON.parse(localStorage.getItem(uploadsKey) || "[]"); }
function formatSize(bytes) {
  return bytes < 1024 ? bytes + " B"
       : bytes < 1024*1024 ? (bytes/1024).toFixed(1) + " KB"
       : (bytes/1024/1024).toFixed(1) + " MB";
}

function b64urlEncode(bytes) {
  return btoa(String.fromCharCode(...bytes))
    .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

function b64urlDecode(str) {
  str = str.replace(/-/g, "+").replace(/_/g, "/");
  while (str.length % 4) str += "=";
  return Uint8Array.from(atob(str), c=>c.charCodeAt(0));
}

/* ================= Crypto ================= */
async function encryptFile(buffer) {
  const key = await crypto.subtle.generateKey(
    { name: "AES-GCM", length: 256 },
    true,
    ["encrypt","decrypt"]
  );
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, buffer);
  const rawKey = await crypto.subtle.exportKey("raw", key);
  return {
    encryptedBytes: new Uint8Array(encrypted),
    iv,
    key: new Uint8Array(rawKey)
  };
}

async function decryptFile(buffer, keyBytes, iv) {
  const key = await crypto.subtle.importKey("raw", keyBytes, "AES-GCM", false, ["decrypt"]);
  const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, buffer);
  return new Uint8Array(decrypted);
}

/* ================= Upload ================= */
document.getElementById("uploadBtn").onclick = async () => {
  const fileInput = document.getElementById("fileInput");
  const textInput = document.getElementById("textInput");
  const encrypt = document.getElementById("encryptCheckbox").checked;
  const msg = document.getElementById("message");
  msg.classList.add("hidden");

  let file, filename, iv, key;

  if (fileInput.files.length) {
    file = fileInput.files[0];
    filename = file.name;
    if (textInput.value.trim()) {
      msg.textContent = "File selected â€” text input will be ignored.";
      msg.classList.remove("hidden");
    }
  } else if (textInput.value.trim()) {
    file = new Blob([textInput.value], { type: "text/plain" });
    filename = "note.txt";
  } else {
    alert("Select a file or enter text.");
    return;
  }

  // Encrypt if requested
if (encrypt) {
  const enc = await encryptFile(await file.arrayBuffer());
  file = new Blob([enc.encryptedBytes]);
  filename = "encrypted";
  iv = b64urlEncode(enc.iv);
  key = b64urlEncode(enc.key);
}


  const bin = uuid(); // new UUID bin
  const url = `https://filebin.net/${bin}/${encodeURIComponent(filename)}`;

  try {
    const res = await fetch(url, { method: "POST", body: file });
    if (!res.ok) {
      const text = await res.text();
      alert("Upload failed: " + text);
      return;
    }
  } catch(e) {
    alert("Upload failed: " + e);
    return;
  }

  const fileUrl = `https://filebin.net/${bin}/${filename}`;

  // Save metadata
  const uploads = loadUploads();
  uploads.unshift({
    id: uuid(),
    bin,
    filename,
    originalName: filename === "encrypted" ? (fileInput.files[0]?.name || "note.txt") : filename,
    size: file.size,
    time: Date.now(),
    encrypted: encrypt,
    iv,
    key
  });
  saveUploads(uploads);
  renderUploads();
};

/* ================= Render ================= */
let visibleCount = 10;
function renderUploads() {
  const list = document.getElementById("uploadsList");
  const showMore = document.getElementById("showMoreBtn");
  list.innerHTML = "";

  const uploads = loadUploads();
  uploads.slice(0, visibleCount).forEach((u, i) => {
    const filebinUrl = `https://filebin.net/${u.bin}/${u.filename}`;
    const shareUrl = `${location.origin}${location.pathname}?bin=${u.bin}&file=${encodeURIComponent(u.filename)}` +
                     (u.encrypted ? `#key=${encodeURIComponent(u.key)}&iv=${encodeURIComponent(u.iv)}` : "");

    const row = document.createElement("div");
    row.className = "border rounded p-3 flex flex-col gap-2";
    row.innerHTML = `
      <div class="text-sm">
        <strong>#${i+1}</strong>
        <a href="${filebinUrl}" target="_blank" class="text-blue-600 underline ml-1">
          ${u.originalName}
        </a> (${formatSize(u.size)})<br/>
        <span class="text-gray-500">${humanTime(u.time)}</span>
      </div>
      <div class="flex gap-2">
        <button class="share bg-gray-200 px-2 py-1 rounded text-sm">Share</button>
        <button class="delete bg-red-100 text-red-600 px-2 py-1 rounded text-sm">Delete</button>
      </div>
    `;

    row.querySelector(".share").onclick = async () => {
      if (navigator.share) {
        navigator.share({ url: shareUrl });
      } else {
        await navigator.clipboard.writeText(shareUrl);
        alert("Link copied to clipboard");
      }
    };

    row.querySelector(".delete").onclick = async () => {
      await fetch(`https://filebin.net/${u.bin}`, { method: "DELETE" });
      saveUploads(loadUploads().filter(x => x.id !== u.id));
      renderUploads();
    };

    list.appendChild(row);
  });

  showMore.classList.toggle("hidden", uploads.length <= visibleCount);
}

document.getElementById("showMoreBtn").onclick = () => {
  visibleCount += 10;
  renderUploads();
};

/* ================= Shared link handler ================= */
(async function handleSharedLink() {
  const params = new URLSearchParams(location.search);
  if (!params.has("bin") || !params.has("file")) return;

  const bin = params.get("bin");
  const file = params.get("file");

  // Extract key and iv from URL hash
  const hashParams = new URLSearchParams(location.hash.slice(1));
  const keyB64 = hashParams.get("key");
  const ivB64 = hashParams.get("iv");

  try {
    // Fetch the encrypted file as bytes
    const res = await fetch(`https://filebin.net/${bin}/${file}`);
    if (!res.ok) { alert("File not found."); return; }

    let encryptedBytes = new Uint8Array(await res.arrayBuffer());
    let finalData = encryptedBytes;

    // Only decrypt if key and iv exist
    if (keyB64 && ivB64) {
      const keyBytes = b64urlDecode(keyB64); // returns Uint8Array
      const ivBytes = b64urlDecode(ivB64);   // returns Uint8Array

      try {
        finalData = await decryptFile(encryptedBytes, keyBytes, ivBytes);
      } catch (err) {
        console.error(err);
        alert("Decryption failed (wrong key or corrupted file).");
        return;
      }
    }

    // Download the result
    const blob = new Blob([finalData]);
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = file === "encrypted" ? hashParams.get("origName") || "note.txt" : file;
    a.click();

  } catch (err) {
    console.error(err);
    alert("Failed to fetch or decrypt file: " + err);
  }
})();

renderUploads();
</script>
</body>
</html>

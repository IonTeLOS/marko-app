<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Secure Filebin Uploader</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen p-4">
<div class="max-w-3xl mx-auto space-y-6">

  <div class="bg-white rounded-xl shadow p-6 space-y-4">
    <h1 class="text-xl font-semibold">Upload to Filebin</h1>
    <input type="file" id="fileInput" class="block w-full text-sm" />
    <textarea id="textInput" placeholder="Or paste text here (saved as note.txt)" class="w-full border rounded p-2 text-sm" rows="4"></textarea>
    <div class="flex items-center gap-2">
      <input type="checkbox" id="encryptCheckbox" />
      <label for="encryptCheckbox" class="text-sm">Encrypt file (AES-GCM)</label>
    </div>
    <div id="message" class="text-sm text-amber-600 hidden"></div>
    <button id="uploadBtn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Upload</button>
  </div>

  <div class="bg-white rounded-xl shadow p-6 space-y-4">
    <h2 class="text-lg font-semibold">Recent uploads</h2>
    <div id="uploadsList" class="space-y-3"></div>
    <button id="showMoreBtn" class="text-sm text-blue-600 hidden">Show more</button>
  </div>
</div>

<script>
/* ================= Utilities ================= */
const uploadsKey = "filebin_uploads";

function uuid() { return crypto.randomUUID().split('-')[0]; }
function humanTime(ts) { return new Date(ts).toLocaleString(); }
function saveUploads(list) { localStorage.setItem(uploadsKey, JSON.stringify(list)); }
function loadUploads() { return JSON.parse(localStorage.getItem(uploadsKey) || "[]"); }

/* ================= 1. CRYPTO HELPERS ================= */
// Consistent hex helpers
const bufToHex = (buf) => Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');

const hexToBuf = (hex) => {
    if (!hex) return new Uint8Array();
    // Remove any non-hex characters just in case
    const cleanHex = hex.replace(/[^0-9a-fA-F]/g, '');
    const matches = cleanHex.match(/.{1,2}/g);
    return new Uint8Array(matches ? matches.map(byte => parseInt(byte, 16)) : []);
};

async function encryptFile(buffer) {
    // Generate a 256-bit key
    const key = await crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt"]
    );

    // Generate a 12-byte IV (24 hex chars)
    const iv = crypto.getRandomValues(new Uint8Array(12));

    // Encrypting... This returns an ArrayBuffer containing [Ciphertext][Tag]
    const encryptedBuffer = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv: iv },
        key,
        buffer
    );

    return {
        data: new Uint8Array(encryptedBuffer), // 16 bytes longer than original
        iv: bufToHex(iv),
        key: bufToHex(await crypto.subtle.exportKey("raw", key))
    };
}

async function decryptFile(buffer, keyHex, ivHex) {
    const keyBuf = hexToBuf(keyHex);
    const ivBuf = hexToBuf(ivHex);

    const key = await crypto.subtle.importKey(
        "raw",
        keyBuf,
        { name: "AES-GCM" },
        false,
        ["decrypt"]
    );

    // FIX: Ensure we are passing the underlying ArrayBuffer
    const decrypted = await crypto.subtle.decrypt(
        {
            name: "AES-GCM",
            iv: ivBuf // The IV must be exactly 12 bytes (24 hex chars)
        },
        key,
        buffer.buffer || buffer // Handles both Uint8Array and ArrayBuffer
    );

    return new Uint8Array(decrypted);
}

/* ================= 2. THE DOWNLOADER (Your Version) ================= */
async function downloadAndDecrypt(bin, file, keyHex, ivHex, origName) {
  const msg = document.getElementById("message");
  msg.classList.remove("hidden");
  msg.innerText = `ðŸ”„ Processing ${decodeURIComponent(origName)}...`;

  try {
    const fileUrl = `https://filebin.net/${bin}/${file}`;
    const res = await fetch(fileUrl);
    if (!res.ok) throw new Error("File not found.");

    const blob = await res.blob();
    let data = new Uint8Array(await blob.arrayBuffer());

    // LOGS FOR DEBUGGING (Check your F12 console)
    console.log("File received, length:", data.length);
    console.log("Key present:", !!keyHex, "IV present:", !!ivHex);

    // FIX: Tightened check for keys (handles strings "null" or "undefined")
    const hasKey = keyHex && keyHex !== 'null' && keyHex !== 'undefined' && keyHex.length > 0;
    const hasIv = ivHex && ivHex !== 'null' && ivHex !== 'undefined' && ivHex.length > 0;

    if (hasKey && hasIv) {
      msg.innerText = "ðŸ” Decrypting...";
      try {
        // We use the existing decryptFile function
        console.log("Data Length:", data.byteLength); // Should match 'bytes' in your CURL response
console.log("Key Hex Length:", keyHex.length); // Should be exactly 64 for AES-256
console.log("IV Hex Length:", ivHex.length);   // Should be exactly 24
        const decryptedBuffer = await decryptFile(data, keyHex, ivHex);
        data = new Uint8Array(decryptedBuffer);
        console.log("Decryption successful!");
      } catch (e) {
        console.error("Decryption Error:", e);
        throw new Error("Decryption failed. Data might be corrupted or key is invalid.");
      }
    } else {
      console.warn("Skipping decryption: No valid keys found in parameters.");
    }

    // Trigger the save
    const finalBlob = new Blob([data], { type: 'application/octet-stream' });
    const downloadUrl = URL.createObjectURL(finalBlob);
    const a = document.createElement("a");
    a.href = downloadUrl;
    a.download = decodeURIComponent(origName);
    document.body.appendChild(a);
    a.click();

    setTimeout(() => {
        URL.revokeObjectURL(downloadUrl);
        a.remove();
        msg.classList.add("hidden");
    }, 500);

  } catch (err) {
    alert("Error: " + err.message);
    msg.classList.add("hidden");
  }
}

/* ================= 3. UPLOAD LOGIC ================= */
document.getElementById("uploadBtn").onclick = async () => {
    const file = document.getElementById("fileInput").files[0];
    if (!file) return alert("Select a file");

    const encrypt = document.getElementById("encryptCheckbox").checked;
    const btn = document.getElementById("uploadBtn");
    btn.disabled = true; btn.innerText = "Uploading...";

    try {
        const originalBuffer = await file.arrayBuffer();
        let uploadPayload;
        let iv = null, key = null;

        if (encrypt) {
            const result = await encryptFile(originalBuffer);
            uploadPayload = result.data; // The Uint8Array (Ciphertext + Tag)
            iv = result.iv;
            key = result.key;
        } else {
            uploadPayload = new Uint8Array(originalBuffer);
        }

        const binId = crypto.randomUUID().split('-')[0];
        const url = `https://filebin.net/${binId}/${encodeURIComponent(file.name)}`;

        // FIX: Wrap in Blob and explicitly set headers
        const blobPayload = new Blob([uploadPayload], { type: 'application/octet-stream' });

        const res = await fetch(url, {
            method: "POST",
            headers: {
                'Content-Type': 'application/octet-stream',
                'Content-Length': blobPayload.size.toString() // Tell the server exactly what to expect
            },
            body: blobPayload
        });

        if (!res.ok) throw new Error(`Upload failed: ${res.status}`);

        console.log("Uploaded successfully. Expected size:", blobPayload.size);

        // Save metadata
        const uploads = JSON.parse(localStorage.getItem("filebin_uploads") || "[]");
        uploads.unshift({ bin: binId, filename: file.name, iv, key, time: Date.now(), encrypted: encrypt });
        localStorage.setItem("filebin_uploads", JSON.stringify(uploads));

        renderUploads();
    } catch (e) {
        alert(e.message);
    } finally {
        btn.disabled = false; btn.innerText = "Upload";
    }
};

/* ================= Shared Link Entry Point ================= */
(async function handleSharedLink() {
  const params = new URLSearchParams(location.search);
  if (!params.has("bin") || !params.has("file")) return;

  const bin = params.get("bin");
  const file = params.get("file");
  const hashParams = new URLSearchParams(location.hash.slice(1));

  // Get metadata from the URL hash
  const keyHex = hashParams.get("k");
  const ivHex = hashParams.get("i");
  const origName = hashParams.get("n") || "downloaded_file";

  // Trigger the download immediately for shared links
  downloadAndDecrypt(bin, file, keyHex, ivHex, origName);
})();

/* ================= List Rendering ================= */
function renderUploads() {
  const list = document.getElementById("uploadsList");
  list.innerHTML = "";

  loadUploads().forEach(u => {
    // Shared URL for others
    let hashParts = [`n=${encodeURIComponent(u.originalName)}`];
    if (u.encrypted) hashParts.push(`k=${u.key}`, `i=${u.iv}`);
    const shareUrl = `${window.location.origin}${window.location.pathname}?bin=${u.bin}&file=${encodeURIComponent(u.filename)}#${hashParts.join('&')}`;

    const row = document.createElement("div");
    row.className = "border rounded p-3 flex justify-between items-center bg-white shadow-sm";

    // We use a <span> with styling instead of an <a> tag to prevent the browser
    // from trying to download the raw "data.bin" directly.
    row.innerHTML = `
      <div class="text-sm">
        <span
            role="button"
            onclick="downloadAndDecrypt('${u.bin}', '${u.filename}', '${u.key}', '${u.iv}', '${encodeURIComponent(u.originalName)}')"
            class="font-bold text-blue-600 cursor-pointer hover:underline">
            ${u.originalName}
        </span> ${u.encrypted ? 'ðŸ”’' : ''}<br/>
        <span class="text-gray-400 text-xs">${humanTime(u.time)}</span>
      </div>
      <div class="flex gap-3">
        <button class="text-blue-600 text-sm font-semibold" onclick="navigator.clipboard.writeText('${shareUrl}'); alert('Link Copied!')">Copy Link</button>
        <button class="text-red-400 text-sm" onclick="deleteUpload('${u.id}', '${u.bin}')">Delete</button>
      </div>
    `;
    list.appendChild(row);
  });
}

window.deleteUpload = (id, bin) => {
    fetch(`https://filebin.net/${bin}`, { method: 'DELETE' });
    saveUploads(loadUploads().filter(x => x.id !== id));
    renderUploads();
};

renderUploads();
</script>
</script>
</body>
</html>

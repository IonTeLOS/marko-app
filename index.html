<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="description" content="A new way to bookmark. Sync your links between devices. Create content and share it with your friends and the world. Get a fresh, minimal social profile.">
<meta name="keywords" content="bookmark, local, search engine, share link, google drive, light social presence, notify on change">
  <title>Marko</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="theme-color" content="#0d47a1">
<meta name="msapplication-TileColor" content="#0d47a1">
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="512x512" href="appLogo_512.png">
<link rel="icon" type="image/svg+xml" href="triskelion_back.svg">
<link rel="mask-icon" href="safari-pinned-tab.svg" color="#0d47a1">
<link rel="manifest" href="manifest.json">
  <!-- Open Graph -->
<meta property="og:type" content="website" />
<meta property="og:title" content="Marko" />
<meta property="og:description" content="A sophisticated bookmarking application" />
<meta property="og:url" content="https://marko-app.netlify.app" />

<meta property="og:image" content="https://marko-app.netlify.app/og.png" />
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="630" />

<!-- Twitter/X -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Marko" />
<meta name="twitter:description" content="A sophisticated bookmarking application" />
<meta name="twitter:image" content="https://marko-app.netlify.app/og.png" />
<meta name="twitter:image:width" content="1200" />
<meta name="twitter:image:height" content="630" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js" type="module"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js" type="module"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-installations.js" type="module"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js" type="module"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-messaging.js" type="module"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions.js" type="module"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.9.0/localforage.min.js"></script>
<script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://documentcloud.adobe.com/view-sdk/main.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Icons+Outlined" rel="stylesheet">
<script src="https://unpkg.com/easymde/dist/easymde.min.js"></script> 
<script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>    
    <!-- Google Icons -->
<script src="https://unpkg.com/showdown/dist/showdown.min.js"></script>
    <!-- Materialize JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/notiflix@3/dist/notiflix-aio-3.2.7.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/notiflix@3/src/notiflix.min.css" rel="stylesheet">
<script type="speculationrules">
{
  "prerender": [
    {
      "source": "list",
      "urls": [
        "https://marko-app.netlify.app/createmarko",
        "https://marko-app.netlify.app/login",
        "https://marko-app.netlify.app/logout",
        "https://marko-app.netlify.app/profile2"
      ],
      "eagerness": "immediate"
    }
  ]
}
</script>

<style>
body {
  font-family: Roboto, sans-serif;
  position: relative;
  display: flex;
  min-height: 100vh;
  justify-content: center;
  flex-direction: column;
  max-width: 100%;
  overflow-x: hidden;
  height: auto !important;    
  margin: 8px !important;
  padding: 0;
  padding-bottom: 150px;  transition: background-color 0.2s ease-in-out, color; /* place for last bookmark */
}
    
body.light-mode {
  background-color: #e3f2fd;
  color: #333333;
}

body.light-mode .bookmark {
  background-color: #bbdefb;
}
    
body.dark-mode {
  background-color: #292929;
  color: #999999;
}

body.dark-mode .bookmark {
background-color: #1f1b24;
}
      
.bookmarks-container {
      flex: 100;
      display: flex;
      flex-direction: column;
      display: 'block';
    }      






      
      .bookmark-wrapper {
        width: 100%;
      }  

    .bookmark .icon-wrapper {
      display: flex;
      align-items: center;
      flex: 1;
    }

    .bookmark .icon-container {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 72px; /* Standard width */
      height: 72px; /* Standard height */
      border-radius: 50%;
      transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
      margin-right: 16px;
      background-color: #fff; /* Light background */
    }

    .bookmark:hover .icon-container,
    .bookmark-title:hover {
      transform: scale(1.1); /* Enlarge container on hover */
    }

.bookmark {    
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px;
  border-radius: 4px;
  cursor: pointer;
  position: relative;
  margin-bottom: 8px;
  border: 4px solid transparent;
  background-clip: padding-box;
}

.bookmark::before {
    content: '';
    position: absolute;
    top: -4px; /* Adjusted from -2px to -4px */
    right: -4px;
    bottom: -4px;
    left: -4px;
    z-index: -1;
    border-radius: inherit;
    background: transparent;
    transition: background 0.3s ease, border 0.3s ease;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.bookmark:hover {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Adjusted shadow color and intensity */
}

.bookmark.active {
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
}

.bookmark .bookmark-title {
  font-weight: bold;
  text-align: center;
  flex: 1;
  transition: transform 0.2s ease-in-out;
}

.bookmark:hover .bookmark-title {
  transform: scale(1.20);
}

/* Hover effect (if needed, but make sure it doesnâ€™t override swipe states) */
.bookmark:hover::before {
  background: blue;
  animation: blink 2s infinite; /* Ensure duration and iteration are set */
}

/* Swiped left state */
.bookmark.swipe-left:not(#main-bookmark)::before {
background: linear-gradient(to right, #FF0000, rgba(255, 0, 0, 0.1));
}

/* Swiped right state */
.bookmark.swipe-right:not(#main-bookmark)::before {
background: linear-gradient(to left, #00FF00, rgba(0,255,0,0.1));  
}
  
.icon-container {
            width: 72px; /* Adjust as needed */
            height: 72px; /* Adjust as needed */
            position: relative;
            overflow: hidden;
        }
.icon-container::before {
            content: '';
            position: absolute;
            width: 62px; /* 72px (size of container) - 5px (border) * 2 */
            height: 62px; /* Same calculation as width */
            border-radius: 50%; /* Makes the ring circular */
            border: 5px solid var(--ring-color, #2ecc71); /* Thickness and color of the ring TODO change default color */
            box-sizing: border-box; /* Ensures the border is included in the size */
        }  
.bookmark-icon {
  font-size: 36px;
  object-fit: contain; /* Adjust to 'contain' if you prefer the image to be fully visible */
  display: block;    
  transition: color 0.2s ease-in-out, transform 0.2s ease-in-out;
}

.bookmark:hover .bookmark-icon {
  color: #0d47a1;
}

    .delete-icon {
      color: #f44336; /* Material Design error color */
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%); /* Center icon vertically */
      opacity: 0; /* Initially hide the delete icon */
      transition: opacity 0.2s ease-in-out, color 0.2s ease-in-out, transform 0.2s ease-in-out; /* Add transitions */
      font-size: 24px; /* Smaller than main icons */
    }

    .bookmark:hover .delete-icon,
    .bookmark.long-press .delete-icon {
      opacity: 1; /* Show delete icon on hover or long press */
      transform: translateY(-50%) scale(1.1); /* Scale up while maintaining vertical center */
    }

    .delete-icon:hover {
      color: #d32f2f; /* Darker red on hover */
      cursor: pointer; /* Change cursor to indicate clickability */
      transform: translateY(-50%) scale(1.2); /* Scale up more on direct hover */
    }
.bookmark .bell-icon,
.bookmark .next-icon {
    position: absolute; /* Position bell icon absolutely */
    top: 50%;
    right: 10px; /* Adjust as necessary */
    transform: translateY(-50%); /* Center icon vertically */
    font-size: 24px; /* Smaller than main icons */
}
    .bell-icon:hover,
    .next-icon {
      color: #ffd700; /* Darker red on hover */
      cursor: pointer; /* Change cursor to indicate clickability */
      transform: translateY(-50%) scale(1.2); /* Scale up more on direct hover */
    }    

    .content {
      display: none; /* Initially hide content divs */
      padding: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-top: 8px;
    }
   

      [id^="bookmark-"]:hover {
          color: #ffffff;
      } 

    
/* System Default (initial state) */
@media (prefers-color-scheme: light) {
  body {
    background-color: #e3f2fd; /* Align with .body.light-mode */
    color: #333333; /* Align with .body.light-mode */
  }
  .bookmark {
    background-color: #bbdefb; /* Align with .body.light-mode .bookmark */
    transition: background-color 0.2s ease-in-out; /* Smooth transition on background color change */
  }
}

/* Hover effect for .bookmark and related elements */
.body.light-mode .bookmark:hover {
  background-color: #acc8e5; /* Lighter background on hover */
}
    
/* System Default (initial state) */
@media (prefers-color-scheme: dark) {
  body {
    background-color: #292929;
    color: #999999;
  }
  .bookmark {
    background-color: #1f1b24;
    transition: background-color 0.2s ease-in-out; /* Smooth transition on background color change */
  }
}

/* Hover effect for .bookmark and related elements */
.body.dark-mode .bookmark:hover {
  background-color: #333; /* Darker background on hover */
}
  
.context-menu {
    position: fixed;
    transform: translate(-50%, -50%);
    display: none;
    z-index: 1000;
    animation: zoomIn 0.4s ease-out; /* Apply zoom-in animation */
}

#current-link .ml-3 {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}
  
.context-menu .material-icons-outlined {
    color: orange; /* Set icon color to orange */
}
/* Light mode styles */
@media (prefers-color-scheme: light) {
    .context-menu {
        color: #0D47A1; /* Set background color for light mode */
    }
}  
/* Animation for the context menu */
@keyframes zoomIn {
    0% {
        transform: scale(0.8); /* Start scaled down */
        opacity: 0;
    }
    50% {
        transform: scale(1.05); /* Slightly zoom in beyond final scale */
    }
    100% {
        transform: scale(1); /* Final scale */
        opacity: 1;
    }
}


  
input {
  padding-right: 30px; /* Space for the clear button */
  font-size: 16px;
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
  outline: none;
  color: darkcyan; 
}

input:focus {
  border-color: #007bff;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}

.clear-btn {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  cursor: pointer;
  font-size: 18px;
  color: #999;
  padding: 0;
  line-height: 1;
}

.clear-btn:hover {
  color: #333;
}


.clear-btn:hover {
  color: #333;
}

#icon-select { 
  cursor: pointer; 
  background: none; 
  border: none; 
  padding: 0; 
  display: flex; 
  align-items: center; 
  justify-content: center; 
  width: 56px; 
  height: 56px; 
  transition: background-color 0.3s; 
}

#icon-select:hover, #icon-select:focus { 
  background-color: rgba(0, 0, 0, 0.1); 
}
        #search { 
  flex-grow: 1; 
  height: 56px; 
  font-size: 16px; 
  border: none; 
  outline: none; 
  margin-left: 10px; 
  padding: 0 15px; 
  width: 90%;
  box-sizing: border-box;

}

#icon-name { 
  margin: 0 15px 0 0; 
  font-size: 1rem; 
}

#color-select { 
  display: flex; 
  align-items: center; 
  justify-content: center; 
  width: 56px; 
  height: 56px; 
  font-size: 12px; 
  font-weight: bold; 
  color: white; 
  text-shadow: 0 0 3px rgba(0, 0, 0, 0.5); 
  cursor: pointer; 
}

.card-panel { 
  position: relative; 
  z-index: 1; 
  display: flex; 
  flex-direction: column; 
  align-items: stretch; 
  padding: 0; 
}

#icon-select .material-icons-outlined { font-size: 32px; }
#icon-dropdown {
  display: none;
  position: fixed; /* Change from absolute to fixed */
  z-index: 1000;
  background-color: white;
  border-radius: 4px;
  box-shadow: 0 8px 17px 2px rgba(0,0,0,0.14), 0 3px 14px 2px rgba(0,0,0,0.12), 0 5px 5px -3px rgba(0,0,0,0.2);
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90%;
  max-width: 400px;
  max-height: 80vh; /* Set max height to 80% of viewport height */
  overflow-y: auto;
  padding: 10px;
}

#icon-selection-container {
  position: relative;
  overflow: hidden;
}

#icon-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
  gap: 10px;
}

.icon { text-align: center; cursor: pointer; padding: 10px; border-radius: 4px; transition: background-color 0.3s; }
.icon:hover { background-color: #f0f0f0; }
.material-icons-outlined { font-size: 24px; }
.material-icons-outlined { color: black; }
    


#color-select { display: flex; align-items: center; justify-content: center; width: 56px; height: 56px; font-size: 12px; font-weight: bold; color: white; text-shadow: 0 0 3px rgba(0, 0, 0, 0.5); cursor: pointer; }
        @media only screen and (min-width: 601px) {
            .container { width: 90%; }
        }


    .input-field {
      margin-bottom: 20px;
      position: relative;
  
    }

    .input-field input[type="url"],
    .input-field input[type="text"],
    .input-field input[type="tel"],
    .input-field select,
    .input-field textarea {
      display: block;
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }

    .icon-source-selector {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .icon-source-selector select {
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: white;
      appearance: auto;
    }

    .menu-container {
      display: flex;
      gap: 20px;
      justify-content: center;
    }

    .menu-container button {
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #18488e;
      color: white;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      font-size: 24px;
      overflow: hidden;
      position: relative;
      border: none;
      cursor: pointer;
    }

    .menu-container button i {
      font-size: 36px;
    }

    .menu-container button::before {
      content: "";
      position: absolute;
      top: 50%;
      left: 50%;
      width: 200%;
      height: 200%;
      background-color: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
      transform: translate(-50%, -50%) scale(0);
      transition: transform 0.4s;
    }

    .menu-container button:active::before {
      transform: translate(-50%, -50%) scale(1);
      transition: 0s;
    }

.bookmark-button {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 20px;
}

.bookmark-button .btn {
  display: flex;
  align-items: center;
  background-color: #18488e; /* Customize as needed */
  color: white;
  padding: 20px 40px; /* Significantly increase padding for a larger button */
  border-radius: 10px; /* Adjust border radius as needed */
  text-transform: none;
  font-size: 24px; /* Increase font size */
  transition: background-color 0.3s ease;
}

.bookmark-button .btn:hover {
  background-color: #123366; /* Customize hover color as needed */
}

.bookmark-button .btn i.material-icons {
  margin-right: 12px; /* Increase margin for better spacing */
  font-size: 32px; /* Increase icon size */
}
        #new-link-url,
        #new-link-name, 
        #phone-number-field, 
        #window-url {
            font-size: 2em; /* Increase font size */
            padding: 10px; /* Increase padding for better touch target */
            border: 1px solid #ccc; /* Add a border */
            border-radius: 4px; /* Round the corners */
            width: 100%; /* Make the input field take the full width */
            box-sizing: border-box; /* Ensure padding and border are included in the width */
        }
        #icon-source,
        #link-type {
            font-size: 1.5em; /* Increase font size */
            justify-content: center;
            padding: 5px;
            width: 100%; /* Make the input field take the full width */
        }

        .offline-banner {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background-color: #ffcc00; /* Adjust color as needed */
            color: #333; /* Adjust text color as needed */
            text-align: center;
            padding: 10px;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
            z-index: 998; /* Ensure it appears above other elements */
            transition: transform 0.3s ease-in-out; /* Smooth transition for sliding effect */
            transform: translateY(100%); /* Initially hidden off the bottom of the viewport */
            visibility: hidden; /* Initially hidden */
        }

        /* Show the banner */
        .offline-banner.show {
            transform: translateY(0); /* Move to its normal position */
            visibility: visible; /* Make it visible */
        }

        .dark-mode-switch {
            position: fixed;
            bottom: 50px;
            left: 20px;
            display: flex;
            align-items: center;
            z-index: 1000; /* Ensure the switch appears above the offline banner */
      }
         iframe {
            aspect-ratio: 16/9;
            width: 100%;
        }
    
.container {
  transition: margin-bottom 0.3s ease;
  margin-bottom: 40px;    
}    
#menu-container {
  display: flex;
  justify-content: center;
  align-items: center;
  bottom: 80px; /* Positioned just above the always visible element */
  height: 80px;
  background-color: #4267B2;
  transition: transform 0.3s ease, opacity 0.3s ease, visibility 0.3s ease;
  opacity: 0;
  visibility: hidden;
  transform: translateY(100%);
}

#menu-container.visible {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}

#menu-container.hidden {
  opacity: 0;
  visibility: hidden;
  transform: translateY(100%);
}
.form-buttons {
  position: fixed;
  left: 0;
  width: 100%;
  height: 80px;    
  background-color: #4267B2;
  box-sizing: border-box;
  z-index: 999;
  text-align: center; /* Center the buttons horizontally */
  justify-content: center;    
  display: flex;
  align-items: center;
  transform: translateY(0);
  transition: transform 0.3s ease-in-out;
}
.form-buttons.hidden {
  transform: translateY(100%);
}    

.add-banner {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 80px;     
  background-color: #0D47A1;
  margin-bottom: 0;    
  box-sizing: border-box;
  z-index: 1000;
  text-align: center; /* Center the buttons horizontally */
  justify-content: center; 
  overflow: visible;
  white-space: nowrap;
}

      
.material-btn {
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  transition: color 0.2s ease-in-out, transform 0.2s ease-in-out, background 0.2s ease-in-out;
  height: 72px;
  width: 72px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  margin: 0 10px;
}

.material-btn:hover {
  color: #333333;
  transform: scale(1.1);
}

.material-btn .material-icon {
  font-size: 42px; /* Change the icon size to 48x48 */
}
  
.material-btn:focus {
  outline: none;
  background-color: rgba(255, 255, 255, 0.3); /* Darker background on focus */
}

.material-btn:focus-visible {
  outline: none;
  background-color: rgba(255, 255, 255, 0.3); /* Darker background on focus */
}

   /* The overlay for the modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.4);
            justify-content: center;
            align-items: center;
            overflow: hidden;

        }

    

/* The actual content of the modal */
.modal-content {
    background-color: #fff;
    margin: 0;
    padding: 20px;
    z-index: 1000;
    border-radius: 0;
    max-width: none; /* Remove the max-width constraint */
    box-shadow: none; /* Remove the box-shadow */
    display: flex;
    flex-direction: column;
}

.close {
  color: cyan;
  font-size: 42px;
  font-weight: bold;
  position: absolute;
  top: 10px;
  right: 50px;
  padding: 10px;
  cursor: pointer;
  transition: color 0.3s;
}

.tabs {
    display: flex;
    justify-content: space-between;
    margin-top: 20px;
}

.tab-link {
    background-color: #444;
    border: none;
    color: white;
    padding: 10px 20px;
    cursor: pointer;
    transition: background-color 0.2s;
    flex: 1;
    text-align: center;
}

.tab-link:hover {
    background-color: #555;
}

.tab-link.active {
    background-color: #666;
}

.tab-content {
    flex: 1;
    display: flex;
    justify-content: center;
    padding: 20px 0;
}

.tab-page {
    display: none;
    width: 100%;
}

.tab-page.active {
    display: block;
}

@media (max-width: 600px) {
    .tab-link {
        padding: 8px 12px;
    }
    .modal-content {
        width: 95%;
    }
}
    .lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
      z-index: 1002;
    }
    .lightbox.active {
      display: flex;
    }
    .lightbox-content {
      position: relative;
      width: 90%;
      height: 90%;
      max-width: 100%;
      max-height: 100%;
      background-color: white;
      border-radius: 10px;
    }
    .lightbox-content .content-container {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      position: relative;
    }
    /* Option 1: Iframe with absolute positioning */
    .lightbox-content iframe {
      width: 100%;
      height: 100%;
      border: none;
      position: absolute;
      overflow-x: hidden;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 10px; /* Rounded corners for iframe */
    }
 /* Closing Button (outside lightbox) */
    .close-btn {
      position: fixed; /* Make the element absolutely positioned */
      bottom: 5px; /* Position the element at the bottom */
      left: 50%; /* Position the element horizontally at 50% */
      transform: translateX(-50%); /* Center the element horizontally */
      background-color: #3f51b5; /* Material Blue */
      color: white;
      border: none;
      width: 38px;
      height: 38px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 1002; /* Ensure button is on top of lightbox */
      font-size: 24px; /* Adjust font size for desired icon size */
      border-radius: 50%;
      box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2); /* Material shadow effect */
    }
    .close-btn:hover {
      background-color: #384890
      }  
      #player-container {
      width: 100%;
      max-width: 640px;
      aspect-ratio: 16 / 9;
      margin-top: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    @media (max-width: 768px) {
      #player-container {
        width: 95%;
      }
    }
    @media (orientation: landscape) and (max-width: 900px) {
      #player-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        max-width: none;
        margin: 0;
        z-index: 9999;
      }
    }
        #youtube-lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;        }
        #youtube-lightbox.active {
            display: flex;
        }
        #player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #close-yt {
            position: absolute;
            top: 90px;
            right: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffffff;
            color: #ffffff;
            cursor: pointer;
            font-size: 24px;
            opacity: 1;
            transition: opacity 0.3s;
            z-index: 9999;
        }
        #close-yt.hidden {
            opacity: 0;
            pointer-events: none;
        }
.g-button {
    display: inline-flex;
    align-items: center;
    justify-content: center; /* Center the text horizontally */
    background-color: #4285f4;
    color: white;
    border: none;
    border-radius: 3px;
    font-family: 'Roboto', sans-serif;
    font-size: 14px;
    font-weight: 500;
    padding: 20px 10px;
    margin: 7px;
    width: 150px; /* Set a fixed width */
    height: 40px; /* Set a fixed height */
    cursor: pointer;
    transition: background-color 0.3s;
    box-sizing: border-box; /* Ensure padding and border are included in the total width and height */
}

.g-button:hover {
    background-color: #357ae8; /* Add a hover effect */
}

.g-button .material-icons {
    margin-right: 10px;
}
    
    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    .spinning {
        animation: spin 1s linear infinite;
    }
    .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
        }
.install-banner {
    display: none;
    position: fixed;
    top: -110px; /* Initially hidden above the viewport */
    left: 0;
    width: 100%;
    height: 110px;
    background-color: #ffa426;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    cursor: pointer;
    z-index: 10001;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    transition: top 1s ease; /* Smooth drop-down effect */
    border-bottom: 4px solid white; /* White line at the bottom */
}

.install-banner .material-icons {
    font-size: 36px;
    margin-top: 20px;
}

.install-banner p {
    margin: 0;
    font-size: 20px;
    font-weight: bold;
}

.close-banner {
    position: absolute;
    top: 10px; /* Adjust this value to position the close button */
    right: 10px; /* Adjust this value to position the close button */
    font-size: 32px;
    cursor: pointer;
    color: white;
    padding: 10px; /* Padding around the close button */
    background-color: rgba(255, 255, 255, 0.1); /* Semi-transparent background */
    border-radius: 50%; /* Rounded shape */
    transition: background-color 0.3s ease; /* Smooth transition */
    z-index: 10002; /* Higher z-index to ensure it covers elements below */
}

.close-banner:hover {
    background-color: rgba(255, 255, 255, 0.3); /* Darker background on hover */
}



    /* Light Mode Styles */
    .bg-white {
        background-color: #ffffff;
    }

    .border-gray-300 {
        border-color: #e5e7eb;
    }

    .text-gray-500 {
        color: #6b7280;
    }

    .hover\:bg-gray-100:hover {
        background-color: #f3f4f6;
    }

    .text-gray-900 {
        color: #111827;
    }

    .dark\:bg-gray-700 {
        background-color: #374151;
    }

    .dark\:border-gray-700 {
        border-color: #4b5563;
    }

    .dark\:text-gray-300 {
        color: #d1d5db;
    }

    .dark\:hover\:bg-gray-700:hover {
        background-color: #4a5568;
    }

    /* Material Icons Styles */
    .material-icons-outlined {
        font-family: 'Material Icons Outlined';
        font-weight: normal;
        font-style: normal;
        font-size: 1.5rem; /* Adjust icon size */
        line-height: 1;
        letter-spacing: normal;
        text-transform: none;
        display: inline-block;
        white-space: nowrap;
        word-wrap: normal;
        direction: ltr;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        vertical-align: middle;
    }

        .no-select {
            user-select: none;
        }
.tooltip {
    position: fixed;
    bottom: 85px; /* Adjust as needed */
    left: 10px; /* Adjust as needed */
    width: 16rem; /* 256px (w-64 in tailwindcss) */
    background-color: #ffffff; /* White background */
    border: 1px solid #cccccc; /* Gray border */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Shadow effect */
    padding: 5px 10px;
    border-radius: 4px;
    display: none;
    z-index: 1003; /* Set z-index to 1003 */
    font-size: 0.875rem; /* 14px (text-sm in tailwindcss) */
    color: #0d47a1; /* Blue text color */
    white-space: nowrap; /* Prevent line breaks */
    overflow: hidden; /* Hide overflowing content */
}

.tooltip-content {
    display: inline-block;
    white-space: nowrap;
    position: relative;
}

@keyframes scroll-text {
    0% {
        transform: translateX(100%);
    }
    15% {
        transform: translateX(0); /* Immediately show text */
    }
    90% {
        transform: translateX(-100%);
    }
    100% {
        transform: translateX(-100%); /* Restart */
    }
}

.tooltip-scrolling {
    animation: scroll-text 10s linear infinite;
}

.form-container-wrapper {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
  z-index: 9999; /* Ensures it is above other content */
  visibility: hidden; /* Initially hidden */
}

.form-container-wrapper.active {
  visibility: visible;
}

.form-container {
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  max-width: 500px;
  width: 90%; /* Responsive width */
  box-sizing: border-box;
}
.form-field {
  margin-bottom: 20px;
}

    .form-field input, .form-field select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
      font-size: 16px;
    }

.form-field label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}

.form-field input:focus,
.form-field select:focus {
  border-color: #3f51b5;
}

.btn {
  background-color: #3f51b5;
  color: white;
  border: none;
  padding: 10px 15px;
  border-radius: 4px;
  cursor: pointer;
  width: 100%;
  font-size: 16px;
}

.btn:hover {
  background-color: #303f9f;
}
    #dropdownContainer {
        font-family: Arial, sans-serif;
        pointer-events: auto !important;
    }
    #contactBookmarks {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        -webkit-appearance: menulist !important;
        -moz-appearance: menulist !important;
        appearance: menulist !important;
        pointer-events: auto !important;
    }
    #contactBookmarks option {
        display: block !important;
    }

.overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: none;
    z-index: 1999;
}

.search-container {
    width: 100vw;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 2000;
    background-color: white;
    opacity: 0;
    transition: transform 0.5s ease, opacity 0.5s ease;
}

.search-container.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
}

.search-container.hide {
    transform: translate(-50%, -50%) scale(0);
    opacity: 0;
}
  
.search-input-container {
    display: flex;
    width: 100%;
    position: relative;
    align-items: center;
    max-width: 100%; /* Prevent horizontal scrolling */
}

.custom-button {
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #0D47A1;
    color: white;
    border: none;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    transition: box-shadow 0.3s;
    font-size: 1.5rem;
    width: 60px;
    height: 60px;
}

.custom-search-input {
    flex: 1;
    font-size: 1.5rem;
    padding: 0 50px 0 20px !important;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    height: 60px;
    box-sizing: border-box;
    outline: none; 
}
.custom-search-input::placeholder {
    color: #999; /* Placeholder text color */
}
.custom-search-input:focus {
    border-color: #2196F3 !important;
    box-shadow: 0 0 8px rgba(33, 150, 243, 0.5) !important;
    outline: none !important;
}

.dropdown-button, .clear-button, .engine-select-button {
    position: absolute;
    right: 75px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    cursor: pointer;
    color: #999;
    padding: 5px;
    z-index: 1;
    outline: none;
}
.dropdown-button:focus,
.engine-select-button:focus,
.engine-select-button:active {
    border-color: transparent; /* Ensure no border color */
    box-shadow: 0 0 8px rgba(33, 150, 243, 0.5); /* Optional: Add your custom focus shadow */
    outline: none !important; /* Ensure no default outline is shown */
    color: #2196F3 !important; /* Material Design blue color or any other color you prefer */
}
.engine-select-button:focus {
    color: #2196F3; /* Material Design blue color or any other color you prefer */
}
.dropdown {
    display: none;
    position: absolute;
    z-index: 1000;
    border: 1px solid #ccc;
    background: white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    max-height: 350px;
    overflow-y: auto;
    border-radius: 4px;
    width: calc(100% - 120px); /* Full width minus buttons */
}

.dropdown-item {
    padding: 10px;
    cursor: pointer;
    font-size: 14px;
}

.dropdown-item:hover {
    background-color: #f0f0f0;
}

.engine-dropdown {
    position: absolute;
    top: 100%;
    right: 0;
    background-color: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    display: none; /* Assuming you toggle this with JavaScript */
    z-index: 1000;
    width: 180px; /* Increased size */
    max-height: 400px; /* Set reasonable maximum height for scrolling */
    overflow-y: auto; /* Enable vertical scrolling */
}


.engine-option {
    padding: 10px;
    cursor: pointer;
    font-size: 14px;
}

.engine-option:hover {
    background-color: #f0f0f0;
}

.engine-option.selected {
    background-color: #e0e0e0;
}

@media (max-width: 600px) {
    .custom-button, .custom-search-input, .dropdown, .dropdown-item {
        font-size: 1.2rem;
    }
    .custom-button {
        width: 14vw;
        height: 14vw;
        font-size: 1.2rem;
    }
    .custom-search-input {
        height: 14vw;
        padding: 0 38px 0 10px;
        width: 72vw;
    }
    .dropdown {
        bottom: calc(100% + 5px);
        margin-left: 14vw;
        margin-right: 14vw;
        width: 72vw; /* Full width minus buttons */
    }
    .dropdown-item {
        padding: 8px;
    }
    .dropdown-button, .clear-button, .engine-select-button {
        right: 16vw;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        cursor: pointer;
        color: #999;
        padding: 5px;
        z-index: 1;
    }
}

@media (min-width: 601px) {
    .dropdown {
        top: calc(100% + 5px); /* Positioned below search box */
        margin-left: 60px; 
        margin-right: 60px;
        width: calc(100% - 120px); /* Full width minus left and right buttons */
    }
    .engine-dropdown {
        width: 200px; /* Increased size for desktop */
    }
}


  </style>   

<script type=module>
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
import { getMessaging, getToken, onMessage } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-messaging.js';
import { getInstallations, getId } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-installations.js';
import { getDatabase, ref, set, serverTimestamp, query, orderByChild, equalTo, remove, get } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js';

const firebaseConfig = {
  apiKey: "AIzaSyD96IBVqGKVEdmXIVCYL_7kvlBhJNSD1Ww",
  authDomain: "marko-be9a9.firebaseapp.com",
  databaseURL: "https://marko-be9a9-default-rtdb.firebaseio.com",
  projectId: "marko-be9a9",
  storageBucket: "marko-be9a9.appspot.com",
  messagingSenderId: "7036670175",
  appId: "1:7036670175:web:99992356716578ea13996a"
};
// Initialize Firebase
const app = initializeApp(firebaseConfig);

// Initialize Firebase Realtime Database
const db = getDatabase(app);

// Initialize Firebase Cloud Messaging
const messaging = getMessaging(app);

// Get the installation ID
const installations = getInstallations(app);
getId(installations).then((installationId) => {
  console.log('Installation ID:', installationId);
}).catch((error) => {
  console.error('Error getting installation ID:', error);
});

 // Handle foreground messages
onMessage(messaging, (payload) => {
  console.log('Message received. ', payload);
  if (payload.data.goto) {
    const navUrl = String(payload.data.goto);
    window.open(navUrl, '_blank');
  }
  if (payload.data.url) {
    const navUrl = String(payload.data.url);
    window.open(navUrl, '_blank');
  }
  if (payload.data.uuid) {
  const uuid = payload.data.uuid;
  const url = `https://marko-app.netlify.app?uuid=${uuid}`;
  localforage.getItem('notifications').then(function(notifications) {
                if (!notifications) {
                    console.error('No notifications found');
                    return;
                }
  // Filter out the notification with the specified uuid
  const updatedNotifications = notifications.filter(notification => notification[0] !== uuid);
  // Save the updated array back to localForage
  return localforage.setItem('notifications', updatedNotifications);
  })
  window.location.href = 'https://marko-app.netlify.app';
  window.open(url, '_blank'); // Opens URL in a new tab or window
  }
  //window.location.href = `https://marko-app.netlify.app?uuid=${payload.data.uuid}`;
/*
  const notificationTitle = payload.notification.title;
  const notificationOptions = {
    body: payload.notification.body,
    icon: payload.notification.icon,
    data: {
      url: `https://marko-app.netlify.app?uuid=${payload.data.uuid}`,
      uuid: payload.data.uuid
    }
  };

  const notification = new Notification(notificationTitle, notificationOptions);

  notification.onclick = function(event) {
    event.preventDefault();
    window.open(notificationOptions.data.url, '_blank');
    removeBellAfterNotification(notificationOptions.data.uuid);  
  };
  */
});      
  // Request permission for notifications and get the token
  function requestNotificationPermission() {
    console.log('Requesting notification permission...');
    Notification.requestPermission().then((permission) => {
      if (permission === 'granted') {
        console.log('Notification permission granted.');
        // Get the token using the VAPID key
        getToken(messaging, { vapidKey: 'BNbpZ8MoJQ0OvODtVFtqBmiH81lNdGMSU87ISkIMoRGCVN2gHdxnemVqfW1MlAzO5qQqTi_I_QdKo7qpdyFq3tw' }).then((fcmToken) => {
          if (fcmToken) {
            console.log('FCM Token:', fcmToken);
            // Send the token to your server and save it in localStorage
            localStorage.setItem('fcmt', fcmToken);
            set(ref(db, 'tokens/' + fcmToken), {
              token: fcmToken,
              lastSeen: serverTimestamp()
            });
          } else {
            console.log('No registration token available. Request permission to generate one.');
          }
        }).catch((error) => {
          console.error('An error occurred while retrieving token.', error);
        });
      } else {
        console.log('Notification permission denied.');
      }
    });
  }
  


      // Register the service worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/firebase-messaging-sw.js', {
    scope: '/'
  }).then(function(registration) {
    console.log('Service Worker registered with scope:', registration.scope);

    navigator.serviceWorker.addEventListener('message', (event) => {
      if (event.data && event.data.action === 'open_url') {
        const url = event.data.url;
        // Handle the URL as needed in your application
        console.log('Received URL to open:', url);
        window.location.href = url; // Navigate to the URL
      }
    });
  }).catch(function(error) {
    console.error('Service Worker registration failed:', error);
  });
}



// Request notification permission on page load
// requestNotificationPermission();
  // Expose db and necessary functions for other scripts
  window.db = db;
  window.ref = ref;
  window.set = set;
  window.serverTimestamp = serverTimestamp;
  window.requestNotificationPermission = requestNotificationPermission;

  function getShowTimeByUuid(uuid) {
            return localforage.getItem('notifications').then(function(notifications) {
                if (!notifications) {
                    console.error('No notifications found');
                    return null;
                }

                // Find the pair with the matching uuid
                const notification = notifications.find(notification => notification[0] === uuid);

                if (notification) {
                    return notification[1];
                } else {
                    console.error('Notification not found for uuid:', uuid);
                    return null;
                }
            }).catch(function(err) {
                console.error('Error retrieving notifications', err);
                return null;
            });
        }
  
export async function cancelScheduledNotification(uuid) {
    if (!uuid) {
        alert("Invalid data provided.");
        return;
    }

    const showTime = await getShowTimeByUuid(uuid);
    if (!showTime) {
        alert("No notification found for this Marko.");
        return;
    }

    const formattedShowTime = new Date(showTime).toLocaleString('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
    });

    const confirmDelete = confirm(`Scheduled for ${formattedShowTime}. Are you sure you want to delete the notification for this Marko?`);

    if (!confirmDelete) {
        console.log("User canceled reminder removal.");
        return;
    }

    // Query based on scheduledTime (indexed field)
    const notificationsRef = ref(db, "scheduledNotifications");
    const queryRef = query(notificationsRef, orderByChild("scheduledTime"));

    get(queryRef).then((snapshot) => {
      if (snapshot.exists()) {
        snapshot.forEach((childSnapshot) => {
          const notification = childSnapshot.val();
          if (notification.uuid === uuid) {
            console.log("Removing notification with key:", childSnapshot.key);
            remove(childSnapshot.ref)
              .then(() => {
                alert("Reminder successfully removed.");
                localforage.getItem('notifications').then(function(notifications) {
                if (!notifications) {
                    console.error('No notifications found');
                    return;
                }
            // Filter out the notification with the specified uuid
            const updatedNotifications = notifications.filter(notification => notification[0] !== uuid);
            // Save the updated array back to localForage
            return localforage.setItem('notifications', updatedNotifications);
            })
              })
              .catch((error) => {
                console.error("Error deleting notification:", error);
                alert("An error occurred while removing the reminder.");
              });
          }
        });
      } else {
        alert("There was no active notification for this UUID.");
      }
    }).catch((error) => {
      console.error("Error querying notifications:", error);
      alert("An error occurred while querying the notifications.");
    });
}


          // Function to retrieve the showTime for a given uuid

// Expose the function globally
window.cancelScheduledNotification = cancelScheduledNotification;

</script>
 <script> 

        Notiflix.Notify.init({
            position: 'center-top',
            timeout: '7000',
            clickToClose: 'true',
            zindex: 4003,
            cssAnimationStyle: 'from-top',
            fontFamily: 'Roboto, sans-serif', // Set font family
            });
   Notiflix.Confirm.init({
    className: 'notiflix-prompt-custom',
    position: 'center', // Position in the upper half of the screen in the middle
    width: '360px', // Maximum width
    borderRadius: '8px', // Border radius
    useGoogleFont: true, // Disable Google Fonts to use custom font
    fontFamily: 'Roboto, sans-serif', // Set font family
    cssAnimationStyle: 'zoom', // Animation style
    backOverlay: true,
    plainText: true,
    okButtonBackground: '#0D47A1',
    titleColor: '#000000',
    titleFontSize: '20px',
    messageFontSize: '18px',
    zindex: 4000, 
});
function onWindowFocus() {
    console.log("Window is focused!");
    // Your function code here

      // Retrieve a value using localForage
localforage.getItem('newUnopenedReminder').then(function(value) {
  if (value !== null) {
    console.log('Retrieved value:', value);
    // Use the retrieved value in your application logic
    window.location.href = value;
        loadArrayFromURL();
        return localforage.removeItem('newUnopenedReminder');
  } else {
    console.log('Value not found in localForage.');
    const url = new URL(window.location.href); // Create a URL object

    if (url.searchParams.has('uuid')) {
    // URL includes "?uuid="
    console.log("URL contains now useless 'uuid' parameter, redirecting");
    redirectToHomepage();
  }
  }
}).catch(function(err) {
  console.error('Error retrieving value from localForage:', err);
});
  
localforage.getItem('new-nav-request').then(function(value) {
  if (value !== null) {
    console.log('Retrieved value:', value);
    window.open(value, '_blank');
        return localforage.removeItem('new-nav-request');
  } else {
    console.log('Url Value not found in localForage.');
  }
}).catch(function(err) {
  console.error('Error retrieving value from localForage:', err);
});  
}
   
window.addEventListener('focus', onWindowFocus);

function detectTheme() {
    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const theme = localStorage.getItem("theme");

    // Apply the theme based on user preference or system theme
    if (theme) {
        if (theme === "dark") {
            document.body.classList.add('dark-mode');
            document.body.classList.remove('light-mode');
            console.log("Following user's theme choice: Dark Mode");
        } else {
            document.body.classList.add('light-mode');
            document.body.classList.remove('dark-mode');
            console.log("Following user's theme choice: Light Mode");
        }
    } else {
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            document.body.classList.remove('light-mode');
            console.log("Following system theme: Dark");
        } else {
            document.body.classList.add('light-mode');
            document.body.classList.remove('dark-mode');
            console.log("Following system theme: Light");
        }
    }
}

function toggleTheme() {
    const currentTheme = localStorage.getItem("theme");
    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    if (currentTheme === "dark") {
        localStorage.setItem("theme", "light");
        document.body.classList.add('light-mode');
        document.body.classList.remove('dark-mode');
        console.log("User selected: Light mode");
    } else if (currentTheme === "light") {
        localStorage.setItem("theme", "dark");
        document.body.classList.remove('light-mode');
        document.body.classList.add('dark-mode');
        console.log("User selected: Dark mode");
    } else {
    	if (isDarkMode) {
    	    localStorage.setItem("theme", "light");
    	    document.body.classList.add('light-mode');
            document.body.classList.remove('dark-mode');
            console.log("User selected: Light mode");
        } else {
            localStorage.setItem("theme", "dark");
            document.body.classList.add('dark-mode');
            document.body.classList.remove('light-mode');
            console.log("User selected: Dark mode");
        }        
    }
}
    
  // Detect theme on page load and apply it, unless user has chosen differently
  document.addEventListener('DOMContentLoaded', detectTheme);

  // Listen for changes in the system theme and follow them
 window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', toggleTheme);

let isSignedIn = false;
let accessToken = localStorage.getItem('accessToken') || '';

if (accessToken) {
    isSignedIn = true;
}

function toggleSignInOut() {
    if (isSignedIn) {
        handleSignOut();
    } else {
        handleSignIn();
    }
}

function handleSignIn() {
    updateButtonState('loading');
    const loadingButton = document.getElementById('signInOutButton');
    const loadingIcon = document.getElementById('signInOutIcon');
    loadingButton.disabled = true;
    loadingIcon.classList.add('spinning');
    setTimeout(() => {
      window.location.href = LOGIN_PAGE_URL;
    }, 1200);
}

function handleSignOut() {
    updateButtonState('loading');
    const loadingButton = document.getElementById('signInOutButton');
    const loadingIcon = document.getElementById('signInOutIcon');
    loadingButton.disabled = true;
    loadingIcon.classList.add('spinning');
    setTimeout(() => {
      window.location.href = LOGOUT_PAGE_URL;
    }, 1200);
}

function updateButtonState(state) {
    const button = document.getElementById('signInOutButton');
    const icon = document.getElementById('signInOutIcon');
    const text = document.getElementById('signInOutText');
    
    switch(state) {
        case 'signedIn':
            icon.textContent = 'logout';
            text.textContent = 'Sign Out';
            button.disabled = false;
            break;
        case 'signedOut':
            icon.textContent = 'login';
            text.textContent = 'Sign In';
            button.disabled = false;
            break;
        case 'loading':
            icon.textContent = 'hourglass_empty';
            text.textContent = 'Loading...';
            button.disabled = true;
            break;
    }
}

function checkInitialState() {
    updateButtonState('loading');
    const accessToken = localStorage.getItem('accessToken');
    if (accessToken) {
        isSignedIn = true;
        setTimeout(() => updateButtonState('signedIn'), 1000);
    } else {
        setTimeout(() => updateButtonState('signedOut'), 1000);
    }
}


// Call this when the page loads
document.addEventListener('DOMContentLoaded', checkInitialState);
         // use this to show second line of menu buttons when needed. it wont work as is, it references removed elements 
         function menuMore() {
            const modal = document.getElementById('myModal');
            const buttonContainer = document.getElementById('menu-container');
            if (modal.style.display === 'block') {
                buttonContainer.classList.remove('hidden');
                buttonContainer.classList.add('visible');
            } else {
                buttonContainer.classList.remove('visible');
                buttonContainer.classList.add('hidden');
            }
        }

  // Ensure this function runs when the DOM content is fully loaded
  document.addEventListener('DOMContentLoaded', () => {
    menuMore();

    // Add an event listener to monitor changes to the visibility of new-link-form
  const observer = new MutationObserver(() => {
    menuMore();
    });

  observer.observe(document.getElementById('myModal'), { attributes: true, attributeFilter: ['style'] });
  });

  function passCheck() {
            const storedPassword = localStorage.getItem('password');
            console.log("pass: " + storedPassword);
            const loggedIn = sessionStorage.getItem('loggedIn');
            if (!storedPassword || loggedIn === "true") {
                sessionStorage.setItem('loggedIn', "true");
                renderLinks();
                return;
            }

            const enteredPassword = prompt('Enter password:');
            if (enteredPassword === null) {
                alert('You have to enter pass to continue');
                return;
            }

            if (enteredPassword === storedPassword) {
               sessionStorage.setItem('loggedIn', "true");
               renderLinks();
               return;    
            } else {
                // Silently fail in case of wrong password. Password is set locally only for discretion
                return;
            }
        }


let bookmarks = [];    
    const linkIcon = 'https://fonts.gstatic.com/s/i/materialicons/link/v15/24px.svg';
    const mailIcon = 'https://fonts.gstatic.com/s/i/materialicons/mail/v15/24px.svg';
    const phoneIcon = 'https://fonts.gstatic.com/s/i/materialicons/call/v15/24px.svg';
    const fileIcon = 'https://fonts.gstatic.com/s/i/materialicons/insert_drive_file/v15/24px.svg';
    const noteIcon = 'https://fonts.gstatic.com/s/i/materialicons/note/v15/24px.svg';


    // this is what is mainly done: each time page is loaded it checks local storage and -after it confirms if user is logged it- it renders the bbokmarks
    document.addEventListener("DOMContentLoaded", () => {
    
        const savedMarkos = JSON.parse(localStorage.getItem('bookmarks')) || [];
        console.log('Saved Markos:', savedMarkos);  // Debug log

        bookmarks = savedMarkos;  // Initialize links array
        passCheck();  // Render the bookmarks
        detectTheme();
        checkConnection();
    });

   document.addEventListener('DOMContentLoaded', () => {
    function checkConnection() {
        const offlineBanner = document.getElementById('offline-banner');

        // Initial check for online status
        if (!navigator.onLine) {
            offlineBanner.classList.add('show');
            console.log('no internet connection');
        } else {
            offlineBanner.classList.remove('show');
            console.log('internet connection is active');
        }

        // Listen for online event to remove the banner
        window.addEventListener('online', () => {
            offlineBanner.classList.remove('show');
            console.log('internet connection restored');
        });

        // Listen for offline event to show the banner
        window.addEventListener('offline', () => {
            offlineBanner.classList.add('show');
            console.log('internet connection lost');
        });
    }

    // Call the function to set up event listeners and perform the initial check
    checkConnection();
});

async function syncAndShowPublicMarkos() {
    if (!navigator.onLine) {
        alert("Connect to the Internet to proceed");
        return;
    }

    const syncFromButton = document.getElementById('syncFromDrive');
    syncFromButton.disabled = true;

    if (!confirm("Are you sure you want to show your public Markos from Google Drive?")) {
        return;
    }

    try {
        const userLoggedOut = localStorage.getItem('explicitLogout');
        if (userLoggedOut === 'true') {
          if (confirm('You have to login to use this feature. Login now?')) {
                localStorage.removeItem('explicitLogout');
                window.location.href = LOGIN_PAGE_URL;
          } else {
            return;
          }
        }
        accessToken = localStorage.getItem('accessToken');
        console.log('Using access token:', accessToken);

        // Fetch file list with cache-control headers
        const fileListResponse = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${PUBLIC_FILE}' and trashed=false`, {
            method: 'GET',
            headers: new Headers({
                'Authorization': 'Bearer ' + accessToken,
                'Cache-Control': 'no-cache, no-store, must-revalidate'
            })
        });

        if (!fileListResponse.ok) {
            throw new Error(`File list fetch failed. HTTP status: ${fileListResponse.status}`);
        }

        const fileListData = await fileListResponse.json();
        console.log('File list data:', fileListData);

        if (fileListData.files && fileListData.files.length > 0) {
            const fileId = fileListData.files[0].id;

            // Fetch file content with cache-control headers
            const fileResponse = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
                method: 'GET',
                headers: new Headers({
                    'Authorization': 'Bearer ' + accessToken,
                    'Cache-Control': 'no-cache, no-store, must-revalidate'
                })
            });

            if (!fileResponse.ok) {
                throw new Error(`File fetch failed. HTTP status: ${fileResponse.status}`);
            }

            const fileData = await fileResponse.json();
            localStorage.setItem('public-bookmarks', JSON.stringify(fileData));
        } else {
            throw new Error('No public bookmarks file found in Google Drive');
        }

        // After fetching and storing, proceed to show public Markos
        const linkContainer = document.querySelector('.bookmarks-container');
        linkContainer.innerHTML = ''; // Clear the container

        const savedPublicLinks = JSON.parse(localStorage.getItem('public-bookmarks')) || [];
        console.log('Saved Links:', savedPublicLinks); // Debug log

        links = savedPublicLinks; // Initialize links array
        passCheck(); // Render the bookmarks
        detectTheme();
        checkConnection();

        alert("Your Markos are now in sync. Enjoy!");
    } catch (error) {
        console.error('Full error object:', error);
        let errorMessage = 'Error retrieving file: ' + error.message;
        alert(errorMessage);
    }
}

// TODO add a default for the cases the commonMarko added has already been deleted by its creator      
async function syncAndShowCommonMarko(fileId, title = 'Shared with me') {
    const nameWithoutSpaces = title.replace(/\s+/g, '');
    if (!navigator.onLine) {
        alert("Connect to the Internet to proceed");
        return;
    }
    try {
        const userLoggedOut = localStorage.getItem('explicitLogout');
        if (userLoggedOut === 'true') {
          if (confirm('You have to login to use this feature. Login now?')) {
                localStorage.removeItem('explicitLogout');
                window.location.href = LOGIN_PAGE_URL;
          } else {
            return;
          }
        }
        // refresh token
        //await initializeGoogleIdentity();
        accessToken = localStorage.getItem('accessToken');
        // get file with given id from Google Drive
        const fileResponse = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media&key=${API_KEY}`, {
            method: 'GET',
            headers: new Headers({
                'Cache-Control': 'no-cache, no-store, must-revalidate'
            })
        });
        if (!fileResponse.ok) {
            throw new Error(`File fetch failed. HTTP status: ${fileResponse.status} ${fileResponse.statusText}`);
        }
      
        const fileContent = await fileResponse.json();
        console.log('File content:', JSON.stringify(fileContent));

        // Since the fileContent is the remote array from the Google Driva file containing the Markos
        const bookmarks = fileContent;
        
        if (bookmarks) {
            // update the stored common-bookmarks   
            localStorage.setItem(fileId, JSON.stringify(bookmarks));
            console.log('Sync complete');

            // show the bookmarks of this common Marko
            const linkContainer = document.querySelector('.bookmarks-container');
            linkContainer.innerHTML = '';
            console.log('Common Markos:', bookmarks);
            links = bookmarks;
            passCheck();
            detectTheme();
            checkConnection();
           // check that this common Marko doesnt exist already
          // Retrieve or initialize commonMarkos array from localStorage
          //allCommonMarkos = JSON.parse(localStorage.getItem('commonMarkos')) || [];

          if (!allCommonMarkos.includes(fileId)) {
             // Add fileId to allCommonMarkos array
             allCommonMarkos.push(fileId);
             // Store updated allCommonMarkos array back into localStorage
            localStorage.setItem('commonMarkos', JSON.stringify(allCommonMarkos));
            // add a Marko for this common Marko
            createMarko('contact', `${fileId}`, `${title}`, '', '');
          } else { 
           console.log(`Marko ${title} has already been added.`);
        }   
            updateUI(fileId, `${title}`);
            alert(`Synced. Showing Markos from ${title}. Enjoy!`);
            sessionStorage.setItem('now-showing', fileId);
            console.log('now showing Markos from:' + fileId);
        } else {
            console.error('Bookmarks not found in fileContent');
            alert('Error: no Markos found in the file content.');
        }
    } catch (error) {
        console.error('Error:', error.message);
        //alert('An error occurred: ' + error.message);
    } finally {
        console.log('syncAndShowCommonMarko completed');
    }
}

// show the title of common Marko, update clicking action on main bookmark to open the notification page with topic name the fileId        
function updateUI(fileId, name) {
    const bookmarkTitle = document.querySelector('.bookmark-title');
    if (bookmarkTitle) {
        bookmarkTitle.textContent = name;
        bookmarkTitle.style.color = '#0D47A1'; 
        bookmarkTitle.style.fontSize = '24px'; 
        //bookmarkTitle.dataset.commonName = name;
    }
    const nextIcon = document.getElementById('next-icon');
    nextIcon.innerHTML = 'arrow_back_ios';
    nextIcon.classList.add('material-icons');
    nextIcon.style.fontSize = '36px'; // Set nextIcon size to 36px
    nextIcon.onclick = function (event) {
        location.reload();
        event.stopPropagation();
    };
    const mainBookmark = document.getElementById('main-bookmark');
    mainBookmark.onclick = function() {
        openLink(`https://ntfy.sh/${fileId}`);
    };
  myCommons = JSON.parse(localStorage.getItem('myCommons')) || [];
  const fileIdIsMine = myCommons.includes(fileId);
  if (!fileIdIsMine) {
    // Hide all delete-icon elements if fileId not in myCommons = is not a file I am owner of
    const deleteIcons = document.querySelectorAll('.delete-icon');
    deleteIcons.forEach(icon => {
        icon.style.display = 'none';
    });
    // TODO: add a "viewingNow" sessionStorage item to deactivate swipe while on common or public Marko collections
        // Hide non-relevant context menu items
    const contextMenuItems = [
        'context-delete',
        'context-moveup',
        'context-movedown',
        'context-divider',
        'context-rename'
    ];
    contextMenuItems.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.style.display = 'none';
        }
    });
}
}

function moveMarkoTo() {
    const bookmarkContainer = document.querySelector('.bookmarks-container');
    const bookmarks = bookmarkContainer.querySelectorAll('.bookmark-wrapper[onclick^="openMarko(syncAndShowCommonMarko,"]');

    // Hide all bookmarks
    bookmarkContainer.querySelectorAll('.bookmark').forEach(el => el.style.display = 'none');

    // Show and modify only the matching bookmarks
    bookmarks.forEach((bookmark) => {
        const bookmarkParent = bookmark.closest('.bookmark');
        bookmarkParent.style.display = 'block';

        const onclickValue = bookmark.getAttribute('onclick');
        const match = onclickValue.match(/openMarko\(syncAndShowCommonMarko,\s*'([^']+)',\s*'([^']+)'\)/);

        if (match) {
            const [, firstArg, secondArg] = match;
            const index = parseInt(bookmarkParent.getAttribute('data-index'));

            bookmark.onclick = function(event) {
                event.preventDefault();
                if (confirm(`Do you want to copy chosen Marko to ${secondArg}?`)) {
                    const allBookmarks = JSON.parse(localStorage.getItem('bookmarks') || '[]');
                    const targetBookmark = allBookmarks[index];

                    if (targetBookmark) {
                        const targetArray = JSON.parse(localStorage.getItem(firstArg) || '[]');
                        targetArray.push(targetBookmark);
                        localStorage.setItem(firstArg, JSON.stringify(targetArray));
                        updateMarko(firstArg);
                    }
                }
            };
        }
    });
}
    
function clearFrame() {
    document.getElementById("lightbox-iframe").srcdoc = "";
}  
    
function showShareNote(title, text) {
 
var iframe = document.getElementById('lightbox-iframe');

iframe.srcdoc = `
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Share Note</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: lightgrey;
            text-align: center;
            font-family: 'monospace', sans-serif;
            margin: 0;
            overflow: hidden;
            position: relative;
        }
        .content {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .share-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 48px;
            color: black;
        }
        .share-button:hover {
            color: #0d47a1;
            transform: scale(1.2); 
        }
    </style>
</head>
<body>
    <div class="content">
        <div style="font-weight: bold; font-size: 24px;">${title}</div>
        <br>
        <div style="font-weight: normal; font-size: 18px;">${text}</div>
    </div>
    <button class="share-button" onclick="shareText('${text}', '${title}')">
        <span class="material-icons">share</span>
    </button>
    <script>
        function stripHtmlTags(htmlString) {
            const tempDiv = document.createElement('div');
            // Replace <br> with newlines, escaping the backslash properly
            htmlString = htmlString.replace(/<br\\s*\\/?>/gi, '\\n');
            tempDiv.innerHTML = htmlString;
            return tempDiv.textContent || tempDiv.innerText || '';
        }

        function shareText(htmlText, title) {
            window.focus();
            
            // Strip HTML tags
            const text = stripHtmlTags(htmlText);
            
            // Share link if Web Share API is available
            if (navigator.share) {
                navigator.share({
                    title: title,
                    text: text
                })
                .then(() => {
                    console.log('Successfully shared');
                })
                .catch(err => {
                    console.error('Error sharing', err);
                    // Fallback to clipboard if sharing fails
                    navigator.clipboard.writeText(\`\${title}: \${text}\`)
                    .then(() => {
                        console.log('Successfully copied to clipboard');
                        alert('Copied to clipboard');
                    })
                    .catch(err => {
                        console.error('Error copying to clipboard:', err);              
                    });
                });
            } else {
                // Fallback to clipboard
                navigator.clipboard.writeText(\`\${title}: \${text}\`)
                .then(() => {
                    console.log('Successfully copied to clipboard');
                    alert('Copied to clipboard');
                })
                .catch(err => {
                    console.error('Error copying to clipboard:', err);
                });
            } 
        }
    <\/script>
</body>
</html>
`;


// Display the lightbox
document.getElementById('lightbox').style.display = 'flex';
document.getElementById('add-banner').style.display = 'none';
// Set a timeout to hide the lightbox after 20 seconds     
setTimeout(function() {
    document.getElementById('lightbox').style.display = 'none';
    document.getElementById('add-banner').style.display = 'block';
}, 20000);
}

    function generateUUID() {
    // Generate 16 random bytes
    const bytes = new Uint8Array(16);
    window.crypto.getRandomValues(bytes);

    // Set version to 4 and variant to 8, 9, A, or B
    bytes[6] = (bytes[6] & 0x0f) | 0x40; // Version 4
    bytes[8] = (bytes[8] & 0x3f) | 0x80; // Variant 10xx

    // Convert bytes to UUID string format
    return [...bytes].map((byte, index) => {
        const hex = byte.toString(16).padStart(2, '0');
        return (index === 4 || index === 6 || index === 8 || index === 10) ? `-${hex}` : hex;
    }).join('');
}

 // change address bar text when a friend's links are shown   
function changeURL(url) {
            const current = window.location.href;
            const find = '/friends';
            const found = current.match(find);
            if (url.length === 11) {
                history.pushState({}, '', window.location.href + "?v=" + url);
                checkUrlAndLoadVideo();
            }
            else if (window.location.origin === 'null' || window.location.protocol === 'file:') {
                console.log("running locally, no changeUrl");
            }
            else if (found) {
            // Get the base URL including the file name
            const cleanUrl = window.location.href.split('?')[0];
            history.replaceState(null, '', cleanUrl);
            const friendName = url.substring(0, url.lastIndexOf('+'));
            history.pushState({}, '', cleanUrl + "/" + friendName);
            }
            else {
                console.log("no parsable url provided");
            }
        }

// Function to check if a Marko exists with extended checks
function markoExists(type, url, title, array = "bookmarks") {
    const data = JSON.parse(localStorage.getItem(array)) || [];
    for (let i = 0; i < data.length; i++) {
        const storedType = data[i][0];
        const storedUrl = data[i][1];
        const storedTitle = data[i][2];

        // Check if type and URL are the same, or URL and title are the same
        if ((storedType === type && storedUrl === url) ||
            (storedUrl === url && storedTitle === title)) {
            // If a similar Marko is found, show the confirmation dialog
            const confirmation = confirm("You already have a similar Marko, are you sure you want to continue?");
            return confirmation;
        }
    }
    return true; // Return true if no similar Marko found
}

// Function to retrieve and process localStorage values
        function retrieveAndProcessStorage() {
            const storedLongLink = localStorage.getItem('temp-long-link');
            let storedAlias = localStorage.getItem('temp-alias');
            const isOneTime = localStorage.getItem('temp-onetime') === 'true';

            if (storedAlias) {
                // Handle alias length and spaces
                if (storedAlias.length > 11) {
                    alert(`Alias was too long and has been shortened to: ${storedAlias.substring(0, 11)}`);
                    storedAlias = storedAlias.substring(0, 11);
                }
                storedAlias = storedAlias.replace(/\s+/g, '_'); // Replace spaces with underscores
            }

            return { storedLongLink, storedAlias, isOneTime };
        }

        // Function to send a request to create a shortlink
        function sendShortlinkCreationRequest(url, alias, maxClicks) {
            const data = new URLSearchParams();
            data.append('url', url);
            if (alias && alias.trim() !== '') data.append('alias', alias); // Only append alias if not empty
            if (maxClicks) data.append('max-clicks', '1');

            return fetch('https://spoo.me/', {
                method: 'POST',
                headers: {
                    'Content-type': 'application/x-www-form-urlencoded',
                    'Accept': 'application/json'
                },
                body: data.toString()
            })
            .then(response => response.json());
        }

        // Function to process the shortlink creation response
        function processShortlinkCreationResponse(url, alias, maxClicks) {
            sendShortlinkCreationRequest(url, alias, maxClicks)
                .then(responseData => {
                    console.log('Parsed API response:', responseData);

                    if (responseData.short_url) {
                        //alert('Shortlink created successfully!');

                        // Store the shortlink in localStorage
                        localStorage.setItem('short-link', responseData.short_url);

                        // Handle clipboard copy and sharing
                        handleClipboardAndSharing(responseData.short_url);
                    } else {
                        throw new Error('Invalid response data');
                    }
                })
                .catch(error => {
                    console.error('Error:', error.message);
                    if (alias) {
                        // Retry shortlink creation without alias
                        sendShortlinkCreationRequest(url, '', maxClicks)
                            .then(responseData => {
                                console.log('Parsed API response:', responseData);

                                if (responseData.short_url) {
                                    //alert('Custom alias unavailable. Shortlink created without alias.');

                                    // Store the shortlink in localStorage
                                    localStorage.setItem('short-link', responseData.short_url);

                                    // Handle clipboard copy and sharing
                                    handleClipboardAndSharing(responseData.short_url);
                                } else {
                                    throw new Error('Invalid response data');
                                }
                            })
                            .catch(error => {
                                console.error('Error:', error.message);
                                //alert('An error occurred while creating shortlink');
                            });
                    } else {
                        console.error('Error:', error.message);
                        //alert('An error occurred while creating shortlink');
                    }
                });
        }

        // Function to copy shortlink to clipboard and share it
        function handleClipboardAndSharing(shortlink) {

            // Share link if Web Share API is available
            if (navigator.share) {
                window.focus();
                navigator.share({
                    title: 'Shortlink',
                    text: 'Check out this shortlink:',
                    url: shortlink
                })
                .then(() => {
                    //alert('Shortlink shared successfully!');
                })
                .catch(err => {
                    console.error('Error sharing shortlink:', err);
                    //alert('Failed to share shortlink.');
                });
            } else {
            window.focus();
            navigator.clipboard.writeText(shortlink)
                .then(() => {
                    console.log('Shortlink copied to clipboard!');
                    // Clear localStorage
                    localStorage.removeItem('temp-long-link');
                    localStorage.removeItem('temp-alias');
                    localStorage.removeItem('temp-onetime');
                    localStorage.removeItem('temp-marko-link');
                })
                .catch(err => {
                    console.error('Error copying to clipboard:', err);
                    //alert('Failed to copy shortlink to clipboard.');
                });            
            }
        }

        // Function to validate alias characters
        function validateAliasCharacters(alias) {
            const validPattern = /^[a-zA-Z0-9 _-]+$/; // Allows letters, numbers, hyphens, underscores, and spaces
            return validPattern.test(alias);
        }

      
        // Function to set temp-marko-link and initiate shortlink creation
        function initializeShortlinkWithTempMarkoLink(link) {
            if (link && link.trim() !== '') {
                // Automatically prepend https:// if the link does not start with http:// or https://
                if (!link.startsWith('http://') && !link.startsWith('https://')) {
                    link = 'https://' + link;
                }
                
                localStorage.setItem('temp-marko-link', link);

                // Handle shortlink creation using stored values
                const { storedAlias, isOneTime } = retrieveAndProcessStorage();
                processShortlinkCreationResponse(link, storedAlias, isOneTime);
            }
        }

   /*
   TODO add this to the time we are parsing url params
        // Automatically initialize shortlink creation if temp-marko-link is set in localStorage
        const savedLink = localStorage.getItem('temp-marko-link');
        if (savedLink) {
            initializeShortlinkWithTempMarkoLink(savedLink);
        }

*/

function scrollDown() {
window.scroll({
    top: document.body.scrollHeight,
    left: 0,
    behavior: 'smooth'
});
}
      
      
  function createMarko(type, link, title, icon, color, array = "bookmarks") {
    // Check if a similar Marko exists
    if (!markoExists(type, link, title, array)) {
        return; // Exit the function if the user cancels
    }
    // Function to get a random color
    function getRandomColor() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }

    // Function to infer link type if not specified
    function inferLinkType(link) {
        if (link.startsWith('mailto:')) {
            return 'email';
        } else if (link.startsWith('tel:')) {
            return 'phone';
        } else if (link.startsWith('https://')) {
            return 'website';
        } else if (link.startsWith('https://wa.me/')) {
            return 'whatsapp';
        } else if (link.startsWith('viber://chat?number=')) {
            return 'viber';
        } else if (link.startsWith('common-marko')) {
            return 'contact';
        } else {
            return 'note'; // Default to note if type cannot be inferred
        }
    }

    // Default icon based on type
    function getDefaultIcon(type, url) {
        const icons = {
            'website': `https://www.google.com/s2/favicons?domain=${url}&sz=32`,
            'email': 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/email/default/48px.svg',
            'phone': 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/perm_phone_msg/default/48px.svg',
            'note': 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/short_text/default/48px.svg',
            'whatsapp': 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/message/default/48px.svg',
            'viber': 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/message/default/48px.svg',
            'contact': 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/person/default/48px.svg'
        };

        // Check if the URL is valid for website type
        if (type === 'website' && url && !url.includes('://')) {
            return 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/link/default/48px.svg'; // Invalid URL or domain
        }
        return icons[type] || 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/link/default/48px.svg';
    }

    // Default title based on type
    function getDefaultTitle(type) {
        const titles = {
            'website': 'Website',
            'email': 'Email',
            'phone': 'Phone',
            'note': 'Note',
            'whatsapp': 'WhatsApp',
            'viber': 'Viber',
            'contact': 'Contact'
        };
        return titles[type] || 'Link';
    }

    // Infer the link type if not provided
    if (!type) {
        type = inferLinkType(link);
    }

    // Use default title if not provided
    if (!title) {
        title = getDefaultTitle(type);
    }

    // Use default icon if not provided or for websites
    if (!icon) {
        icon = getDefaultIcon(type, link);
    }

    // Use random color if not provided
    if (!color) {
        color = getRandomColor();
    }

    // Construct the bookmark array
    const linkData = [type, link, title, icon, color];
    // Save the bookmark to local storage
    let bookmarks = JSON.parse(localStorage.getItem('bookmarks')) || [];
    bookmarks.push(linkData);
    localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
    const alertStatus = sessionStorage.getItem('alertStatus');

            if (alertStatus !== 'off') {
                // Show the alert
                alert(`Success! You just added a Marko for ${title}`);
                window.location.href = window.location.origin + window.location.pathname;
            } else {
                // Set alertStatus back to 'on' for future alerts and skip showing the alert
                sessionStorage.setItem('alertStatus', 'on');
            }
    return linkData;
}

function handleSharedLink(url, title, text) {
    console.log(`Link: ${url}, Title: ${title}, Extras: ${text}`);  
    createMarko('', url, title, '', '');
}
            
  function loadArrayFromURL() {
        function getColor() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
    const params = new URLSearchParams(window.location.search);
    
    const compressed = params.get('data');
    const isGlobal = params.get('globalMarko');
    const isCommon = params.get('commonMarko');
    const commonMarkoId = params.get('common-marko');
    const commonName = params.get('common-name');
    const purelink = params.get('friendlink');
    const sharedTitle = params.get('title');
    const reminder = params.get('uuid');
    const sharedUrl = params.get('url');
    const sharedText = params.get('text');
    
    const type = params.get('type');
    const theLink = params.get('link');
    const title = params.get('title');
    const icon = params.get('icon');
    const color = params.get('color');
    const isNewMarko = params.get('createMarko');
    const noConfirmation = params.get('noConfirm');
    // Decode the action parameter
    const link = decodeURIComponent(theLink || '').replace(/\n/g, '<br>');
    const scrollRequest = params.get('scroll');
    const randomColor = getColor();
    const navUrl = params.get('nav'); 
    const func = params.get('then');  
    const functionsMap = {
        getFromGoogleDrive,
        saveToGoogleDrive
    };

    if (func && functionsMap[func]) {
        functionsMap[func](); // Execute the corresponding function
        window.history.replaceState({}, document.title, window.location.origin);
    }
    
    if (navUrl) {
        window.open(navUrl, '_blank');
    }
            
            // Check if the scroll parameter is present
            if (scrollRequest === 'down') {
                console.log('Scroll to bottom requested');
                scrollDown();
            }
    // Check if createMarko=true is present in the URL parameters
    if (isNewMarko === 'true' && type && link && title && icon && color) {
      if (noConfirmation === 'true') {
            console.log("User is adding a Marko.");
            createMarko(type, link, title, icon, color);
            return;
      }
        if (confirm(`Do you want to add a Marko for ${title}?`)) {
            console.log("User is adding a Marko.");
            createMarko(type, link, title, icon, color);
        } else {
            console.log("User does not want to add a Marko.");
        }
    } else {
        console.log("Not all required parameters for Marko creation are present or createMarko is not true.");
    }
    
// Case 4: Handling multiple shared parameters
const seemsLikeShared = (sharedTitle ? 1 : 0) + (sharedUrl ? 1 : 0) + (sharedText ? 1 : 0);
if (seemsLikeShared >= 2) {
    console.log('Shared Title:', sharedTitle);
    console.log('Shared Text:', sharedText);
    console.log('Shared URL:', sharedUrl);
    
    let sharedLink = null;
    let remaining1 = null;
    let remaining2 = null;

    if (sharedText && sharedText.startsWith("https://")) {
        sharedLink = decodeURIComponent(sharedText);
        remaining1 = sharedTitle;
        remaining2 = sharedUrl;
    } else if (sharedTitle && sharedTitle.startsWith("https://")) {
        sharedLink = decodeURIComponent(sharedTitle);
        remaining1 = sharedText;
        remaining2 = sharedUrl;
    } else if (sharedUrl && sharedUrl.startsWith("https://")) {
        sharedLink = decodeURIComponent(sharedUrl);
        remaining1 = sharedText;
        remaining2 = sharedTitle;
    }  

    if (sharedLink) {
        let title, text;
        
        // Determine title and text based on conditions
        if (remaining1 && remaining2) {
            if (!remaining1.startsWith("https://") && !remaining2.startsWith("https://")) {
                // If neither remaining1 nor remaining2 starts with https://, use the shorter as title
                title = remaining1.length <= remaining2.length ? remaining1 : remaining2;
                text = "*";
            } else {
                title = remaining1.startsWith("https://") ? remaining1 : remaining2;
                text = remaining1.startsWith("https://") ? remaining2 : remaining1;
            }
        } else if (remaining1) {
            title = remaining1;
            text = "*";
        } else if (remaining2) {
            title = remaining2;
            text = "*";
        } else {
            title = "Shared with Marko";
            text = "*";
        }

        handleSharedLink(sharedLink, title, text);
        window.history.replaceState({}, document.title, "/");
        return;
    } else {
        console.log("No valid link found in shared parameters.");
    }
}

// Case 1: Plain text sharing as a potential link or note
if (sharedText) {
    // Split sharedText by newline characters to handle multiline scenarios
    const lines = sharedText.split(/\r?\n/);

    // Initialize variables to hold potential title and URL
    let title = sharedTitle || 'Quick Note'; // Default title
    let url = null;

    // Iterate through each line to identify URL and adjust title
    lines.forEach(line => {
        if (!url && line.startsWith("http")) {
            url = line.trim(); // Assume first line with http as URL
            title = lines.length > 1 ? lines.find(l => l !== url) : url; // Use remaining line as title if more than one line
        }
    });

    if (url) {
        const baseUrl = getBaseUrl(sharedText);
        const baseLink = baseUrl || "Link shared with Marko"; // Use base URL as title or default if not available
        handleSharedLink(url, baseLink, "*");
        window.history.replaceState({}, document.title, "/");
        return;
    } else {
                // Case 3: Plain text sharing (including selected text from mobile)
        let noteTitle, noteContent;

        if (sharedText) {
            const lines = sharedText.trim().split('\n');
            if (lines.length > 1) {
                // Use the first line as title if there are multiple lines
                noteTitle = lines[0].trim();
                noteContent = lines.slice(1).join('\n').trim();
            } else {
                // If it's a single line, use a default title
                noteTitle = title || 'Quick Note';
                noteContent = sharedText.trim();
            }
        } else if (title) {
            // If only title is provided, treat it as the content
            noteTitle = 'Quick Note';
            noteContent = title.trim();
        } else {
            // Fallback case if somehow we don't have any text
            noteTitle = 'Empty Note';
            noteContent = '';
        }

        console.log('Creating note:', { title: noteTitle, content: noteContent });
         handleSharedLink(noteContent, noteTitle, '');
        window.history.replaceState({}, document.title, "/");
        return;
    }
}

// Case 2: Simple link sharing
if (sharedText && sharedText.startsWith("http")) {
    const baseUrl = getBaseUrl(sharedText);
    const title = baseUrl || "Shared with Marko"; // Use base URL as title or default if not available
    handleSharedLink(sharedText, title, "*");
    window.history.replaceState({}, document.title, "/");
    return;
}

console.log("No valid sharing data found.");

    if (reminder) {
        openReminder(reminder);
        removeBellAfterNotification(reminder);
        window.close();
        return;
    }

    if (purelink) {
        if (confirm("Do you want to add " + params.get('friendname') + " as friend?")) {
            linkData = ['friend', params.get('friendlink'), params.get('friendname'), 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/person/default/48px.svg', randomColor];
            let markos = JSON.parse(localStorage.getItem('bookmarks')) || [];

            markos.push(linkData);
            localStorage.setItem('bookmarks', JSON.stringify(markos));
            console.log('Markos saved:', markos);

            passCheck();
        }
    }

if (commonMarkoId && isCommon) {
    //allCommonMarkos = JSON.parse(localStorage.getItem('commonMarkos')) || [];
    
    // Check if commonMarko already exists in localStorage
    if (allCommonMarkos.includes(commonMarkoId)) {
        console.log(`A Marko for ${commonName} has already been added.`);
        alert(`You already have ${commonName} as contact!`);
        // TODO: add logic to show with updateUI etc
    } else {
        // Prompt user to confirm adding as a friend
        if (confirm(`Do you want to add ${params.get('common-name')} as a friend?`)) {
            allCommonMarkos.push(commonMarkoId);
            // Store updated allCommonMarkos array back into localStorage
            localStorage.setItem('commonMarkos', JSON.stringify(allCommonMarkos));
            // Call function to sync and show commonMarko
            syncAndShowCommonMarko(commonMarkoId, commonName);
        } else {
            console.log('User rejected friend request.');
        }
    }
}  
    
    
    if (compressed && isGlobal) {
        try {
            if (confirm("Do you want to add " + `${sharedTitle}` + " as a friend?")) {
                const decompressed = LZString.decompressFromEncodedURIComponent(compressed);
                console.log(decompressed);
                const array = JSON.parse(decompressed);
                const friendString = JSON.stringify(array);
                
                // Generate a UUID
                const uuid = generateUUID();
                
                // Create the local storage key with the UUID
                const storageKey = "friends/" + `${sharedTitle}` + "+" + uuid;
                localStorage.setItem(storageKey, friendString);
                console.log("Friend " + `${sharedTitle}` + " saved:", friendString);
                
                const friendUrl = `${storageKey}`;
                const linkData = ["friend", friendUrl, `${sharedTitle}`, "https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/person/default/48px.svg", getRandomColor()];
                let bookmarks = JSON.parse(localStorage.getItem('bookmarks')) || [];

                bookmarks.push(linkData);
                localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
                console.log('Markos saved:', bookmarks);

                passCheck();
            }
        } catch (error) {
            console.log('Failed to load array from URL.');
        }
    }
}
      
// Function to extract base URL from a full URL
function getBaseUrl(url) {
    const parsedUrl = new URL(url);
    let baseUrl = `${parsedUrl.hostname}`;
    // Optionally remove 'www.' if present
    if (baseUrl.startsWith("www.")) {
        baseUrl = baseUrl.slice(4);
    }
    return baseUrl;
}

function countAchievements() {
    // Select all elements with an ID that starts with 'bookmark-'
    const elements = document.querySelectorAll('[id^="bookmark-"]');
    
    // Count the number of such elements
    const count = elements.length;
    
    // Check if the count is more than 5
    if (count > 5) {
        // Select the element with ID 'main-title'
        const mainTitleElement = document.getElementById('main-title');
        
        // Check if the mainTitleElement exists to avoid errors
        if (mainTitleElement) {
            // Add a star emoji (â­) next to the main title
            mainTitleElement.textContent += ' â­';
        }
    }

    // Return the count of elements
    return count;
}

// URL of your login page
        const LOGIN_PAGE_URL = 'https://marko-app.netlify.app/login';
        const LOGOUT_PAGE_URL = 'https://marko-app.netlify.app/logout';

        // Function to check if the user is logged in
        async function checkLoginStatus() {
            const userLoggedOut = localStorage.getItem('explicitLogout');
            if (userLoggedOut === 'true') {
              return;
            }
          
            accessToken = localStorage.getItem('accessToken');

            if (!accessToken) {
                // No access token found, redirect to login
                window.location.href = LOGIN_PAGE_URL;
                return;
            }

            try {
                // Validate the access token by calling a Google API endpoint
                const response = await fetch('https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=' + accessToken);

                if (response.ok) {
                    const data = await response.json();
                    console.log('Access Token is valid:', data);
                    // Proceed to load the main page content
                } else {
                    console.warn('Invalid Access Token:', response.status);
                    // Token is invalid, redirect to login
                    window.location.href = LOGIN_PAGE_URL;
                }
            } catch (error) {
                console.error('Error validating Access Token:', error);
                // Redirect to login on any error
                window.location.href = LOGIN_PAGE_URL;
            }
        }



    window.onload = function() {
    checkLoginStatus();
    Notiflix.Notify.warning('Site under active development. Breaking changes ahead..');
    loadArrayFromURL();  
    loadDonationParams();
    toggleBellIcons();
    console.log('You have ' + countAchievements() + ' Markos');  // Logs the count of elements with IDs starting with 'bookmark-'
  
};   
   // TODO document.getElementById('download-button').addEventListener('click', downloadPage);
    
    // delete a bookmark from local storage and remove it from now shown (the later by calling removeMarko function) TODO: maybe merge to 1 with clearLink()
    function deleteLink(index, array = 'bookmarks') {
            // nowPlaying is the bunch of Markos currently shown
            const nowShowing = sessionStorage.getItem('now-showing') || 'bookmarks';
            const currentMarkosArray = JSON.parse(sessionStorage.getItem(nowShowing)) || [];
            if (confirm('Are you sure you want to delete this Marko?')) {
              removeMarko(index);
              currentMarkosArray.splice(index, 1);
              localStorage.setItem(nowShowing, JSON.stringify(currentMarkosArray));
            }
            if (nowShowing !== 'bookmarks') {
              syncAndShowCommonMarko(nowShowing);
            }
    }
    
        function clearLink(index, array = 'bookmarks') {
              removeMarko(index);
              bookmarks.splice(index, 1);
              localStorage.setItem(array, JSON.stringify(bookmarks));
              saveLinks();
    }
    
            function moveMarkoUp(index) {
                if (index > 0) {
                    [bookmarks[index - 1], bookmarks[index]] = [bookmarks[index], bookmarks[index - 1]];
                    localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
                    saveLinks();
                    renderLinks();
                } else {
                    alert("This Marko is already at the top.");
                }
            }    
    
            function moveMarkoDown(index) {
                if (index < bookmarks.length - 1) {
                    const [link] = bookmarks.splice(index, 1);
                    bookmarks.push(link);
                    localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
                    saveLinks();
                    renderLinks();

                } else {
                    alert("This Marko is already at the bottom.");
                }
            }

function toggleBellIcons() {
    const bookmarks = document.querySelectorAll('.bookmark');

    bookmarks.forEach((bookmark) => {
        const index = bookmark.getAttribute('data-index');
        const wrapper = bookmark.querySelector('.bookmark-wrapper');
        const bellIcon = document.getElementById(`bell-${index}`);
        const deleteIcon = document.getElementById(`delete-${index}`); // Get the delete icon element

        if (!wrapper) {
            console.error(`No .bookmark-wrapper found inside #bookmark-${index}`);
            return;
        }

        const uuid = wrapper.getAttribute('data-uuid');

        if (!bellIcon) {
            // console.log(`No bell icon found with id bell-${index}`);
            return;
        }

        // Check if uuid is blank, "null", or "undefined"
        if (!uuid || uuid === "" || uuid === "null" || uuid === "undefined") {
            bellIcon.style.display = 'none'; // Hide the bell icon
        } else {
            bellIcon.style.display = 'inline-block'; // Show the bell icon
            // Hide the delete icon
            if (deleteIcon) {
                deleteIcon.style.display = 'none';
            }
        }

        // If bell icon is visible, ensure delete icon is hidden
        if (bellIcon.style.display === 'inline-block' && deleteIcon) {
            deleteIcon.style.display = 'none';
        }
    });
}



    

function addReminderToMarko(index) {
    // Check if index is within bounds of the links array
    if (index >= 0 && index < bookmarks.length) {
        // Generate a UUID
        const uuid = generateUUID();

        // Get the bookmark array at the specified index
        let bookmark = bookmarks[index];

        // If bookmark is undefined (should not happen with proper index validation), create a new bookmark array
        if (!bookmark) {
            bookmark = [];
        }

        // Add the uuid as the last element in the bookmark array
        if (bookmark.length >= 6) {
            // Replace the existing UUID (if any) with the new one
            bookmark[5] = uuid;
        } else {
            // Add the UUID as the 6th item
            bookmark.push(uuid);
        }

        // Ensure there are no more than 6 items in the array
        if (bookmark.length > 6) {
            bookmark.splice(0, bookmark.length - 6); // Remove excess items
        }

        console.log('Updated bookmark array:', bookmark);

        // Update the bookmark in the links array
        bookmarks[index] = bookmark;

        // Save the updated links array to localStorage
        localStorage.setItem('bookmarks', JSON.stringify(bookmarks));

        // Call saveLinks and renderLinks to update the UI
        saveLinks();
        renderLinks();

        toggleBellIcons();

        // Call constructLinkFromBookmark to get shareTitle, shareBody, and shareIcon
        const { shareBody, shareIcon } = constructLinkFromBookmark(index, false); 
        
        // Store uuid, shareBody, and shareIcon in sessionStorage
        const reminderDetails = {
            uuid,
            shareBody,
            shareIcon
        };
        // temporarily save data to session storage for immediate retrieval
        sessionStorage.setItem('reminderDetails', JSON.stringify(reminderDetails));
        
        // show the form after storing data in sessionStorage
        toggleFormVisibility(true);
    } else {
        console.error(`Index ${index} is out of bounds for links array.`);
        return;
    }
}


document.addEventListener('DOMContentLoaded', function() {
    // Event listener for form submission
    document.getElementById('submitButton').addEventListener('click', function(event) {
        event.preventDefault(); // Prevent default form submission

        // Retrieve uuid, shareBody, and shareIcon from sessionStorage
        const reminderDetails = JSON.parse(sessionStorage.getItem('reminderDetails'));
        if (!reminderDetails) {
            alert("Something went wrong..");
            console.error('Reminder details not found in sessionStorage.');
            return;
        }

        const { uuid, shareBody, shareIcon } = reminderDetails;
        console.log('Retrieved reminder details:', reminderDetails);

        // Construct notification details
        const { textInput, delay } = constructNotification();
        console.log('Constructed notification details:', { textInput, delay });
        scheduleNotification(textInput, shareBody, delay, shareIcon, uuid);
        console.log('Notification scheduled with:', { textInput, shareBody, delay, shareIcon, uuid });
    });
});

function renameMarko(index) {
    if (index >= 0 && index < bookmarks.length) {
        // Check if there's a bookmark at the specified index
        let bookmark = bookmarks[index];

        const currentTitle = bookmark[2];

    // Prompt the user for a new name, pre-filling with oldName
    let userInput = prompt("Enter new name for this Marko:", currentTitle);
    
    // If the user cancels the prompt, return immediately
    if (userInput === null) {
        return;
    }
    
    // Trim the user's input and truncate to 30 characters max
    const newTitle = userInput.trim().substring(0, 30);
    
    console.log(`Old Title: ${currentTitle}`);
    console.log(`New Title: ${newTitle}`);
        // Prompt user for confirmation
        
            bookmark[2] = newTitle;

            // Update the links array
            bookmarks[index] = bookmark;

            // Save the updated links array to localStorage
            localStorage.setItem('bookmarks', JSON.stringify(bookmarks));

            // Call saveLinks and renderLinks to update the UI
            saveLinks();
            renderLinks();
    } else {
        console.error(`Index ${index} is out of bounds for links array.`);
        return;
    }
}
        
function removeReminder(index) {
    if (index >= 0 && index < bookmarks.length) {
        // Check if there's a bookmark at the specified index
        let bookmark = bookmarks[index];

        if (!bookmark || bookmark.length < 6) {
            console.error(`No valid bookmark found at index ${index}`);
            return;
        }

        const currentUUID = bookmark[5]; // Get the current UUID


            // Remove the UUID (invalidate it)
            bookmark[5] = "";

            // Update the links array
            bookmarks[index] = bookmark;

            // Save the updated links array to localStorage
            localStorage.setItem('bookmarks', JSON.stringify(bookmarks));

            // Call saveLinks and renderLinks to update the UI
            saveLinks();
            renderLinks();

            toggleBellIcons();

            // after removing the bell, cancel the actual notification
            cancelScheduledNotification(currentUUID);
 

    } else {
        console.error(`Index ${index} is out of bounds for links array.`);
        return;
    }
}
    
function removeBellAfterNotification(uuid) {
    // Find the bookmark index that matches the provided UUID
    const index = bookmarks.findIndex(bookmark => bookmark && bookmark.length >= 6 && bookmark[5] === uuid);

    if (index === -1) {
        console.error(`Bookmark with UUID ${uuid} not found in links array.`);
        return;
    }

    // Get the current UUID
    const currentUUID = bookmarks[index][5];

    
        // Remove the UUID (invalidate it)
        bookmarks[index][5] = "";

        // Save the updated links array to localStorage
        localStorage.setItem('bookmarks', JSON.stringify(bookmarks));

        // Update the UI
        saveLinks();
        renderLinks();
        
        toggleBellIcons(); // Update bell icons based on new state

        console.log(`Bell removed for bookmark with UUID ${uuid}`);

}
    
// Function to get current datetime as a string in the required format
function getCurrentDatetimeString() {
  const now = new Date();
  const year = now.getFullYear();
  const month = ('0' + (now.getMonth() + 1)).slice(-2);
  const day = ('0' + now.getDate()).slice(-2);
  const hours = ('0' + now.getHours()).slice(-2);
  const minutes = ('0' + now.getMinutes()).slice(-2);
  return `${year}-${month}-${day}T${hours}:${minutes}`;
}

// Function to toggle form visibility
function toggleFormVisibility(showForm) {
  const formContainer = document.getElementById('notificationForm');
  const datetimeInput = document.getElementById('datetimeInput'); // Correctly get datetime input element

  if (showForm) {
    formContainer.classList.add('active'); // Show the form
    datetimeInput.value = getCurrentDatetimeString(); // Set current datetime string to datetime input
  } else {
    formContainer.classList.remove('active'); // Hide the form
    // Clear form inputs
    datetimeInput.value = '';
    document.getElementById('timeDelaySelect').value = '0';
    document.getElementById('textInput').value = '';
  }
}

  function generateUniqueToken() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
    
let deviceToken;

function initializeDeviceToken() {
    deviceToken = localStorage.getItem('deviceToken');
    if (!deviceToken) {
        deviceToken = generateUniqueToken();
        localStorage.setItem('deviceToken', deviceToken);
    }
    
    // Send this token to Firebase Realtime Database
    const dbRef = window.ref(window.db, 'devices/' + deviceToken);
    return window.set(dbRef, {
      lastSeen: window.serverTimestamp()
    });
  }

    
function calculateDelay() {
    const datetimeInput = document.getElementById('datetimeInput').value;
    const timeDelay = parseInt(document.getElementById('timeDelaySelect').value);

    // Check if datetimeInput is empty
    if (!datetimeInput) {
        alert('Please enter a date and time.');
        return null;
    }

    // Parse the input datetime
    const datetime = new Date(datetimeInput);

    // Validate the parsed datetime
    if (isNaN(datetime.getTime())) {
        alert('Invalid date and time.');
        return null;
    }

    // Calculate the delay from now
    const now = new Date();
    const selectedTime = datetime.getTime();
    const delayFromNow = selectedTime - now.getTime() + timeDelay;

    return delayFromNow;
}


// Function to handle form submission and construct notification
function constructNotification() {
    
  const textNotInput = document.getElementById('textInput').value;
  const newDelay = calculateDelay(); // Assuming you have a function to calculate delay

  // Log the values to show they are accessible globally
  console.log('Text Input:', textNotInput);
  console.log('New Delay:', newDelay);

  // Optionally, close the form after submission
  toggleFormVisibility(false);

  // Return an object with the values
  return {
    textInput: textNotInput,
    delay: newDelay
  };
}
/*
function requestNotificationPermission() {
    if (!('Notification' in window)) {
        console.log('Notifications not supported in this browser.');
        return Promise.reject('Notifications not supported');
    }

    return Notification.requestPermission().then(permission => {
        if (permission === 'granted') {
            console.log('Notification permission granted.');
            return Promise.resolve();
        } else {
            console.log('Notification permission denied.');
            return Promise.reject('Notification permission denied');
        }
    });
}
*/

function sendEmailNotification(title, body, uuid) {
    authorize()
        .then(() => {
            console.log('User email:', loggedInUserEmail);
            const email = loggedInUserEmail;
            const body = "This is my Marko reminder, click.." + `https://marko-app.netlify.app?uuid=${uuid}`;
            const topic = uuid;
          
            fetch(`https://ntfy.sh/${encodeURIComponent(topic)}`, {
                method: 'POST',
                body: body,
                headers: {
                    'Email': email
                }
            })
            .then(response => {
                if (response.ok) {
                    alert('Email notification sent successfully!');
                } else {
                    alert('Failed to send email notification. Please try again.');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                //alert('An error occurred. Please try again.');
            });
        })
        .catch(error => {
            console.error('Error in authorization:', error);
        });
}      

// detect if run on mobile or on desktop based on screen width. TODO use this function to make it more mobile friendly
function isMobileDevice() {
  return 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0 ||
         window.matchMedia('(max-width: 768px)').matches;
}

if (isMobileDevice()) {
  console.log("Marko seems to be running on mobile");
} else {
  console.log("Marko seems to be running on desktop");
}    
      
function scheduleNotification(title, body, delay, icon, uuid) {
    const notificationTime = new Date(Date.now() + delay).toISOString();
    let myToken;

    // Retrieve the device Firebase token
    try {
        myToken = localStorage.getItem('fcmt');
        console.log(myToken);
        if (!myToken) {
            throw new Error("No device token found");
        }
    } catch (error) {
        alert("Could not identify device, aborting..");
        return;
    }

    // Determine the notification icon
    const notIcon = icon.startsWith("https://fonts.gstatic.com/") ? icon : "https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/open_in_new/default/48px.svg";

    // Check if Notifications are supported in the browser
    if (!('Notification' in window)) {
        console.log('Notifications not supported in this browser.');
        return;
    }

    // Request notification permission
    Notification.requestPermission().then(permission => {
        if (permission !== 'granted') {
            alert("You have to give permission for notifications to be shown.");
            console.log('Notification permission denied.');
            return Promise.reject('Notification permission denied');
        }

        const notificationData = {
            title: title || 'Click to open..',
            body: body || 'your Marko reminder',
            uuid: uuid,
            icon: notIcon,
            deviceToken: myToken,
            scheduledTime: notificationTime
        };

        // Add email to notificationData if not on mobile
            const userEmail = localStorage.getItem('userEmail');
            if (confirm("Do you also want an email reminder in your Gmail inbox?")) {
              notificationData.email = userEmail;
               console.log("Scheduling an email notification to..: " + userEmail)
            }

        // Generate a unique key
        const uniqueKey = Date.now().toString(36) + Math.random().toString(36).substr(2);
        // Create a reference with the unique key
        const newNotificationRef = window.ref(window.db, `scheduledNotifications/${uniqueKey}`);
        // Send notification data to Firebase Realtime Database
        return window.set(newNotificationRef, notificationData);  
    }).then(() => {
        const showTime = new Date(notificationTime).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: '2-digit', hour: '2-digit', minute: '2-digit' });
        alert(`Notification scheduled to be shown at: ${showTime}`);
        // store in localForage to show notification time to user when bell clicked >>> let them cancel it
        localforage.getItem('notifications').then(function(notifications) {
                if (notifications === null) {
                    notifications = []; // Initialize as an empty array if it doesn't exist
                }
          // Push the new pair onto the array
        notifications.push([uuid, showTime]);
        return localforage.setItem('notifications', notifications);
        })
    }).catch(error => {
        if (error !== 'Notification permission denied') {
            alert("Something went wrong..");
            console.error('Error scheduling notification:', error);
        }
    });
}
      /*
function scheduleNotification(title, body, delay, icon, uuid) {
    // sendEmailNotification(title, body, uuid); // using it as part of the cloud function to schedule one instead
    const notificationTime = new Date(Date.now() + delay).toISOString();
    let token;
    // Retrieve the device Firebase token
    try {
        myToken = localStorage.getItem('fcmt');
        console.log(myToken);
        if (!myToken) {
            throw new Error("No device token found");
        }
    } catch (error) {
        alert("Could not identify device, aborting..");
        return;
    }

    // Determine the notification icon
    const notIcon = icon.startsWith("https://fonts.gstatic.com/") ? icon : "https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/open_in_new/default/48px.svg";

    // Check if Notifications are supported in the browser
    if (!('Notification' in window)) {
        console.log('Notifications not supported in this browser.');
        return;
    }

    // Request notification permission
    Notification.requestPermission().then(permission => {
        if (permission !== 'granted') {
            alert("You have to give permission for notifications to be shown.");
            console.log('Notification permission denied.');
            return Promise.reject('Notification permission denied');
        }

            const notificationData = {
                title: title || 'Click to open..',
                body: body || 'your Marko reminder',
                uuid: uuid,
                icon: notIcon,
                deviceToken: myToken,
                scheduledTime: notificationTime
            };

    // Generate a unique key
    const uniqueKey = Date.now().toString(36) + Math.random().toString(36).substr(2);

    // Create a reference with the unique key
    const newNotificationRef = window.ref(window.db, `scheduledNotifications/${uniqueKey}`);

    // Send notification data to Firebase Realtime Database
    return window.set(newNotificationRef, notificationData);  
    }).then(() => {
        alert(`Notification scheduled to be shown at: ${new Date(notificationTime).toLocaleString('en-GB', { day: '2-digit', month: '2-digit', year: '2-digit', hour: '2-digit', minute: '2-digit' })}`);
    }).catch(error => {
        if (error !== 'Notification permission denied') {
            alert("Something went wrong..");
            console.error('Error scheduling notification:', error);
        }
    });
}
*/
document.addEventListener('DOMContentLoaded', (event) => { 
    initializeDeviceToken()
        .then(() => window.requestNotificationPermission())
        .catch(error => console.error('Error initializing:', error));
});

// Function to check if an element is partially visible at the top, considering the main-bookmark
        function isPartiallyVisibleAtTop(el, offset) {
            const rect = el.getBoundingClientRect();
            return rect.top < offset && rect.bottom > offset;
        }

        // Function to scroll the element into view
        function adjustScroll() {
            const loggedIn = sessionStorage.getItem('loggedIn');
            if (loggedIn !== 'true') {
                return;
            }
            const mainBookmark = document.getElementById('main-bookmark');
            const mainBookmarkHeight = mainBookmark.getBoundingClientRect().height;
            const paddingOffset = 10; // Adjust this value to match your bookmark padding
            const bookmarks = document.querySelectorAll('.bookmark');
            bookmarks.forEach(bookmark => {
                const rect = bookmark.getBoundingClientRect();
                if (isPartiallyVisibleAtTop(bookmark, mainBookmarkHeight + paddingOffset)) {
                    const scrollOffset = rect.top - (mainBookmarkHeight + paddingOffset);
                    window.scrollBy({
                        top: scrollOffset,
                        behavior: 'smooth'
                    });
                }
            });
        }

        // Debounce function to limit the rate at which the adjustScroll function is called
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Add scroll event listener with debounce
        window.addEventListener('scroll', debounce(adjustScroll, 100));
      
// Function to find and click bookmark with matching UUID
function openReminder(uuid) {
    console.log("checking..");
    // Iterate through bookmarks
    // Select all bookmark elements
    const bookmarkElements = document.querySelectorAll('.bookmark');

    // Iterate through each bookmark element
    bookmarkElements.forEach(bookmarkElement => {
        // Find the bookmark-wrapper element inside each bookmark
        const bookmarkWrapper = bookmarkElement.querySelector('.bookmark-wrapper');
        
        // Retrieve data-uuid attribute from bookmark-wrapper
        const dataUUID = bookmarkWrapper.getAttribute('data-uuid');
        
        // Compare data-uuid with the UUID you are looking for
        if (dataUUID === uuid) {
            // Found the bookmark with matching UUID
            console.log(`Found bookmark with data-uuid: ${uuid}. Clicking it...`);
            
            // Simulate click on the bookmark or perform your action
            bookmarkWrapper.click(); // Example: Click on the bookmark-wrapper
            // Replace with your specific logic to interact with the bookmark
        }
    });
}
function addAd() {
                const linkContainer = document.querySelector('.bookmarks-container');

                const iconUrl = 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/kid_star/default/48px.svg';
                const bookmarkElement = document.createElement('div');
                bookmarkElement.className = 'bookmark';

                bookmarkElement.id = `bookmark-genericAd`;
                bookmarkElement.innerHTML = `
     <div class="bookmark-wrapper" data-type='ad' onmouseover="showTooltip('Promoted content')"
     onmouseout="hideTooltip()" onclick="openMarko(openLink, 'http://tiny.cc/gsnfzz')" style="cursor: pointer;">
        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: orange;">
                <img src="${iconUrl}" alt="Promotion" class="bookmark-icon" style="width: 42px; height: 42px;">
            </div>
            <span class="bookmark-title">This is an ad</span>
    </div>        
</div> 
    <span id="bell-99999" class="material-icons bell-icon" style="display: none;" onclick="removeReminder('99999'); event.stopPropagation();">notifications_active</span>
    </div>
`;
                    linkContainer.appendChild(bookmarkElement);
}

//localStorage.clear();
// main function to show the bookmarks that are stored as arrays in local storage as visual elements    
function renderLinks() {
            let title = document.title;
            let pageUrl = window.location.href;
            const linkContainer = document.querySelector('.bookmarks-container');
            linkContainer.innerHTML = ''; // Clear the container
            // Add no-select class to prevent text selection
            document.body.classList.add('no-select');
            const defaultIconUrl = 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/open_in_new/default/48px.svg';  // Replace with a better default icon URL
const bookmarkElement = document.createElement('div');
bookmarkElement.className = 'bookmark';
bookmarkElement.id = 'main-bookmark';
bookmarkElement.innerHTML = `
    <div class="bookmark-wrapper" id="home-icon" data-type='website' onmouseover="showTooltip('Welcome!')"
     onmouseout="hideTooltip()" style="cursor: pointer;">
        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: #0d47a1;">
                <img src="https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/home/default/48px.svg"
                alt="Home" class="bookmark-icon" style="width: 42px; height: 42px;">
            </div>
            <span id="main-title" class="bookmark-title">${title}</span>
        </div>
        </div>
      <span id="share-me" class="material-icons delete-icon" 
          style="color: #ff5e00; cursor: pointer; font-size: 24px;"
          onclick="sharePage(event); event.stopPropagation();">share</span>    
      </div>
`;

// Apply sticky styles
bookmarkElement.style.position = '-webkit-sticky'; /* For Safari */
bookmarkElement.style.position = 'sticky';
bookmarkElement.style.top = '0';
bookmarkElement.style.zIndex = '1000';
linkContainer.appendChild(bookmarkElement);
//addAd();
                bookmarks.forEach((link, index) => {
                if (link[0] === "youtube") {
                //const iconUrl = link[3] || defaultIconUrl; 

                const bookmarkElement = document.createElement('div');
                bookmarkElement.className = 'bookmark';
                bookmarkElement.dataset.index = index; // Store the index as a data attribute
                bookmarkElement.id = `bookmark-${index}`;
                bookmarkElement.innerHTML = `
    <div class="bookmark-wrapper" data-uuid='${link[5]}' data-type='${link[0]}' onmouseover="showTooltip('${link[1]}')"
     onmouseout="hideTooltip()" onclick="openMarko(loadVideo, '${link[1]}')" style="cursor: pointer;">
        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: ${link[4]};">
                <img src="${link[3]}" alt="${link[2]}" class="bookmark-icon" style="width: 42px; height: 42px;">
            </div>
            <span class="bookmark-title">${link[2]}</span>
    </div>        
</div> 
    <span id="bell-${index}" class="material-icons bell-icon" style="display: none;" onclick="removeReminder(${index}); event.stopPropagation();">notifications_active</span>
        <span id="delete-${index}" class="material-icons delete-icon" onclick="deleteLink(${index}); event.stopPropagation();">delete</span>
    </div>
`;
                    linkContainer.appendChild(bookmarkElement);
                hideAdd();   
                    
                }           
                else if (link[0] === "window") {
                const bookmarkElement = document.createElement('div');
                bookmarkElement.className = 'bookmark';
                bookmarkElement.dataset.index = index; // Store the index as a data attribute

                bookmarkElement.id = `bookmark-${index}`;
                bookmarkElement.innerHTML = `
    <div class="bookmark-wrapper" data-uuid='${link[5]}' data-type='${link[0]}' onmouseover="showTooltip('${link[1]}')"
     onmouseout="hideTooltip()" onclick="openMarko(showWindow, '${link[1]}')" style="cursor: pointer;">
        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: ${link[4]};">
                <img src="${link[3]}" alt="${link[2]}" class="bookmark-icon" style="width: 42px; height: 42px;">
            </div>
            <span class="bookmark-title">${link[2]}</span>
    </div>        
</div> 
    <span id="bell-${index}" class="material-icons bell-icon" style="display: none;" onclick="removeReminder(${index}); event.stopPropagation();">notifications_active</span>
        <span id="delete-${index}" class="material-icons delete-icon" onclick="deleteLink(${index}); event.stopPropagation();">delete</span>
    </div>
`;
                    linkContainer.appendChild(bookmarkElement);
                hideAdd();   
                    
                }    else if (link[0] === "pdf") {
                const iconUrl = 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/picture_as_pdf/default/48px.svg';
                const proxied = "https://corsproxy.io/?" + link[1];
                const bookmarkElement = document.createElement('div');
                bookmarkElement.className = 'bookmark';
                bookmarkElement.dataset.index = index; // Store the index as a data attribute

                bookmarkElement.id = `bookmark-${index}`;
                bookmarkElement.innerHTML = `
    <div class="bookmark-wrapper" data-uuid='${link[5]}' data-type='${link[0]}' onmouseover="showTooltip('${link[1]}')"
     onmouseout="hideTooltip()" onclick="openMarko(showPDFLightbox, '${proxied}', '${link[2]}')" style="cursor: pointer;">
        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: ${link[4]};">
                <img src="${iconUrl}" alt="${link[2]}" class="bookmark-icon" style="width: 42px; height: 42px;">
            </div>
            <span class="bookmark-title">${link[2]}</span>
    </div>        
</div> 
    <span id="bell-${index}" class="material-icons bell-icon" style="display: none;" onclick="removeReminder(${index}); event.stopPropagation();">notifications_active</span>
        <span id="delete-${index}" class="material-icons delete-icon" onclick="deleteLink(${index}); event.stopPropagation();">delete</span>
    </div>
`;
                    linkContainer.appendChild(bookmarkElement);
                hideAdd();   
                    
                } 
                else if (link[0] === "download") {
                // const iconUrl = 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/download/default/48px.svg';
                // const proxied = "https://corsproxy.io/?" + link[1];
                const bookmarkElement = document.createElement('div');
                bookmarkElement.className = 'bookmark';
                bookmarkElement.dataset.index = index; // Store the index as a data attribute

                bookmarkElement.id = `bookmark-${index}`;
                bookmarkElement.innerHTML = `
    <div class="bookmark-wrapper" data-uuid='${link[5]}' data-type='${link[0]}' onmouseover="showTooltip('${link[1]}')"
     onmouseout="hideTooltip()" onclick="openMarko(downloadFile, '${link[1]}', '${link[2]}')" style="cursor: pointer;">
        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: ${link[4]};">
                <img src="${link[3]}" alt="${link[2]}" class="bookmark-icon" style="width: 42px; height: 42px;">
            </div>
            <span class="bookmark-title">${link[2]}</span>
    </div>        
</div> 
    <span id="bell-${index}" class="material-icons bell-icon" style="display: none;" onclick="removeReminder(${index}); event.stopPropagation();">notifications_active</span>
        <span id="delete-${index}" class="material-icons delete-icon" onclick="deleteLink(${index}); event.stopPropagation();">delete</span>
    </div>
`;
                    linkContainer.appendChild(bookmarkElement);
                hideAdd();      
                }   else if (link[0] === "contact") {
                // const iconUrl = 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/download/default/48px.svg';
                // const proxied = "https://corsproxy.io/?" + link[1];
                const bookmarkElement = document.createElement('div');
                bookmarkElement.className = 'bookmark';
                bookmarkElement.dataset.index = index; // Store the index as a data attribute
                // TODO: deleting should remove the google drive file, if initiated by owner
                bookmarkElement.id = `bookmark-${index}`;
                bookmarkElement.innerHTML = `
    <div class="bookmark-wrapper" data-uuid='${link[5]}' data-type='${link[0]}' onmouseover="showTooltip('This is a contact')"
     onmouseout="hideTooltip()" onclick="openMarko(syncAndShowCommonMarko, '${link[1]}', '${link[2]}')" style="cursor: pointer;">
        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: ${link[4]};">
                <img src="${link[3]}" alt="${link[2]}" class="bookmark-icon" style="width: 42px; height: 42px;">
            </div>
            <span class="bookmark-title">${link[2]}</span>
        </div>
        <span id="delete-${index}" class="material-icons delete-icon" onclick="deleteLink(${index}); event.stopPropagation();">delete</span>
    </div>
`;
                    linkContainer.appendChild(bookmarkElement);
                hideAdd();      
                }     
                else if (link[0] === "post") {
                const iconUrl = 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsoutlined/wysiwyg/default/48px.svg';
                const bookmarkElement = document.createElement('div');
                bookmarkElement.className = 'bookmark';
                bookmarkElement.dataset.index = index; // Store the index as a data attribute

                bookmarkElement.id = `bookmark-${index}`;
                bookmarkElement.innerHTML = `
     <div class="bookmark-wrapper" data-uuid='${link[5]}' data-type='${link[0]}' onmouseover="showTooltip('open to view post')"
     onmouseout="hideTooltip()" onclick='openMarko(showPost, ${JSON.stringify(link[1])})' style="cursor: pointer;">
        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: ${link[4]};">
                <img src="${iconUrl}" alt="${link[2]}" class="bookmark-icon" style="width: 42px; height: 42px;">
            </div>
            <span class="bookmark-title">${link[2]}</span>
    </div>        
</div> 
    <span id="bell-${index}" class="material-icons bell-icon" style="display: none;" onclick="removeReminder(${index}); event.stopPropagation();">notifications_active</span>
        <span id="delete-${index}" class="material-icons delete-icon" onclick="deleteLink(${index}); event.stopPropagation();">delete</span>
    </div>
`;
                    linkContainer.appendChild(bookmarkElement);
                hideAdd();   
                    
                }  
                else if (link[0] === "note") {
    
                const iconUrl = link[3] || defaultIconUrl; 
                const note = decodeURIComponent(link[1]).replace(/\n/g, '<br>');

                const bookmarkElement = document.createElement('div');
                bookmarkElement.className = 'bookmark';
                bookmarkElement.dataset.index = index; // Store the index as a data attribute

                bookmarkElement.id = `bookmark-${index}`;
                
                bookmarkElement.innerHTML = `
    <div class="bookmark-wrapper" data-uuid='${link[5]}' data-type='${link[0]}' onmouseover="showTooltip('${link[2]}')"
     onmouseout="hideTooltip()" onclick="openMarko(showShareNote, '${link[2]}', '${note}')" style="cursor: pointer;">
        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: ${link[4]};">
                <img src="${iconUrl}" alt="${link[2]}" class="bookmark-icon" style="width: 42px; height: 42px;">
            </div>
            <span class="bookmark-title">${link[2]}</span>
    </div>        
</div> 
    <span id="bell-${index}" class="material-icons bell-icon" style="display: none;" onclick="removeReminder(${index}); event.stopPropagation();">notifications_active</span>
        <span id="delete-${index}" class="material-icons delete-icon" onclick="deleteLink(${index}); event.stopPropagation();">delete</span>
    </div>
`;
                    linkContainer.appendChild(bookmarkElement);
                hideAdd();   
                }
                else {
    
                const iconUrl = link[3] || defaultIconUrl; 
    
                const bookmarkElement = document.createElement('div');
                bookmarkElement.className = 'bookmark';
                bookmarkElement.dataset.index = index; // Store the index as a data attribute

                bookmarkElement.id = `bookmark-${index}`;
                
                bookmarkElement.innerHTML = `
    <div class="bookmark-wrapper" data-uuid='${link[5]}' data-type='${link[0]}' onmouseover="showTooltip('${link[1]}')"
     onmouseout="hideTooltip()" onclick="openMarko(openLink, '${link[1]}')">

        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: ${link[4]};">
                <img src="${iconUrl}" alt="${link[2]}" class="bookmark-icon" style="width: 42px; height: 42px;">
            </div>
<span class="bookmark-title">${link[2]}</span>
    </div>        
</div> 
    <span id="bell-${index}" class="material-icons bell-icon" style="display: none;" onclick="removeReminder(${index}); event.stopPropagation();">notifications_active</span>
        <span id="delete-${index}" class="material-icons delete-icon" onclick="deleteLink(${index}); event.stopPropagation();">delete</span>
    </div>
`;
                    linkContainer.appendChild(bookmarkElement);
                hideAdd();   
                            
                }

            });
            // TODO : decide if we always want to scroll down (to see most recently added Markos)
            // scrollDown();
        }
// detect if run on mobile or on desktop based on screen width. TODO use this function to make it more mobile friendly
    
function showTooltip(link) {
    currentLink = link;
    const isGoodForStatus = () => {
        return 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0 ||
               window.matchMedia('(max-width: 768px)').matches;
    };

    if (!isGoodForStatus ()) {
        const tooltip = document.getElementById('tooltip');
        const tooltipContent = document.getElementById('tooltip-content');

        if (tooltip && tooltipContent) {
            tooltipContent.textContent = link;
            tooltip.style.display = 'block';

            const tooltipWidth = tooltip.offsetWidth;
            const textWidth = tooltipContent.scrollWidth;

            // If the text overflows the tooltip, apply the scrolling animation
            if (textWidth > tooltipWidth) {
                tooltipContent.style.animation = 'scroll-text 10s linear infinite';
            } else {
                tooltipContent.style.animation = 'none';
            }
        }
    }
}


    function hideTooltip() {
        const tooltip = document.getElementById('tooltip');
        if (tooltip) {
            tooltip.style.display = 'none';
        }
    }
        

        function renderFriend(friend) {
            const linkContainer = document.querySelector('.bookmarks-container');
            linkContainer.innerHTML = ''; // Clear the container

            const defaultIconUrl = 'https://example.com/default-icon.png';  // Replace with an actual default icon URL
            const savedFriendLinks = JSON.parse(localStorage.getItem(`${friend}`)) || [];
            console.log('Saved Friend Links:', savedFriendLinks);  // Debug log
            bookmarks = savedFriendLinks;
            bookmarks.forEach((link, index) => {
                const iconUrl = link[3] || defaultIconUrl;  // Use default icon if iconurl is undefined

                const bookmarkElement = document.createElement('div');
                bookmarkElement.className = 'bookmark';
                bookmarkElement.dataset.index = index; // Store the index as a data attribute

                bookmarkElement.id = `bookmark-${index}`;
                
                bookmarkElement.innerHTML = `
    <div class="bookmark-wrapper" data-type='${link[0]}' onclick="openMarko(openLink, '${link[1]}')" style="cursor: pointer;">
        <div class="icon-wrapper">
            <div class="icon-container" style="--ring-color: ${link[4]};">
                <img src="${iconUrl}" alt="${link[2]}" class="bookmark-icon">
            </div>
            <span class="bookmark-title">${link[2]}</span>
        </div>
        <span id="delete-${index}" class="material-icons delete-icon" onclick="deleteLink(${index}); event.stopPropagation();">delete</span>
    </div>
`;
                linkContainer.appendChild(bookmarkElement);
            });
        }
    
        function showPost(htmlContent) {
            document.getElementById('add-banner').style.display = 'none';
            var iframe = document.getElementById('lightbox-iframe');
iframe.srcdoc = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My post</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Roboto', sans-serif;
            background-color: lightcyan;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            overflow-x: hidden;
        }
        hr {
        	border: 1px solid #ccc; /* Light grey border */
        	margin: 20px 0; /* Vertical spacing */
        	width: 100%; /* Full width */
    	}
        h1, h2, h3, p, ol, ul, table, form, img, iframe, canvas, details, progress, textarea, label, select {
            max-width: 100%;
            margin: 10px 0;
            padding: 0 10px;
            box-sizing: border-box;
        }

        h1, h2 {
            text-align: center;
        }

        /* Responsive images */
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 10px auto;
        }

        /* Alert styles */
        .alert {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
            text-align: center;
        }

        .alert-primary { background-color: #cce5ff; color: #004085; }
        .alert-secondary { background-color: #e2e3e5; color: #383d41; }
        .alert-success { background-color: #d4edda; color: #155724; }
        .alert-danger { background-color: #f8d7da; color: #721c24; }
        .alert-warning { background-color: #fff3cd; color: #856404; }
        .alert-info { background-color: #d1ecf1; color: #0c5460; }
        .alert-light { background-color: #fefefe; color: #818182; }
        .alert-dark { background-color: #d6d8d9; color: #1b1e21; }

        /* Button styles */
        .btn {
            display: inline-block;
            padding: 10px 20px;
            margin: 10px 0;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            background-color: #0056b3;
        }

        /* Table styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        table, th, td {
            border: 1px solid #ddd;
            padding: 10px;
        }

        th {
            background-color: #f2f2f2;
            text-align: left;
        }

        td {
            text-align: center;
        }

        /* Horizontal line (delimiter) */
        hr {
            border: none;
            height: 1px;
            background-color: grey;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    ${htmlContent}
</body>
</html>
`;
            document.getElementById('lightbox').style.display = 'flex';
        }

     // function to open bookmark links in new tab. separate behavior for friends' links
        function openLink(url) {
          const prefix = 'https://marko-app.netlify.app?marko:common-';
          if (url.startsWith(prefix)) {
              let restOfString = url.substring(prefix.length);
        
               // Find the index of the first '-' character
               let firstDashIndex = restOfString.indexOf('-');
        
               // If there is a '-' character, extract name and link
         if (firstDashIndex !== -1) {
            let commonName = restOfString.substring(0, firstDashIndex);
            let commonId = restOfString.substring(firstDashIndex + 1);
            syncAndShowCommonMarko(commonId, commonName);
            console.log(`Title of common Marko: ${commonName}, its FileId: ${commonId}`);
    }
          }
            if (url.startsWith("friends/")) {
               console.log("friend!!");
               changeURL(url);
               renderFriend(url);
            } else {
                window.open(url, '_blank');
            }
}
        // function to open bookmark links in new tab. separate behavior for friends' links
        function openMarko(action, data, extras) {    
            if (action === loadVideo) {
               loadVideo(data);
            } else if (action === showWindow) {
                showWindow(data);
            } else if (action === showPDFLightbox) {
                showPDFLightbox(data, extras);
            } else if (action === syncAndShowCommonMarko) {
                syncAndShowCommonMarko(data, extras);
            } else if (action === downloadFile) {
                downloadFile(data, extras);
            } else if (action === showPost) {
                showPost(data);
            } else if (action === showShareNote) {
                showShareNote(data, extras);
            } else {
                openLink(data);
            }
}

// Function to download a file after user confirmation
function downloadFile(url, title) {
    if (confirm(`Do you want to download ${title} - ${url}?`)) {
        openLink(url);
    }
      }    
   
function playSound(sound) {
      var audio = document.getElementById(sound);
      audio.play();
    }    
   
// Function to remove the bookmark element from DOM
function removeMarko(index) {
            // Handle delete icon click with haptic feedback
          const bookmarkToDelete = document.getElementById(`bookmark-${index}`);
    
    if (bookmarkToDelete) {
        bookmarkToDelete.remove();
    }
     else {
        console.error(`Element with ID bookmark-${index} not found.`);
    }  
      }

        function showNoteForm() {
            const noteText = prompt("Enter your note:");
            if (noteText) {
                const iconUrl = noteIcon;
                const iconColor = getRandomColor();
                bookmarks.push({ text: noteText, iconUrl, iconColor });
                passCheck();
                saveLinks();
            }
        }

    function toggleNewLinkForm() {
            const newLinkForm = document.getElementById('new-link-form');
            newLinkForm.style.display = newLinkForm.style.display === 'none' || newLinkForm.style.display === '' ? 'block' : 'none';
            toggleButtonContainerVisibility();
        }

    function cancelAddLink() {
        toggleButtonContainerVisibility();
    }

    function getIconUrl(url, hostname) {
            if (url.startsWith('mailto:')) {
                return 'https://fonts.gstatic.com/s/i/materialicons/mail/v15/24px.svg';
            } else if (url.startsWith('tel:')) {
                return 'https://fonts.gstatic.com/s/i/materialicons/call/v15/24px.svg';
            } else if (url.startsWith('file://')) {
                return 'https://fonts.gstatic.com/s/i/materialicons/insert_drive_file/v15/24px.svg';
            } else if (hostname) {
                return `https://www.google.com/s2/favicons?domain=${hostname}&sz=32`;
            } else {
                return 'https://fonts.gstatic.com/s/i/materialicons/open_in_new/v15/24px.svg';
            }
        }


function addNote() {
        const noteInput = document.getElementById('new-note-text');
        const noteText = noteInput.value.trim();

        if (noteText) {
            const iconUrl = noteIcon;
            const iconColor = getRandomColor();

            bookmarks.push({ text: noteText, iconUrl, iconColor });
            noteInput.value = '';
            passCheck();
            saveLinks();
        }
    }
        

document.addEventListener('DOMContentLoaded', () => {
    let deferredPrompt; // Declare deferredPrompt only once

    window.addEventListener('beforeinstallprompt', (e) => {
        // Prevent the mini-infobar from appearing on mobile
        e.preventDefault();
        // Stash the event so it can be triggered later.
        deferredPrompt = e;
        // Update UI to notify the user they can install the PWA
        showInstallPrompt();
    });

    function showInstallPrompt() {
        // Show your install prompt UI here, for example, a button
        const installButton = document.getElementById('install-banner');
        installButton.style.display = 'block';

        // Drop the banner
        setTimeout(() => {
            installButton.style.top = '0';
        }, 100); // Small delay to trigger the CSS transition

        installButton.addEventListener('click', () => {
            // Show the install prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('User accepted the install prompt');
                    // Hide the install button
                    installButton.style.display = 'none';
                } else {
                    console.log('User dismissed the install prompt');
                }
                // Clear the deferredPrompt variable, as it can only be used once
                deferredPrompt = null;
            });
        });
    }

    window.addEventListener('appinstalled', () => {
        // Log install to analytics
        console.log('PWA was installed');
    });
});


// implement this soon in production to handle back button clicks properly    
function redirectIfNeeded() {
            try {
            const basePath = '/';
            const currentPath = window.location.pathname;

            // Check if the current path is not the base path
            if (currentPath !== basePath) {
                // Redirect to the base path
                window.location.replace(basePath);
            }
            }
            catch {
                        console.log('running locally');

            }
        }
  
// TODO uncomment this. look at previous function     
// window.onload = redirectIfNeeded;

function redirectToHomepage(event) {
            // Redirect to the homepage
                if (window.opener == null) {

            window.location.href = 'https://marko-app.netlify.app'; // Adjust this to your homepage URL if it's different
        }
}

        // Add an event listener for the popstate event
        window.addEventListener('popstate', redirectToHomepage);

        // Optionally push an initial state to history to ensure popstate works correctly
        window.history.pushState({}, '');        


// this is very important, this is what actually saves array in local storage    
function saveLinks() {
    localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
}
 
  // this is the way friends are added..    
  // window.onload = loadArrayFromURL();
        
    function openSettings () {
var button = document.getElementById('openModal');

// Check if the button element exists
if (button) {
    // Programmatically trigger a click event on the button
    button.click();
} else {
    console.error('Button with id "openModal" not found.');
}
    }
        // open modal as pseudo menu with About, Privacy and Settings tab
        document.addEventListener('DOMContentLoaded', function() {
            const openModalButton = document.getElementById('openModal');
            const modal = document.getElementById('myModal');
            const closeModalButton = document.getElementById('closeModal');
            const modalOverlay = document.getElementById('modalOverlay');

            function showModal() {
                modal.style.display = 'block';
                modalOverlay.style.display = 'block';
            }

            function hideModal() {
                modal.style.display = 'none';
                modalOverlay.style.display = 'none';
            }

            if (openModalButton && modal && closeModalButton && modalOverlay) {
                openModalButton.addEventListener('click', function() {
                    if (modal.style.display === 'block') {
                        hideModal();
                    } else {
                        showModal();
                    }
                });

                closeModalButton.addEventListener('click', function() {
                    hideModal();
                });

                modalOverlay.addEventListener('click', function() {
                    hideModal();
                });
            } else {
                console.error('One or more elements not found');
            }
        });



        function openTab(evt, tabId) {
            // Get all elements with class="tab-page" and hide them
            var tabPages = document.querySelectorAll('.tab-page');
            tabPages.forEach(page => page.classList.remove('active'));

            // Get all elements with class="tab-link" and remove the class "active"
            var tabLinks = document.querySelectorAll('.tab-link');
            tabLinks.forEach(link => link.classList.remove('active'));

            // Show the current tab, and add an "active" class to the button that opened the tab
            document.getElementById(tabId).classList.add('active');
            evt.currentTarget.classList.add('active');
        }
    
    // set a password. password methods give errors when the wrong password is entered only when trying to change it or when trying to delete bookmarks
    // for discretion entering the wrong password just renders empty links
    // this is made not for actual security, but to prohibit indiscrete use, partucularly in mobile
    function setPassword() {
            console.log("Pass is: " + localStorage.getItem('password'));
            const storedPassword = localStorage.getItem('password');
            if (storedPassword) {
                const enteredPassword = prompt('Enter the existing password to set a new one:');
                if (enteredPassword === null) {
                    alert('Password setting canceled.');
                    return;
                }
                if (enteredPassword !== storedPassword) {
                    alert('Incorrect existing password.');
                    return;
                }
            }

            const newPassword = prompt('Enter a new password:');
            if (newPassword === null) {
                alert('Password setting canceled.');
                return;
            }
            if (newPassword) {
                localStorage.setItem('password', newPassword);
                alert('Password set successfully!');
            } else {
                alert('Password cannot be empty.');
            }
        }
    
    
    function removePassword() {
            const storedPassword = localStorage.getItem('password');
            if (!storedPassword) {
                document.getElementById('result').textContent = 'this is also OK';
                return;
            }

            const enteredPassword = prompt('Enter the existing password to remove it:');
            if (enteredPassword === null) {
                alert('You have to enter pass');
                return;
            }

            if (enteredPassword === storedPassword) {
                localStorage.removeItem('password');
                alert('Password removed successfully!');
            } else {
                alert('Incorrect password. Password not removed.');
            }
        }
    
    // clears the local storage, updates DOM
    function clearLinks() {
        passCheck();
        const loggedIn = sessionStorage.getItem('loggedIn');
        console.log(loggedIn);
        if (loggedIn !== "true") {
            alert("Login to clear bookmarks. This action will also reset your password.");
            return;
        } else {
            if (confirm("Do you want to remove all your bookmarks ? This is irreversible !")) {
                localStorage.clear();
                location.reload();
            }
        }
}
    
// open a lightbox to show an iFrame    
function openLight(link) {
    const lightboxIframe = document.getElementById("lightbox-iframe");

    
    lightboxIframe.src = link;
        const lightboxContainer = document.getElementById("lightbox");

    lightboxContainer.classList.add("active");
}    
  function showWindow(link) {
    if (!link) {
      alert("Please enter a valid link.");
      return;
    }

    //const isYouTubeLink = link.includes("youtube.com") || link.includes("youtu.be");
    const lightboxContainer = document.getElementById("lightbox");
    const lightboxIframe = document.getElementById("lightbox-iframe");
    lightboxContainer.style.display = 'flex';
    lightboxIframe.src = link;
    document.getElementById('add-banner').style.display = 'none';
  }
    
// load a YouTube link in the iFrame
function loadVideo(link) {
    const init = () => {
        const ytlightboxContainer = document.getElementById("youtube-lightbox");

        ytlightboxContainer.classList.add("active");

        const videoId = link;

        const playerContainer = document.getElementById("player");
        playerContainer.innerHTML = ''; // Clear any existing iframe

        const iframe = document.createElement('iframe');
        iframe.src = `https://www.youtube-nocookie.com/embed/${videoId}`;
        iframe.width = '100%';
        iframe.height = '100%';
        iframe.title = 'YouTube video player';
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;';
        iframe.allowFullscreen = true;
        iframe.referrerPolicy = 'strict-origin-when-cross-origin';
        playerContainer.appendChild(iframe);

    };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
}

   

document.addEventListener('DOMContentLoaded', () => {
    const ytlightboxContainer = document.getElementById("youtube-lightbox");
    const playerContainer = document.getElementById("player");
    let inactivityTimer;

    function resetInactivityTimer() {
        clearTimeout(inactivityTimer);
        inactivityTimer = setTimeout(hideCloseButton, 3000); // Hide after 3 seconds of inactivity
    }

    function hideCloseButton() {
        const closeBtn = document.getElementById("close-yt");
        if (closeBtn) {
            closeBtn.classList.add('hidden');
        }
    }

    function showCloseButton() {
        const closeBtn = document.getElementById("close-yt");
        if (closeBtn) {
            closeBtn.classList.remove('hidden');
            resetInactivityTimer();
        }
    }

    // Event listeners based on user interaction
    if (ytlightboxContainer) {
        // For desktop and tablets
        ytlightboxContainer.addEventListener('mousemove', showCloseButton);
        // For mobile devices
        ytlightboxContainer.addEventListener('touchstart', showCloseButton);
    } else {
        console.error("YouTube lightbox container not found");
    }

    // Optional: Click event listener for close button
    const closeBtn = document.getElementById("close-yt");
    if (closeBtn) {
        closeBtn.addEventListener('click', () => {
            ytlightboxContainer.classList.remove("active");
            ytlightboxContainer.style.display = 'none'; // Optional: Hide the lightbox
            playerContainer.innerHTML = ''; // Clear the iframe
            location.reload(true);
        });
    } else {
        console.error("Close button not found");
    }
});
        
document.addEventListener('DOMContentLoaded', () => {
    const closeBtn = document.getElementById("close-btn");

    function closeMainLightbox() {
    location.reload();
    // TODO dont reload page, find a way to clear srcdoc 
    // const lightboxContainer = document.getElementById("lightbox");
    // document.getElementById("lightbox-iframe").src = "";
    // lightboxContainer.style.display = 'none';
    // document.getElementById('add-banner').style.display = 'block';  
    }

    if (closeBtn) {
        closeBtn.addEventListener('click', closeMainLightbox);
    } else {
        console.error("Close button not found");
    }
});

    const markos = document.querySelectorAll('.bookmark');
    let currentActiveBookmark = null;

    markos.forEach(bookmark => {
      const iconWrapper = bookmark.querySelector('.icon-wrapper') || bookmark;
      const deleteIcon = bookmark.querySelector('.delete-icon');

      iconWrapper.addEventListener('click', (event) => {
        const dataLink = bookmark.dataset.link;
        const action = bookmark.dataset.action;
        const content = document.querySelector('.content');

        // Handle menu item actions
        if (action) {
          switch (action) {
            case 'info':
              window.open('https://github.com/IonTeLOS/marko', '_blank');
              markoMenu.style.display = 'none';
              break;
            case 'add-link':
              openAdd();
              markoMenu.style.display = 'none';
              break;
            case 'generate':     
              downloadPage();
              markoMenu.style.display = 'none';
              break;
            case 'toggle-mode':
              toggleTheme();
              markoMenu.style.display = 'none';
              break;
            case 'share':
              sharePage();
              markoMenu.style.display = 'none';
              break;      
          }
          return; // Exit early to avoid toggle logic
        }

        
          // Handle content toggle or link opening
        if (bookmark.id !== 'marko') {
          // For any other non-Marko bookmark, hide content and remove active state
          content.style.display = 'none';
          if (currentActiveBookmark) {
            currentActiveBookmark.classList.remove('active');
          }
          currentActiveBookmark = null;

          // Open the external link in a new tab
          if (dataLink) window.open(dataLink, '_blank');
        }
      });

      // Handle delete icon click with haptic feedback
      if (deleteIcon) {
        deleteIcon.addEventListener('click', (event) => {
          event.stopPropagation(); // Prevent triggering the bookmark's click event
          
          // Trigger haptic feedback on supported devices
          if ("vibrate" in navigator) {
            navigator.vibrate(50); // Short 50ms vibration
          }
          
          if (confirm('Are you sure you want to delete this bookmark?')) {
            bookmark.remove();
            if (bookmark.dataset.link === 'show-content') {
              const contentToDelete = document.querySelector('.content');
              if (contentToDelete) contentToDelete.remove();
            }
            if (currentActiveBookmark === bookmark) {
              currentActiveBookmark = null;
            }
          }
        });
      }
    });

function sharePage() {
  window.focus();
  if (navigator.share) {
    navigator.share({
      title: document.title,
      url: window.location.href
    })
    .then(() => console.log('Shared successfully'))
    .catch((error) => console.error('Error in sharing:', error));
  } else {
    // Fallback for browsers that do not support Web Share API
    const url = window.location.href;
    const tempInput = document.createElement('input');
    tempInput.style.position = 'absolute';
    tempInput.style.left = '-9999px';
    tempInput.value = url;
    document.body.appendChild(tempInput);
    tempInput.select();
    document.execCommand('copy');
    document.body.removeChild(tempInput);
    //alert("Link has been copied to your clipboard.");
  }
}

document.addEventListener('DOMContentLoaded', function() {
    const markos = document.querySelectorAll('.bookmark');

    markos.forEach(bookmark => {
        // Click event
        bookmark.addEventListener('click', function() {
            setActiveBookmark(this);
        });

        // Mouse enter event (hover)
        bookmark.addEventListener('mouseenter', function() {
            setActiveBookmark(this);
        });

        // Focus event
        bookmark.addEventListener('focus', function() {
            setActiveBookmark(this);
        });

        // Mouse leave event
        bookmark.addEventListener('mouseleave', function() {
            removeActiveBookmark(this);
        });

        // Blur event
        bookmark.addEventListener('blur', function() {
            removeActiveBookmark(this);
        });
    });

    function setActiveBookmark(bookmark) {
        markos.forEach(b => b.classList.remove('active'));
        bookmark.classList.add('active');
    }

    function removeActiveBookmark(bookmark) {
        bookmark.classList.remove('active');
    }
});

function hideInstallBanner(event) {
    event.stopPropagation(); // Prevents event from bubbling up to the parent
    document.getElementById('install-banner').style.display = 'none';
}
    
// this is the definition of what the main button does, it initiates (or if clicked again ends!) the process of adding a new bookmark, shows the form and an extra row of buttons    
function openAdd() {
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        window.location.href = 'https://marko-app.netlify.app/createmarko?fromApp&darkMode';
    } else {
        window.location.href = 'https://marko-app.netlify.app/createmarko?fromApp';
    }
  /*
    const linkContainer = document.querySelector('.bookmarks-container');
    const upperContainer = document.querySelector('.container'); 
    if (upperContainer.style.display === 'none') {
        linkContainer.style.display = 'none';
        upperContainer.style.display = 'block';
        document.getElementById('new-link-form').style.display = 'block';
    } 
    else {
        document.getElementById('new-link-form').style.display = 'none';
        upperContainer.style.display = 'none';
        linkContainer.style.display = 'block';
    }
    */
  
    }
    
    function hideAdd() {
    document.getElementById('upper-container').style.display = 'none';
    document.getElementById('new-link-form').style.display = 'none';
    const linkContainer = document.querySelector('.bookmarks-container'); 
    linkContainer.style.display = 'block';
    }

    // TODO check if necessary
    function generate() {
      const newName = prompt('Enter the new name for the bookmark:');
  if (newName) {
  document.getElementById('bookmark-title').innerText = "";
    document.getElementById('bookmark-title').innerText = newName;
  }
    }

    

    // Add long-press detection for mobile devices (same as before)
    let longPressTimer;
    const longPressDuration = 450; // 500 milliseconds

    markos.forEach(bookmark => {
      bookmark.addEventListener('touchstart', () => { /* ... */ });
      bookmark.addEventListener('touchend', () => { /* ... */ });
      bookmark.addEventListener('touchmove', () => { /* ... */ });
      bookmark.addEventListener('touchcancel', () => { /* ... */ });
    });    
function createContainer() {
    const container = document.createElement('div');
    container.id = 'dropdownContainer';
    Object.assign(container.style, {
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        zIndex: '2147483647', // Maximum z-index value
        backgroundColor: 'white',
        padding: '20px',
        border: '2px solid red',
        borderRadius: '5px',
        boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
        minWidth: '300px',
        minHeight: '100px',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'flex-start',
        alignItems: 'stretch',
        overflow: 'visible',
        pointerEvents: 'auto', // Ensure it's clickable
    });
    document.body.appendChild(container);
    console.log("Container added to body");
}
function showContactBookmarksDropdown() {
    createContainer();
    console.log("Container created");

    const container = document.getElementById('dropdownContainer');
    container.innerHTML = 'Loading...';

    const bookmarks = JSON.parse(localStorage.getItem('bookmarks')) || [];
    console.log("Bookmarks retrieved:", bookmarks);

    const contactBookmarks = bookmarks.filter(bookmark => bookmark[0] === 'contact');
    console.log("Contact bookmarks:", contactBookmarks);

    if (contactBookmarks.length === 0) {
        container.innerHTML = 'No contact bookmarks found.';
        container.style.color = 'red';
        return;
    }

    const select = document.createElement('select');
    select.id = 'contactBookmarks';
    Object.assign(select.style, {
        width: '100%',
        padding: '10px',
        fontSize: '16px',
        backgroundColor: 'yellow', // Keep this for debugging
        border: '1px solid black',
        borderRadius: '4px',
        appearance: 'menulist',
        display: 'block',
        marginTop: '10px',
        cursor: 'pointer', // Show it's clickable
        pointerEvents: 'auto', // Ensure it's clickable
    });

    const defaultOption = document.createElement('option');
    defaultOption.textContent = 'Select a contact bookmark';
    defaultOption.disabled = true;
    defaultOption.selected = true;
    select.appendChild(defaultOption);

    contactBookmarks.forEach(bookmark => {
        const option = document.createElement('option');
        option.textContent = bookmark[2]; // Display bookmark name
        option.value = bookmark[1]; // Set value as fileId
        select.appendChild(option);
    });

    select.addEventListener('change', function() {
        const selectedFileId = this.value;
        console.log('Selected FileId:', selectedFileId);
    });

   // Add a visible label
    const label = document.createElement('label');
    label.htmlFor = 'contactBookmarks';
    label.textContent = 'Select a contact:';
    label.style.display = 'block';
    label.style.marginBottom = '5px';

    container.innerHTML = '';
    container.appendChild(label);
    container.appendChild(select);

    // Force a redraw
    container.style.display = 'none';
    container.offsetHeight; // This line triggers a reflow
    container.style.display = 'flex';
}

// core action to create an html document for the user to share their links - upload the document on a server
// this also gives the option to create a sharable link with query parameters that stores the links and can it load it in app by a different user    
async function downloadPage() {
        const linkContainer = document.querySelector('.bookmarks-container');
        linkContainer.innerHTML = ''; 
        passCheck();
        const linksContainer = document.querySelector('.bookmarks-container');
        const linksHTML = linksContainer.innerHTML;
        const newName = prompt('You are ready to download your Markos as a complete webpage. Choose a page title:', 'My Markos');
  
        // Set default name if newName is blank or null
        const title = newName ? newName : 'My Markos';
let currentState = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>${title}</title>
    <meta http-equiv="cache-control" content="public">
    <meta http-equiv="expires" content="Thu, 31 Dec 2099 23:59:59 GMT"> 
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23000' d='M0 0h24v24H0z'/%3E%3Cpath fill='%2300bcd4' d='M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM15 3v2h2.59L8.7 13.89l1.41 1.41L19 6.41V9h2V3h-6z'/%3E%3C/svg%3E" type="image/svg+xml">    
  <script src="https://documentcloud.adobe.com/view-sdk/main.js"><\/script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Icons+Outlined" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/notiflix@3/dist/notiflix-aio-3.2.7.min.js"><\/script>
  <link href="https://cdn.jsdelivr.net/npm/notiflix@3/src/notiflix.min.css" rel="stylesheet">
       <style> 
body {
  font-family: Roboto, sans-serif;
  position: relative;
  display: flex;
  min-height: 100vh;
  justify-content: center;
  flex-direction: column;
  max-width: 100%;
  overflow-x: hidden;
  height:auto!important;    
  margin: 8px;
  margin-bottom: 70px;
  padding: 0;
  transition: background-color 0.5s ease-in-out, color;
}

body.light-mode {
  background-color: #e3f2fd;
  color: #333333;
}

body.light-mode .bookmark {
  background-color: #bbdefb;
}
    
body.dark-mode {
  background-color: #292929;
  color: #999999;
}

body.dark-mode .bookmark {
background-color: #1f1b24;
}

/* Hover effect for .bookmark and related elements */
.body.light-mode .bookmark:hover {
  background-color: #acc8e5; /* Lighter background on hover */
}
    
/* System Default (initial state) */
@media (prefers-color-scheme: dark) {
  body {
    background-color: #292929;
    color: #999999;
  }
  .bookmark {
    background-color: #1f1b24;
    transition: background-color 0.2s ease-in-out; /* Smooth transition on background color change */
  }
}

/* Hover effect for .bookmark and related elements */
.body.dark-mode .bookmark:hover {
  background-color: #333; /* Darker background on hover */
}
      
.bookmarks-container {
      flex: 100;
      display: flex;
      flex-direction: column;
    }   
      
 
.bookmark .bookmark-title {
  font-weight: bold;
  text-align: center;
  flex: 1;
  transition: transform 0.2s ease-in-out;
}


.bookmark-title:hover {
  font-weight: bold;
  text-align: center;
  flex: 1;
  transition: transform 0.2s ease-in-out;
  transform: scale(1.20);
}    



      
      .bookmark-wrapper {
        width: 100%;
      }  

    .bookmark .icon-wrapper {
      display: flex;
      align-items: center;
      flex: 1;
    }

    .bookmark .icon-container {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 72px; /* Standard width */
      height: 72px; /* Standard height */
      border-radius: 50%;
      transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
      margin-right: 16px;
      background-color: #fff; /* Light background */
    }

    .bookmark:hover .icon-container {
      transform: scale(1.1); /* Enlarge container on hover */
    }
    
/* Keyframes for blinking animation */
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Bookmark Styling */
.bookmark {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px;
  border-radius: 4px;
  cursor: pointer;
  position: relative;
  margin-bottom: 8px;
  border: 4px solid transparent; /* Initial state */
  background-clip: padding-box;
}

.bookmark:hover {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Adjusted shadow color and intensity */
}

.bookmark.active {
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15);
}

/* Default ::before pseudo-element styling */
.bookmark::before {
  content: '';
  position: absolute;
  top: -4px;
  right: -4px;
  bottom: -4px;
  left: -4px;
  z-index: -1;
  border-radius: inherit;
  border: 4px solid transparent;
  background: transparent;
  transition: background 0.3s ease, border 0.3s ease;
}

/* Apply blinking animation on active state */
.bookmark.active::before {
  background: blue;
  animation: blink 2s infinite; /* Ensure duration and iteration are set */
}

/* Hover effect (if needed, but make sure it doesnâ€™t override swipe states) */
.bookmark:hover::before {
  background: blue;
  animation: blink 2s infinite; /* Ensure duration and iteration are set */
}

/* Swipe states override hover effect */
.bookmark.swipe-left::before,
.bookmark.swipe-right::before {
  background: transparent !important; /* Ensure swipe background is visible */
  border: none !important; /* Optionally hide the border */
}

/* Swiped left state */
.bookmark.swipe-left::before {
  background: linear-gradient(to right, #FF0000, rgba(255, 0, 0, 0.1)) !important;
}

/* Swiped right state */
.bookmark.swipe-right::before {
  background: linear-gradient(to left, #00FF00, rgba(0, 255, 0, 0.1)) !important;
}

.icon-container {
            width: 72px; /* Adjust as needed */
            height: 72px; /* Adjust as needed */
            position: relative;
            overflow: hidden;
        }
.icon-container::before {
            content: '';
            position: absolute;
            width: 62px; /* 72px (size of container) - 5px (border) * 2 */
            height: 62px; /* Same calculation as width */
            border-radius: 50%; /* Makes the ring circular */
            border: 5px solid var(--ring-color, #2ecc71); /* Thickness and color of the ring TODO change default color */
            box-sizing: border-box; /* Ensures the border is included in the size */
        }  
.bookmark-icon {
  font-size: 36px;
  object-fit: contain; /* Adjust to 'contain' if you prefer the image to be fully visible */
  display: block;    
  transition: color 0.2s ease-in-out, transform 0.2s ease-in-out;
}

.bookmark:hover .bookmark-icon {
  color: #0d47a1;
}

/* System Default (initial state) */
@media (prefers-color-scheme: light) {
  body {
    background-color: #e3f2fd; /* Align with .body.light-mode */
    color: #333333; /* Align with .body.light-mode */
  }
  .bookmark {
    background-color: #bbdefb; /* Align with .body.light-mode .bookmark */
    transition: background-color 0.2s ease-in-out; /* Smooth transition on background color change */
  }
}

/* Hover effect for .bookmark and related elements */
.body.light-mode .bookmark:hover {
  background-color: #acc8e5; /* Lighter background on hover */
}
    
/* System Default (initial state) */
@media (prefers-color-scheme: dark) {
  body {
    background-color: #292929;
    color: #999999;
  }
  .bookmark {
    background-color: #1f1b24;
    transition: background-color 0.2s ease-in-out; /* Smooth transition on background color change */
  }
}

/* Hover effect for .bookmark and related elements */
.body.dark-mode .bookmark:hover {
  background-color: #333; /* Darker background on hover */
}

.tooltip {
    position: fixed;
    bottom: 15px; /* Adjust as needed */
    left: 10px; /* Adjust as needed */
    width: 16rem; /* 256px (w-64 in tailwindcss) */
    background-color: #ffffff; /* White background */
    border: 1px solid #cccccc; /* Gray border */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* Shadow effect */
    padding: 5px 10px;
    border-radius: 4px;
    display: none;
    z-index: 1003; /* Set z-index to 1003 */
    font-size: 0.875rem; /* 14px (text-sm in tailwindcss) */
    color: #0d47a1; /* Blue text color */
    white-space: nowrap; /* Prevent line breaks */
    overflow: hidden; /* Hide overflowing content */
}

.tooltip-content {
    display: inline-block;
    white-space: nowrap;
    position: relative;
}

@keyframes scroll-text {
    0% {
        transform: translateX(100%);
    }
    15% {
        transform: translateX(0); /* Immediately show text */
    }
    90% {
        transform: translateX(-100%);
    }
    100% {
        transform: translateX(-100%); /* Restart */
    }
}

.tooltip-scrolling {
    animation: scroll-text 10s linear infinite;
}

    .delete-icon {
      color: #f44336; 
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%); /* Center icon vertically */
      opacity: 0; /* Initially hide the delete icon */
      transition: opacity 0.2s ease-in-out, color 0.2s ease-in-out, transform 0.2s ease-in-out; /* Add transitions */
      font-size: 24px; /* Smaller than main icons */
    }

    .bookmark:hover .delete-icon,
    .bookmark.long-press .delete-icon {
      opacity: 1; /* Show delete icon on hover or long press */
      transform: translateY(-50%) scale(1.1); /* Scale up while maintaining vertical center */
    }

    .delete-icon:hover {
      color: #d32f2f; /* Darker red on hover */
      cursor: pointer; /* Change cursor to indicate clickability */
      transform: translateY(-50%) scale(1.2); /* Scale up more on direct hover */
    }

    .lightbox {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
      z-index: 1002;
    }
    .lightbox.active {
      display: flex;
    }
    .lightbox-content {
      position: relative;
      width: 90%;
      height: 90%;
      max-width: 100%;
      max-height: 100%;
      background-color: white;
      border-radius: 10px;
    }
    .lightbox-content .content-container {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      position: relative;
    }
    /* Option 1: Iframe with absolute positioning */
    .lightbox-content iframe {
      width: 100%;
      height: 100%;
      border: none;
      position: absolute;
      overflow-x: hidden;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 10px; /* Rounded corners for iframe */
    }
 /* Closing Button (outside lightbox) */
    .close-btn {
      position: fixed; /* Make the element absolutely positioned */
      bottom: 5px; /* Position the element at the bottom */
      left: 50%; /* Position the element horizontally at 50% */
      transform: translateX(-50%); /* Center the element horizontally */
      background-color: #3f51b5; /* Material Blue */
      color: white;
      border: none;
      width: 38px;
      height: 38px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      z-index: 1002; /* Ensure button is on top of lightbox */
      font-size: 24px; /* Adjust font size for desired icon size */
      border-radius: 50%;
      box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2); /* Material shadow effect */
    }
    .close-btn:hover {
      background-color: #384890
      }  
      #player-container {
      width: 100%;
      max-width: 640px;
      aspect-ratio: 16 / 9;
      margin-top: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    @media (max-width: 768px) {
      #player-container {
        width: 95%;
      }
    }
    @media (orientation: landscape) and (max-width: 900px) {
      #player-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        max-width: none;
        margin: 0;
        z-index: 9999;
      }
    }
        #youtube-lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1001;        }
        #youtube-lightbox.active {
            display: flex;
        }
        #player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #close-yt {
            position: absolute;
            top: 90px;
            right: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffffff;
            color: #ffffff;
            cursor: pointer;
            font-size: 24px;
            opacity: 1;
            transition: opacity 0.3s;
            z-index: 9999;
        }
        #close-yt.hidden {
            opacity: 0;
            pointer-events: none;
        }

#main-bookmark {
    position: -webkit-sticky; /* For Safari */
    position: sticky;         /* Standard syntax */
    top: 0;
    z-index: 1000;
}


/* Apply no-select to everything */
* {
  user-select: none;
}


        .offline-banner {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px;
            background-color: #ffcc00; /* Adjust color as needed */
            color: #333; /* Adjust text color as needed */
            text-align: center;
            padding: 10px;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
            z-index: 998; /* Ensure it appears above other elements */
            transition: transform 0.3s ease-in-out; /* Smooth transition for sliding effect */
            transform: translateY(100%); /* Initially hidden off the bottom of the viewport */
            visibility: hidden; /* Initially hidden */
        }

        /* Show the banner */
        .offline-banner.show {
            transform: translateY(0); /* Move to its normal position */
            visibility: visible; /* Make it visible */
        }

         iframe {
            aspect-ratio: 16/9;
            width: 100%;
        }
.container {
  transition: margin-bottom 0.3s ease;
  margin-bottom: 40px;    
}   
      
.material-btn {
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  transition: color 0.2s ease-in-out, transform 0.2s ease-in-out, background 0.2s ease-in-out;
  height: 72px;
  width: 72px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  margin: 0 10px;
}

.material-btn:hover {
  color: #333333;
  transform: scale(1.1);
}

.material-btn .material-icon {
  font-size: 42px; /* Change the icon size to 48x48 */
}
  
.material-btn:focus {
  outline: none;
  background-color: rgba(255, 255, 255, 0.3); /* Darker background on focus */
}

.material-btn:focus-visible {
  outline: none;
  background-color: rgba(255, 255, 255, 0.3); /* Darker background on focus */
}
 #powered-by-marko {
      position: absolute;
      bottom: -40px;
      right: 30px;
      font-size: 18px;
      cursor: pointer;
      color: #0d47a1; /* To make the text stand out */
      padding: 0; /* Add some padding around the text */
      border-radius: 5px; /* Make the edges rounded */
      transition: transform 0.3s ease, color 0.3s ease; /* Smooth transition for transform and color */
      display: flex;
      align-items: center; /* Center items vertically */
      gap: 12px; /* Space between SVG and text */
    }
    #powered-by-marko img {
      vertical-align: middle; /* Center SVG vertically */
      width: 36px; /* Set the width of the SVG */
      height: 36px; /* Set the height of the SVG */
    }

    #powered-by-marko:hover {
      color: #f44336;
      transform: scale(1.1);
    }

    @media screen and (max-width: 600px) {
      #powered-by-marko {
        left: 50%;
        bottom: -30px;
        right: auto;
        transform: translateX(-50%);
        font-size: 16px;
      }
    }

  </style>
</head>
<body>

    <!-- Lightbox with iframe and YouTube player -->
  <div class="lightbox" id="lightbox">
    <div class="lightbox-content">
      <div id="content-container">
<iframe id="lightbox-iframe" class="lightbox-iframe" src="" allowfullscreen allow="autoplay"></iframe>
          <button id="close-btn" class="close-btn">
        <i class="material-icons">close</i>
      </button>
      </div>
    </div>
  </div>
<div class="youtube-lightbox" id="youtube-lightbox">
    <button id="close-yt">&times;</button>
    <div id="player"></div>
</div>

    <!-- Placeholder div for Adobe PDF Embed API -->
    <div id="adobe-dc-view"></div>
    <div>
<div id="tooltip" class="tooltip">
    <div class="tooltip-content" id="tooltip-content"></div>
</div>
    
  <div class="offline-banner" id="offline-banner">
        <span class="material-icons">wifi_off</span>
    </div>



        
    </div>
        <div id="marko-container" class="bookmarks-container" no-select>${linksHTML}</div>
        
    <div id="powered-by-marko" onclick="goToApp()">
    <img src="https://raw.githubusercontent.com/IonTeLOS/marko/main/triskelion.svg" alt="Logo">
    <span>Powered by MarkoÂ©</span>
    </div>
    
    <script>      
        // Call the function on page load
        window.onload = checkIfLocalAndConfirm;

Notiflix.Notify.init({
            position: 'center-top',
            timeout: '7000',
            clickToClose: 'true',
            zindex: 4003,
            cssAnimationStyle: 'from-top',
            fontFamily: 'Roboto, sans-serif', // Set font family
            });
   Notiflix.Confirm.init({
    className: 'notiflix-prompt-custom',
    position: 'center', // Position in the upper half of the screen in the middle
    width: '360px', // Maximum width
    borderRadius: '8px', // Border radius
    useGoogleFont: true, // Disable Google Fonts to use custom font
    fontFamily: 'Roboto, sans-serif', // Set font family
    cssAnimationStyle: 'zoom', // Animation style
    backOverlay: true,
    plainText: true,
    okButtonBackground: '#0D47A1',
    titleColor: '#000000',
    titleFontSize: '20px',
    messageFontSize: '18px',
    zindex: 4000, 
});
function sharePage() {
if (navigator.share) {
  window.focus();
  navigator.share({
    title: document.title,
    url: window.location.href
  })
  .then(() => {
    console.log('Shared successfully');
    const nav = \`https://marko-app.netlify.app?type=friend&friendlink=\${window.location.href}&friendname=\${document.title}&createMarko=true\`;
    window.location.href = nav;
  })
  .catch((error) => console.error('Error in sharing:', error));
  const nav = \`https://marko-app.netlify.app?type=friend&friendlink=\${window.location.href}&friendname=\${document.title}&createMarko=true\`;
   setTimeout(() => {
      window.location.href = nav;
    }, 4000);
} else {
  // Fallback for browsers that do not support Web Share API
  const url = window.location.href;
  const tempInput = document.createElement('input');
  tempInput.style.position = 'absolute';
  tempInput.style.left = '-9999px';
  tempInput.value = url;
  document.body.appendChild(tempInput);
  tempInput.select();
  document.execCommand('copy');
  document.body.removeChild(tempInput);
  Notiflix.Notify.success('Link copied to clipboard');
  const nav = \`https://marko-app.netlify.app?type=friend&friendlink=\${window.location.href}&friendname=\${document.title}&createMarko=true\`;
  setTimeout(() => {
      window.location.href = nav;
    }, 4000);
}
}


       function toggleTheme() {
      const body = document.body;
      if (body.classList.contains('dark-mode')) {
        body.classList.remove('dark-mode');
        body.classList.add('light-mode');
      } else if (body.classList.contains('light-mode')) {
        body.classList.remove('light-mode');
      } else {
        body.classList.add('dark-mode');
      }
    }

function goToApp() {
       window.open('https://marko-app.netlify.app', '_blank');
        }
        
// Function to open bookmark links in a new tab with separate behavior for friends' links
function openLink(url) {
        window.open(url, '_blank');
}
        // function to open bookmark links in new tab. separate behavior for friends' links
        function openMarko(action, data, extras) {
            if (action === loadVideo) {
               loadVideo(data);
            } else if (action === showWindow) {
                showWindow(data);
            } else if (action === showPDFLightbox) {
                showPDFLightbox(data, extras);
            } else if (action === downloadFile) {
                downloadFile(data, extras);
            } else if (action === showPost) {
                showPost(data);
            } else if (action === showShareNote) {
                showShareNote(data, extras);
            } else {
                openLink(data);
            }
}


        function showNoteForm() {
            const noteText = prompt("Enter your note:");
            if (noteText) {
                const iconUrl = noteIcon;
                const iconColor = getRandomColor();
                links.push({ text: noteText, iconUrl, iconColor });
                passCheck();
                saveLinks();
            }
        }
// Function to handle click on home icon

        // Function to handle click on share icon
        function handleHomeClick() {
            const param = 'friendname=${title}&friendlink=${window.location.origin}${window.location.pathname}';
            if (param.includes("file://") || param.includes("content://")) {
                    confirm('Upload this file on a server so that everyone can access it?');
                    if (confirm) {
                    openLink("https://tiiny.host");
                    }
                    return;
            }
            openLink("https://marko-app.netlify.app?" + param);
        }
        
        document.getElementById('home-icon').addEventListener('click', handleHomeClick);

        function checkIfLocalAndConfirm() {
            if (window.location.protocol === 'file:' || window.location.protocol === 'content:') {
                // Show confirmation dialog
                var userConfirmed = confirm('Do you want to create your own site? Upload current file ${title}.html on tiiny.host!');
                if (userConfirmed) {
                    // Open the link if the user confirms
                    window.location.href = 'https://tiiny.host';
                }
            }
        }
function detectTheme() {
    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    const theme = localStorage.getItem("theme");

    // Apply the theme based on user preference or system theme
    if (theme) {
        if (theme === "dark") {
            document.body.classList.add('dark-mode');
            document.body.classList.remove('light-mode');
            console.log("Following user choice: Dark");
        } else {
            document.body.classList.add('light-mode');
            document.body.classList.remove('dark-mode');
            console.log("Following user choice: Light");
        }
    } else {
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
            document.body.classList.remove('light-mode');
            console.log("Following system theme: Dark");
        } else {
            document.body.classList.add('light-mode');
            document.body.classList.remove('dark-mode');
            console.log("Following system theme: Light");
        }
    }
}


// detect if run on mobile or on desktop based on screen width. TODO use this function to make it more mobile friendly
function isMobileDevice() {
  return 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0 ||
         window.matchMedia('(max-width: 768px)').matches;
}

if (isMobileDevice()) {
  console.log("Marko seems to be running on mobile");
} else {
  console.log("Marko seems to be running on desktop");
}   

    // show an offline notice in the form of a banner if offline, autohide it when back online
    function checkConnection() {

        const offlineBanner = document.getElementById('offline-banner');
        if (!navigator.onLine) {
            document.getElementById('offline-banner').classList.add('show');
        }
        window.addEventListener('online', () => {
            document.getElementById('offline-banner').classList.remove('show');
        });
        window.addEventListener('offline', () => {
            document.getElementById('offline-banner').classList.add('show');
        });
    }

        

function clearFrame() {
    document.getElementById("lightbox-iframe").srcdoc = "";
}  

function showShareNote(title, text) {
if (confirm("Do you want to share the note with your friends or other apps?")) {
    shareNote(title, text);
    return;
}
else {    
      var iframe = document.getElementById('lightbox-iframe');
iframe.srcdoc =\`
<div style="display: flex; justify-content: center; align-items: center; height: 100vh; background-color: lightgrey; text-align: center; font-family: 'Roboto', sans-serif;">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
    </style>
    <div style="display: flex; flex-direction: column; justify-content: center; align-items: center;">
        <div style="font-weight: bold; font-size: 24px;">\${title}</div>
        <div style="font-weight: normal; font-size: 18px;">\${text}</div>
    </div>
</div>\`;
// Display the lightbox
document.getElementById('lightbox').style.display = 'flex';
// Set a timeout to hide the lightbox after 20 seconds     
setTimeout(function() {
    document.getElementById('lightbox').style.display = 'none';
}, 20000);
}
}

function shareNote(title, text) {
    if (navigator.share) {
    window.focus();
    navigator.share({
      title: title,
      text: text
    })
    .then(() => {
      console.log('Successfully shared');
    })
    .catch((error) => {
      console.error('Error sharing:', error);
    });
  } else if (navigator.clipboard) {
    window.focus();
    navigator.clipboard.writeText(title + ": " + text)
      .then(() => {
        //alert('Note text has been copied to the clipboard.');
      })
      .catch((error) => {
        console.error('Error copying to clipboard:', error);
        // alert('Failed to copy text to clipboard.');
      });
  } 
}

// Function to check if an element is partially visible at the top, considering the main-bookmark
        function isPartiallyVisibleAtTop(el, offset) {
            const rect = el.getBoundingClientRect();
            return rect.top < offset && rect.bottom > offset;
        }

        // Function to scroll the element into view
        function adjustScroll() {
            const mainBookmark = document.getElementById('main-bookmark');
            const mainBookmarkHeight = mainBookmark.getBoundingClientRect().height;
            const paddingOffset = 10; // Adjust this value to match your bookmark padding
            const bookmarks = document.querySelectorAll('.bookmark');
            bookmarks.forEach(bookmark => {
                const rect = bookmark.getBoundingClientRect();
                if (isPartiallyVisibleAtTop(bookmark, mainBookmarkHeight + paddingOffset)) {
                    const scrollOffset = rect.top - (mainBookmarkHeight + paddingOffset);
                    window.scrollBy({
                        top: scrollOffset,
                        behavior: 'smooth'
                    });
                }
            });
        }

        // Debounce function to limit the rate at which the adjustScroll function is called
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Add scroll event listener with debounce
        window.addEventListener('scroll', debounce(adjustScroll, 100));


// detect if run on mobile or on desktop based on screen width. TODO use this function to make it more mobile friendly
    
function showTooltip(link) {
    currentLink = link;
    const isGoodForStatus = () => {
        return 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0 ||
               window.matchMedia('(max-width: 768px)').matches;
    };

    if (!isGoodForStatus ()) {
        const tooltip = document.getElementById('tooltip');
        const tooltipContent = document.getElementById('tooltip-content');

        if (tooltip && tooltipContent) {
            tooltipContent.textContent = link;
            tooltip.style.display = 'block';

            const tooltipWidth = tooltip.offsetWidth;
            const textWidth = tooltipContent.scrollWidth;

            // If the text overflows the tooltip, apply the scrolling animation
            if (textWidth > tooltipWidth) {
                tooltipContent.style.animation = 'scroll-text 10s linear infinite';
            } else {
                tooltipContent.style.animation = 'none';
            }
        }
    }
}


    function hideTooltip() {
        const tooltip = document.getElementById('tooltip');
        if (tooltip) {
            tooltip.style.display = 'none';
        }
    }
        

        function showPost(htmlContent) {
            var iframe = document.getElementById('lightbox-iframe');
iframe.srcdoc = \`
<div style="display: flex; justify-content: center; align-items: center; height: 100vh; background-color: lightcyan; text-align: center; flex-direction: column; overflow-x: hidden; font-family: 'Roboto', sans-serif;">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
        img {
            max-width: 100%;
            height: auto;
        }
        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
        }
    </style>
    \${htmlContent}
</div>\`;
            document.getElementById('lightbox').style.display = 'flex';
}
        
// Function to download a file after user confirmation
function downloadFile(url, title) {
    if (confirm(\`Do you want to download \${title} - \${url}?\`)) {
        openLink(url);
    }
      }




    
// open a lightbox to show an iFrame    
function openLight(link) {
    const lightboxIframe = document.getElementById("lightbox-iframe");

    
    lightboxIframe.src = link;
        const lightboxContainer = document.getElementById("lightbox");

    lightboxContainer.classList.add("active");
}    
  function showWindow(link) {
    if (!link) {
      alert("Please enter a valid link.");
      return;
    }

    //const isYouTubeLink = link.includes("youtube.com") || link.includes("youtu.be");
    const lightboxContainer = document.getElementById("lightbox");
    const lightboxIframe = document.getElementById("lightbox-iframe");
    lightboxContainer.style.display = 'flex';
    lightboxIframe.src = link;
  }
    
// load a YouTube link in the iFrame
function loadVideo(link) {
    const init = () => {
        const ytlightboxContainer = document.getElementById("youtube-lightbox");

        ytlightboxContainer.classList.add("active");

        const videoId = link;

        const playerContainer = document.getElementById("player");
        playerContainer.innerHTML = ''; // Clear any existing iframe

        const iframe = document.createElement('iframe');
        iframe.src = \`https://www.youtube-nocookie.com/embed/\${videoId}\`;
        iframe.width = '100%';
        iframe.height = '100%';
        iframe.title = 'YouTube video player';
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture;';
        iframe.allowFullscreen = true;
        iframe.referrerPolicy = 'strict-origin-when-cross-origin';
        playerContainer.appendChild(iframe);

    };

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
}
  
function updateSwipeClasses(wrapper, deltaX) {
    const bookmark = wrapper.closest('.bookmark');
    bookmark.classList.remove('swipe-left', 'swipe-right');
    if (deltaX < 0) {
        bookmark.classList.add('swipe-left');
    } else if (deltaX > 0) {
        bookmark.classList.add('swipe-right');
    }
}

function initSwipeDetection() {
    document.querySelectorAll('.bookmark-wrapper').forEach(wrapper => {
        let touchstartX = 0;
        let touchstartY = 0;
        let touchstartTime = 0;
        let isSwipeInProgress = false;
        const bookmarkId = wrapper.closest('.bookmark').getAttribute('data-index');
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        const handleSwipeStart = (e) => {
            if (isSwipeInProgress) return;
            isSwipeInProgress = true;
            touchstartTime = Date.now();
            if (isTouchDevice) {
                touchstartX = e.touches[0].clientX;
                touchstartY = e.touches[0].clientY;
            } else {
                touchstartX = e.clientX;
                touchstartY = e.clientY;
            }
        };

        const handleSwipeMove = (e) => {
            if (!isSwipeInProgress) return;
            
            let currentX, currentY;
            if (isTouchDevice) {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
            } else {
                currentX = e.clientX;
                currentY = e.clientY;
            }
            handleSwipe(wrapper, bookmarkId, touchstartX, currentX, touchstartY, currentY);
        };

        const handleSwipeEnd = (e) => {
            isSwipeInProgress = false;
            const touchendTime = Date.now();
            const elapsedTime = touchendTime - touchstartTime;

            // Check if the movement is below the threshold for click detection
            const threshold = 30;
            let currentX, currentY;
            if (isTouchDevice) {
                currentX = e.changedTouches[0].clientX;
                currentY = e.changedTouches[0].clientY;
            } else {
                currentX = e.clientX;
                currentY = e.clientY;
            }

            const deltaX = Math.abs(currentX - touchstartX);
            const deltaY = Math.abs(currentY - touchstartY);

            if (deltaX < threshold && deltaY < threshold && elapsedTime < 200) {
                // It's a click, not a swipe
                return;
            }

            updateSwipeClasses(wrapper, 0); // Reset classes
        };

        if (isTouchDevice) {
            wrapper.addEventListener('touchstart', handleSwipeStart, { passive: true });
            wrapper.addEventListener('touchmove', handleSwipeMove, { passive: true });
            wrapper.addEventListener('touchend', handleSwipeEnd);
        } else {
            wrapper.addEventListener('mousedown', handleSwipeStart);
            wrapper.addEventListener('mousemove', handleSwipeMove);
            wrapper.addEventListener('mouseup', handleSwipeEnd);
            wrapper.addEventListener('mouseleave', handleSwipeEnd); // Add this line
        }

        // Prevent click event if a swipe is detected
        wrapper.addEventListener('click', (e) => {
            if (isSwipeInProgress) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        });
    });
}

let isSwipeActionInProgress = false;
let lastSwipeTime = 0;
const swipeCooldown = 1000; // 1 second cooldown between swipes

function debounce(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

const debouncedHandleSwipe = debounce((wrapper, bookmarkId, startX, currentX, startY, currentY) => {
    const now = Date.now();
    if (isSwipeActionInProgress || now - lastSwipeTime < swipeCooldown) {
        return;
    }

    const threshold = 30;
    const verticalThreshold = 50;
    const deltaX = currentX - startX;
    const deltaY = Math.abs(currentY - startY);

    if (deltaY > verticalThreshold) return;

    if (Math.abs(deltaX) > threshold) {
        if (!bookmarkId) {
        console.log('no bookmark id, this is probably main-bookmark being swiped, nothing to do');
          return;
        }
        isSwipeActionInProgress = true;

          if (deltaX < 0) {
            // Left swipe
            Notiflix.Confirm.show(
                'Please confirm',
                'Do you really want to remove this Marko?',
                'Yes',
                'No',
                () => {
                    try {
                        removeMarko(bookmarkId);
                    } catch (error) {
                        console.error('Error clearing link:', error);
                    }
                },
                () => {
                    // No action needed if 'No' is clicked
                    isSwipeActionInProgress = false;
                }
            );
        } else {
            // Right swipe
            try {
                shareMarko(bookmarkId);
            } catch (error) {
                console.error('Error constructing link:', error);
            }
        }

        lastSwipeTime = now;
        setTimeout(() => {
            isSwipeActionInProgress = false;
        }, 500); // Reset the flag after 500ms
    }
}, 250); // Debounce for 250ms

function handleSwipe(wrapper, bookmarkId, startX, currentX, startY, currentY) {
    const deltaX = currentX - startX;
    const deltaY = Math.abs(currentY - startY);
    const verticalThreshold = 50;

    if (deltaY > verticalThreshold) {
        updateSwipeClasses(wrapper, 0); // Reset classes if vertical swipe
        return;
    }

    updateSwipeClasses(wrapper, deltaX);

    debouncedHandleSwipe(wrapper, bookmarkId, startX, currentX, startY, currentY);
}

// Check if the DOM is already loaded for swipe detection initialization
if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initSwipeDetection);
} else {
    initSwipeDetection();
}



function hideDeleted() {
    // Retrieve the array from localStorage and parse it
let hidden = JSON.parse(localStorage.getItem('hide-these')) || [];

// Perform a function on each item in the array
hidden.forEach(item => {
    // Your function here
    console.log(item); 
    const deletedMarko = document.getElementById(item);
    deletedMarko.remove();
});
}

// Function to remove the bookmark element from DOM
function removeMarko(index) {
            // Handle delete icon click with haptic feedback
          const bookmarkToDelete = document.getElementById(\`bookmark-\${index}\`);
          const hideIndex = \`bookmark-\${index}\`;
    
    if (bookmarkToDelete) {
        bookmarkToDelete.remove();
        let hidden = JSON.parse(localStorage.getItem('hide-these')) || [];
        hidden.push(hideIndex);
        localStorage.setItem('hide-these', JSON.stringify(hidden));
    }
     else {
        console.error(\`Element with ID bookmark-\${index} not found.\`);
    }  
      }
      
document.addEventListener('DOMContentLoaded', () => {
    hideDeleted();
    detectTheme();
    checkConnection();
    
    const ytlightboxContainer = document.getElementById("youtube-lightbox");
    const playerContainer = document.getElementById("player");
    let inactivityTimer;

    function resetInactivityTimer() {
        clearTimeout(inactivityTimer);
        inactivityTimer = setTimeout(hideCloseButton, 3000); // Hide after 3 seconds of inactivity
    }

    function hideCloseButton() {
        const closeBtn = document.getElementById("close-yt");
        if (closeBtn) {
            closeBtn.classList.add('hidden');
        }
    }

    function showCloseButton() {
        const closeBtn = document.getElementById("close-yt");
        if (closeBtn) {
            closeBtn.classList.remove('hidden');
            resetInactivityTimer();
        }
    }

    // Event listeners based on user interaction
    if (ytlightboxContainer) {
        // For desktop and tablets
        ytlightboxContainer.addEventListener('mousemove', showCloseButton);
        // For mobile devices
        ytlightboxContainer.addEventListener('touchstart', showCloseButton);
    } else {
        console.error("YouTube lightbox container not found");
    }

    // Optional: Click event listener for close button
    const closeBtn = document.getElementById("close-yt");
    if (closeBtn) {
        closeBtn.addEventListener('click', () => {
            ytlightboxContainer.classList.remove("active");
            ytlightboxContainer.style.display = 'none'; // Optional: Hide the lightbox
            playerContainer.innerHTML = ''; // Clear the iframe
            location.reload(true);
        });
    } else {
        console.error("Close button not found");
    }
});



document.addEventListener('DOMContentLoaded', () => {
    const closeBtn = document.getElementById("close-btn");

    function closeMainLightbox() {
    location.reload();
    // TODO dont reload page, find a way to clear srcdoc 
    // const lightboxContainer = document.getElementById("lightbox");
    // document.getElementById("lightbox-iframe").src = "";
    // lightboxContainer.style.display = 'none';
    }

    if (closeBtn) {
        closeBtn.addEventListener('click', closeMainLightbox);
    } else {
        console.error("Close button not found");
    }
});


        function showPDFLightbox(pdfUrl, title) {
            const adobeDCView = new AdobeDC.View({
                clientId: "3676715924ab4f4792090061fa24153d",
                divId: "adobe-dc-view",
            });

            const pdfContainer = document.getElementById("adobe-dc-view");
            pdfContainer.style.position = "fixed";
            pdfContainer.style.top = "0";
            pdfContainer.style.left = "0";
            pdfContainer.style.width = "100%";
            pdfContainer.style.height = "100%";
            pdfContainer.style.backgroundColor = "rgba(0, 0, 0, 0)";
            pdfContainer.style.zIndex = "9999";
            pdfContainer.style.display = "flex";
            pdfContainer.style.justifyContent = "center";
            pdfContainer.style.alignItems = "center";

            adobeDCView.previewFile({
                content: {
                    location: {
                        url: pdfUrl,
                    },
                },
                metaData: {
                    fileName: title,
                },
            }, {
                embedMode: "LIGHT_BOX",
                defaultViewMode: "FIT_WIDTH",
            });

            pdfContainer.addEventListener("click", (event) => {
                if (event.target === pdfContainer) {
                    pdfContainer.style.display = "none";
                }
            });
        }

function getLinkFromValue(onclickString) {
    // Regular expression to match the pattern of the onclick attribute
    const regex = /openMarko\\(([^,]+),\\s*'([^']*)'(?:,\\s*'([^']*)')?\\)/;

    // Execute the regex on the onclick string
    const match = onclickString.match(regex);

    // If there's a match, extract the arguments
    if (match) {
        const functionName = match[1].trim();
        const firstArgument = match[2].trim();
        const secondArgument = match[3] ? match[3].trim() : null;

        // Return the arguments as an object without quotes
        return firstArgument.replace(/^'|'$/g, "");
    }

    // If no match, return null
    return null;
}


// this is actually a shareLink function, kept the name for convenience

function deleteLink(index) {
    shareMarko(index);
}


function shareMarko(index) {
    const bookmark = document.querySelector(\`.bookmark[data-index="\${index}"]\`);
    console.log('Selected Marko to share: ', bookmark);
    if (!bookmark) {
        console.log(\`No bookmark found with index \${index}\`);
        return null;
    }

    const bookmarkWrapper = bookmark.querySelector('.bookmark-wrapper');
    const iconContainer = bookmarkWrapper.querySelector('.icon-container');
    const bookmarkTitle = bookmarkWrapper.querySelector('.bookmark-title');
    const bookmarkIcon = iconContainer.querySelector('img');

    // Extract the required values
    const onclickValue = bookmarkWrapper.getAttribute('onclick');
    const actionMatch = getLinkFromValue(onclickValue);
    console.log('actionMatch');
    //const actionLink = actionMatch ? actionMatch[1].replace(/'/g, '') : ''; // Extracted and stripped of single quotes
    const type = bookmarkWrapper.getAttribute('data-type') || '';
    const title = bookmarkTitle ? bookmarkTitle.textContent.trim() : '';
    const icon = bookmarkIcon ? bookmarkIcon.getAttribute('src') : '';
    const color = iconContainer ? getComputedStyle(iconContainer).getPropertyValue('--ring-color').trim() : '';

    // Construct the URL for the shareable link
    const url = new URL('https://marko-app.netlify.app');
    url.searchParams.append('type', type);
    url.searchParams.append('link', actionMatch);
    url.searchParams.append('title', title);
    url.searchParams.append('icon', icon);
    url.searchParams.append('color', color);
    url.searchParams.append('createMarko', 'true');

    const navLink = url.toString();

    window.location.href = navLink;
        
    return navLink;
}

    <\/script>
</body>
</html>`;

        // create the html document and auto download it. This creates a document with an exact copy of all visible user-made bookmarks.
        // Replace >delete< with >share<
        currentState = currentState.replace(/>delete</g, '>add_circle<');
        const oldTitle = 'id="main-title" class="bookmark-title">Marko<';
        const newTitle = `id="main-title" class="bookmark-title">${title}<`;
        currentState = currentState.replace(oldTitle, newTitle);
        const blob = new Blob([currentState], { type: 'text/html' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${title}.html`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        const url = URL.createObjectURL(blob);
        window.open(url);
        // also create a shareable link that, when loaded, can add the friend with his links
        if (confirm('Do you also want to create a shareable direct link?')) {
          createShareableLink(title);
        }
    }
  
  async function createShareableLink(title) {
              const loggedIn = sessionStorage.getItem('loggedIn');
          // make sure the user is logged in before they can create a shareable link.
          if (loggedIn !== "true") {
            alert("log in to create a shareable link");
            return;
        }
    let bookmarks = JSON.parse(localStorage.getItem('bookmarks')) || [];
    
    // Exclude bookmarks of friends
    bookmarks = bookmarks.filter(bookmark => bookmark[0] !== "friend");
    
    // Remove the sixth item if it exists
    const arrayOfArrays = bookmarks.map(item => item.slice(0, 5));
    
    // Convert the array to a JSON string
    const finalData = JSON.stringify(arrayOfArrays, null, 2).replace(/\\/g, "");
    
    try {
        // Validate JSON input
        const array = JSON.parse(finalData);
        if (!Array.isArray(array)) {
            throw new Error('Input is not a valid JSON array.');
        }

        // Compress and encode the JSON string
        const jsonString = JSON.stringify(array);
        const compressed = LZString.compressToEncodedURIComponent(jsonString);
        const url = `${window.location.origin}${window.location.pathname}?title=${title}&data=${compressed}&globalMarko=true`;

        // Load array from URL (assume this is a function you have)
        loadArrayFromURL();

        // Copy to clipboard
        try {
            window.focus();
            await navigator.clipboard.writeText(url);
            //alert('Link copied to clipboard!');
        } catch (clipboardError) {
            console.error('Error copying to clipboard:', clipboardError);
            alert('Failed to copy link to clipboard. You can manually copy the link.');
        }

        // Check if Web Share API is supported
        if (navigator.share) {
            try {
                await navigator.share({
                    title: `${title}`,
                    text: 'This is my Marko superlink!',
                    url: url,
                });
            } catch (shareError) {
                console.error('Error sharing:', shareError);
            }
        } else {
            alert('Share link has been copied to clipboard.');
        }
    } catch (error) {
        alert(`Invalid JSON array. Please enter a valid array. Error: ${error.message}`);
    }
}






</script>

        <script>
        function showPDFLightbox(pdfUrl, title) {
            const adobeDCView = new AdobeDC.View({
                clientId: "3676715924ab4f4792090061fa24153d",
                divId: "adobe-dc-view",
            });

            const pdfContainer = document.getElementById("adobe-dc-view");
            pdfContainer.style.position = "fixed";
            pdfContainer.style.top = "0";
            pdfContainer.style.left = "0";
            pdfContainer.style.width = "100%";
            pdfContainer.style.height = "100%";
            pdfContainer.style.backgroundColor = "rgba(0, 0, 0, 0)";
            pdfContainer.style.zIndex = "9999";
            pdfContainer.style.display = "flex";
            pdfContainer.style.justifyContent = "center";
            pdfContainer.style.alignItems = "center";

            adobeDCView.previewFile({
                content: {
                    location: {
                        url: pdfUrl,
                    },
                },
                metaData: {
                    fileName: title,
                },
            }, {
                embedMode: "LIGHT_BOX",
                defaultViewMode: "FIT_WIDTH",
            });

            pdfContainer.addEventListener("click", (event) => {
                if (event.target === pdfContainer) {
                    pdfContainer.style.display = "none";
                }
            });
        }
    </script>
<script>
const CLIENT_ID = '371617464258-ntrqn44lfo1lpi294hmc5ebad5b9ok5a.apps.googleusercontent.com';
const API_KEY = 'AIzaSyAbf0IPLaP6Cbbx3NnFlfzcWQ-zxIc5S8E';
const SCOPES = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.email';
const FILE_NAME = 'bookmarksMarko.txt';
const PUBLIC_FILE = 'myMarkos.json';  
const COMMON_FILE = "commonMarko";  
const APP_ID = 'marko';

let tokenClient;
let loggedInUserEmail;

        
  
async function initializeGoogleIdentity() {
    tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        callback: (tokenResponse) => {
            if (tokenResponse && tokenResponse.access_token) {
                localStorage.setItem('accessToken', tokenResponse.access_token);
                console.log('Authorization successful.');
            }
        },
    });
}

function authorize() {
    return new Promise((resolve, reject) => {
        const storedEmail = localStorage.getItem('userEmail');

        if (tokenClient) {
            tokenClient.callback = (resp) => {
                if (resp.error !== undefined) {
                    reject(new Error(`Authorization error: ${resp.error}`));
                } else {
                    console.log('Authorization successful, getting user email');
                    localStorage.setItem('accessToken', resp.access_token);
                    getUserEmailAndStore()
                        .then((email) => {
                            console.log('User email retrieved:', email);
                            resolve({ email: email, ...resp });
                        })
                        .catch(error => {
                            console.error('Failed to get user email:', error);
                            reject(error);
                        });
                }
            };
            tokenClient.requestAccessToken({prompt: 'consent'});
        } else {
            reject(new Error('Token client not initialized'));
        }
    });
}

async function refreshToken() {
    return new Promise((resolve, reject) => {
        if (tokenClient) {
            tokenClient.callback = (resp) => {
                if (resp.error !== undefined) {
                    reject(new Error(`Token refresh error: ${resp.error}`));
                } else {
                    console.log('New token received:', resp.access_token);
                    localStorage.setItem('accessToken', resp.access_token);
                    resolve(resp.access_token);
                }
            };
            tokenClient.requestAccessToken({prompt: ''});
        } else {
            reject(new Error('Token client not initialized'));
        }
    });
}

async function ensureValidToken() {
  accessToken = localStorage.getItem('accessToken');
  console.log('Retrieved access token:', accessToken);

    try {
      const newAccessToken = await refreshToken();
      return newAccessToken;
    } catch (error) {
      throw error; // Re-throw the error from refreshToken
    }
}


function retryOperation(operation, maxRetries = 3, delay = 1000) {
    return new Promise((resolve, reject) => {
        let attempts = 0;
        const attempt = () => {
            attempts++;
            operation()
                .then(resolve)
                .catch(error => {
                    if (attempts < maxRetries) {
                        console.log(`Attempt ${attempts} failed. Retrying in ${delay}ms...`);
                        setTimeout(attempt, delay);
                    } else {
                        reject(error);
                    }
                });
        };
        attempt();
    });
}

function findExistingFile(accessToken) {
    return fetch(`https://www.googleapis.com/drive/v3/files?q=name='${FILE_NAME}' and properties has { key='appId' and value='${APP_ID}' }`, {
        method: 'GET',
        headers: new Headers({ 'Authorization': 'Bearer ' + accessToken })
    })
    .then(response => {
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return response.json();
    })
    .then(data => {
        console.log('Google Drive API response:', data);
    if (!data || !data.files) {
        throw new Error('Invalid response from Google Drive API');
    }
    return data;
    });
}

function getFromGoogleDrive() {
    if (!navigator.onLine) {
        alert("Connect to the Internet to proceed");
        return;
    }

    const syncFromButton = document.getElementById('syncFromDrive');
    const syncFromIcon = document.getElementById('syncFromIcon');
    syncFromButton.disabled = true;
    syncFromIcon.classList.add('spinning');
  
        const userLoggedOut = localStorage.getItem('explicitLogout');
        if (userLoggedOut === 'true') {
          if (confirm('You have to login to use this feature. Login now?')) {
                localStorage.removeItem('explicitLogout');
                window.location.href = `${LOGIN_PAGE_URL}?redirect=index.html?then=getFromGoogleDrive`;
          } else {
            return;
          }
        }
  
    if (!confirm("Are you sure you want to sync your bookmarks from Google Drive? This will overwrite any existing local Marko bookmarks.")) {
        stopSpinning(syncFromButton, syncFromIcon);
        return;
    }

    const accessToken = localStorage.getItem('accessToken');
    console.log('Using access token:', accessToken);

    if (!accessToken) {
        alert('No valid access token available');
        stopSpinning(syncFromButton, syncFromIcon);
        return;
    }

    retryOperation(() => findExistingFile(accessToken))
        .then(data => {
            if (data.files && data.files.length > 0) {
                return fetch(`https://www.googleapis.com/drive/v3/files/${data.files[0].id}?alt=media`, {
                    method: 'GET',
                    headers: new Headers({ 'Authorization': 'Bearer ' + accessToken })
                });
            } else {
                throw new Error('No bookmarks file found in Google Drive');
            }
        })
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            localStorage.setItem('bookmarks', JSON.stringify(data));
            bookmarks = data;
            stopSpinning(syncFromButton, syncFromIcon);
            location.reload();
            alert("Your Markos are now in sync. Enjoy!");
        })
        .catch(error => {
            console.error('Full error object:', error);
            let errorMessage = 'Error retrieving file: ' + error.message;
            alert(errorMessage);
            stopSpinning(syncFromButton, syncFromIcon);
        });
}

function deleteExistingFile(accessToken) {
    return findExistingFile(accessToken)
        .then(data => {
            if (data.files && data.files.length > 0) {
                return fetch(`https://www.googleapis.com/drive/v3/files/${data.files[0].id}`, {
                    method: 'DELETE',
                    headers: new Headers({ 'Authorization': 'Bearer ' + accessToken })
                });
            }
        });
}

function createNewFile(accessToken, content) {
    const metadata = {
        'name': FILE_NAME,
        'mimeType': 'application/json',
        'properties': {
            'appId': APP_ID
        }
    };
    const form = new FormData();
    form.append('metadata', new Blob([JSON.stringify(metadata)], {type: 'application/json'}));
    form.append('file', new Blob([content], {type: 'application/json'}));

    return fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
        method: 'POST',
        headers: new Headers({ 'Authorization': 'Bearer ' + accessToken }),
        body: form
    });
}

function saveToGoogleDrive() {
    if (!navigator.onLine) {
        alert("Connect to the Internet to proceed");
        return;
    }
        const userLoggedOut = localStorage.getItem('explicitLogout');
        if (userLoggedOut === 'true') {
          if (confirm('You have to login to use this feature. Login now?')) {
                localStorage.removeItem('explicitLogout');
                window.location.href = `${LOGIN_PAGE_URL}?redirect=index.html?then=saveToGoogleDrive`;
          } else {
            return;
          }
        }
  
    const syncToButton = document.getElementById('syncToDrive');
    const syncToIcon = document.getElementById('syncToIcon');
    syncToButton.disabled = true;
    syncToIcon.classList.add('spinning');

    if (!confirm("Are you sure you want to save your bookmarks to Google Drive?")) {
        stopSpinning(syncToButton, syncToIcon);
        return;
    }

    const accessToken = localStorage.getItem('accessToken');
    console.log('Using access token:', accessToken);

    if (!accessToken) {
        alert('No valid access token available');
        stopSpinning(syncToButton, syncToIcon);
        return;
    }

    retryOperation(() => deleteExistingFile(accessToken))
        .then(() => retryOperation(() => {
            const bookmarksJson = localStorage.getItem('bookmarks');
            return createNewFile(accessToken, bookmarksJson);
        }))
        .then(response => {
            if (!response.ok) throw new Error('Failed to create file');
            return response.json();
        })
        .then(() => {
            alert('Bookmarks saved to Google Drive as ' + FILE_NAME);
            stopSpinning(syncToButton, syncToIcon);
            openDonate();
        })
        .catch(error => {
            console.error('Error in saveToGoogleDrive:', error);
            stopSpinning(syncToButton, syncToIcon);
        });
}

  
function saveToGoogleDrivePublic() {
    if (!navigator.onLine) {
        alert("Connect to the Internet to proceed");
        return;
    }
        const userLoggedOut = localStorage.getItem('explicitLogout');
        if (userLoggedOut === 'true') {
          if (confirm('You have to login to use this feature. Login now?')) {
                localStorage.removeItem('explicitLogout');
                window.location.href = LOGIN_PAGE_URL;
          } else {
            return;
          }
        }
  
    const syncToPublicButton = document.getElementById('syncToPublicDrive');
    const syncToPublicIcon = document.getElementById('syncToPublicIcon');
    syncToPublicButton.disabled = true;
    syncToPublicIcon.classList.add('spinning');

    if (!confirm("Are you sure you want to save your bookmarks to Google Drive as a public file?")) {
        stopSpinning(syncToPublicButton, syncToPublicIcon);
        return;
    }

    const accessToken = localStorage.getItem('accessToken');
    console.log('Using access token:', accessToken);

    if (!accessToken) {
        alert('No valid access token available');
        stopSpinning(syncToPublicButton, syncToPublicIcon);
        return;
    }

    findExistingPublicFile(accessToken, PUBLIC_FILE)
        .then(fileData => {
            const bookmarksJson = localStorage.getItem('bookmarks');
            if (fileData) {
                return updateExistingFile(accessToken, fileData.id, bookmarksJson);
            } else {
                return createNewPublicFile(accessToken, bookmarksJson, PUBLIC_FILE);
            }
        })
        .then(fileData => {
            if (!fileData || !fileData.id) {
                throw new Error('Failed to save file: No file data returned');
            }
            const shareableLink = `https://drive.google.com/file/d/${fileData.id}/view?usp=sharing`;
            copyToClipboard(shareableLink);
            alert('Bookmarks saved to Google Drive as ' + PUBLIC_FILE + '\nShareable link copied to clipboard.');
            stopSpinning(syncToPublicButton, syncToPublicIcon);
            openDonate();
        })
        .catch(error => {
            console.error('Error in saveToGoogleDrivePublic:', error);
            stopSpinning(syncToPublicButton, syncToPublicIcon);
        });
}

function findExistingPublicFile(accessToken, fileName) {
    return fetch(`https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(fileName)}'&spaces=drive&fields=files(id)`, {
        method: 'GET',
        headers: {
            'Authorization': 'Bearer ' + accessToken
        }
    })
    .then(response => {
        if (!response.ok) throw new Error(`Failed to search for file: ${response.status} ${response.statusText}`);
        return response.json();
    })
    .then(data => {
        return data.files.length ? data.files[0] : null;
    });
}

function updateExistingFile(accessToken, fileId, content) {
    return fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`, {
        method: 'PATCH',
        headers: {
            'Authorization': 'Bearer ' + accessToken,
            'Content-Type': 'application/json'  // Correct content type for JSON
        },
        body: content  // Directly send the JSON content
    })
    .then(response => {
        if (!response.ok) throw new Error(`Failed to update file: ${response.status} ${response.statusText}`);
        return response.json();
    });
}

function createNewPublicFile(accessToken, content, fileName) {
    const metadata = {
        name: fileName,
        mimeType: 'application/json'
    };

    return fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
        method: 'POST',
        headers: {
            'Authorization': 'Bearer ' + accessToken
        },
        body: content
    })
    .then(response => {
        if (!response.ok) throw new Error(`Failed to create file: ${response.status} ${response.statusText}`);
        return response.json();
    })
    .then(fileData => {
        return setFilePublic(accessToken, fileData.id)
            .then(() => fileData);
    });
}

function setFilePublic(accessToken, fileId) {
    const permission = {
        type: 'anyone',
        role: 'reader'
    };

    return fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/permissions`, {
        method: 'POST',
        headers: {
            'Authorization': 'Bearer ' + accessToken,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(permission)
    })
    .then(response => {
        if (!response.ok) throw new Error(`Failed to set file public: ${response.status} ${response.statusText}`);
        return response;
    });
}

async function createUpdateCommonMarko() {
    if (!navigator.onLine) {
        alert("Connect to the Internet to proceed");
        return;
    }
    const syncButton = document.getElementById('syncToPublicWritableDrive');
    const syncIcon = document.getElementById('syncToPublicWritableIcon');
    
        const userLoggedOut = localStorage.getItem('explicitLogout');
        if (userLoggedOut === 'true') {
          if (confirm('You have to login to use this feature. Login now?')) {
                localStorage.removeItem('explicitLogout');
                window.location.href = LOGIN_PAGE_URL;
          } else {
            return;
          }
        }
  
    syncButton.disabled = true;
    syncIcon.classList.add('spinning');
    // Prompt user to input name of Marko
    let userInput = prompt("Do you want to save your Markos to Google Drive as a publicly accessible file? If yes, enter a filename:");

    // Handle user input
    let isUpdate = 'no'; // Default value for isUpdate
    let fileName = 'commonMarko'; // Default value for fileName
    let extendedFileName = 'commonMarko.json'; // Default value for fileName

    if (userInput === null) {
        console.log("User canceled the prompt. Continuing to update..");
        isUpdate = 'yes'; // Change isUpdate to 'yes' if user cancels
        sessionStorage.setItem('isUpdate', isUpdate); // Store fileName in sessionStorage
        // TODO: Add here selection of current common markos to update 
    } else {
        let sanitizedInput = userInput.replace(/[^\w-]/g, '');
        fileName = sanitizedInput;
        console.log("Updated fileName:", fileName);
        sessionStorage.setItem('commonFileName', fileName); // Store fileName in sessionStorage
        isUpdate = 'no'; // Change isUpdate to 'yes' if user cancels
        sessionStorage.setItem('isUpdate', isUpdate); // Store fileName in sessionStorage
    }

    // Retrieve isUpdate and commonFileName values from sessionStorage or use default
    isUpdate = sessionStorage.getItem('isUpdate') || isUpdate;
    fileName = sessionStorage.getItem('commonFileName') || fileName;

  
    try {
        accessToken = localStorage.getItem('accessToken');
        console.log('Using access token:', accessToken);
        const fileData = await findExistingPublicWritableFile(accessToken, fileName);
        const fileContent = await prepareFileContent();
        let result;
        if (fileData && isUpdate === 'yes') {
            result = await updateExistingWritableFile(accessToken, fileData.id, fileContent);
        } else {
            const randomU = generateUUID();
            const commonPFileName = `${fileName}-${randomU}.json` || `${COMMON_FILE}-${randomU}.json`;
            sessionStorage.setItem('extendedFileName', commonPFileName); // Store extended fileName in sessionStorage
            result = await createNewPublicWritableFile(accessToken, fileContent, commonPFileName, fileName);
        }

        if (!result || !result.id) {
            throw new Error('Failed to save file: No file data returned');
        }
        
        // Store friend-uuid and fileId in localStorage
        const content = JSON.parse(fileContent);
        localStorage.setItem(result.id, JSON.stringify(content));

        extendedFileName = sessionStorage.getItem('extendedFileName') || extendedFileName;
        //const linkUrl = `${window.location.origin}${window.location.pathname}?common-marko=${fileId}&common-name=${fileName}&commonMarko=true`;
        copyToClipboard(result.id, fileName);
        //alert(`Data saved to Google Drive as ${extendedFileName}\nShareable link copied to clipboard.`);
        //copyToClipboard(result.id, fileName);
    } catch (error) {
        console.error('Error in createUpdateCommonMarko:', error);
        //alert('An error occurred: ' + error.message);
    } finally {
        stopSpinning(syncButton, syncIcon);
    }
}

async function updateMarko(fileId) {
    if (!navigator.onLine) {
        alert("Connect to the Internet to proceed");
        return;
    }
  
        console.log("Adding to fileId:", fileId);

    try {
        accessToken = localStorage.getItem('accessToken');
        console.log('Using access token:', accessToken);
        const fileContent = await prepareFileContent(fileId);
        let result;
        if (fileId) {
            result = await updateExistingWritableFile(accessToken, fileId, fileContent);
        } else {
            console.log("something went wrong..");
        }
        if (!fileId) {
          throw new Error("No fileId provided");
        }
        if (!result || !result.id) {
          throw new Error('Failed to save file: No file data returned');
        } else {
          alert('Success!');
          location.reload();      
        }
    } catch (error) {
        console.error('Error in updateMarko:', error);
        //alert('An error occurred: ' + error.message);
    } finally {
        console.log("leaving updateMarko..");
    }
}
  
async function writeToPublicWritableFile(fileId = '1UvMaQ5qr7DSJV9ovFmaZQkV751_XnjUE') {
    if (!navigator.onLine) {
        alert("Connect to the Internet to proceed");
        return;
    }
    const userLoggedOut = localStorage.getItem('explicitLogout');
        if (userLoggedOut === 'true') {
          if (confirm('You have to login to use this feature. Login now?')) {
                localStorage.removeItem('explicitLogout');
                window.location.href = LOGIN_PAGE_URL;
          } else {
            return;
          }
        }
    
    const syncButton = document.getElementById('syncToPublicWritableDrive');
    const syncIcon = document.getElementById('syncToPublicWritableIcon');
    syncButton.disabled = true;
    syncIcon.classList.add('spinning');

    if (!confirm("Are you sure you want to update the file on Google Drive?")) {
        stopSpinning(syncButton, syncIcon);
        return;
    }

    try {
        // Get the access token
        //initializeGoogleIdentity();
        //const accessToken = localStorage.getItem('accessToken');
        //console.log("blum: " + accessToken);
        accessToken = localStorage.getItem('accessToken');
        console.log('Using access token:', accessToken);
        // Prepare the file content
        const fileContent = await prepareFileContent();

const url = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`;

        const response = await fetch(url, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            },
            body: fileContent
        });

        if (!response.ok) {
    const errorText = await response.text();
    console.error('Full error response:', errorText);
    throw new Error(`File update failed. HTTP status: ${response.status} ${response.statusText}`);
}

        const result = await response.json();

        if (!result || !result.id) {
            throw new Error('Failed to update file: No file data returned');
        }

        // Store uuid and fileId in localStorage if needed
        // localStorage.setItem(uuid, result.id);
        copyToClipboard(result.id);
        alert('File updated on Google Drive successfully.');
    } catch (error) {
        console.error('Error in writeToPublicWritableFile:', error);
        //alert('An error occurred: ' + error.message);
    } finally {
        stopSpinning(syncButton, syncIcon);
    }
}

async function prepareFileContent(array = 'bookmarks') {
    const contentJson = localStorage.getItem('bookmarks'); 
    const content = JSON.parse(contentJson);
    return JSON.stringify(content);
}

async function findExistingPublicWritableFile(accessToken, fileName) {
    const response = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(fileName)}'&spaces=drive&fields=files(id)`, {
        method: 'GET',
        headers: {
            'Authorization': 'Bearer ' + accessToken
        }
    });

    if (!response.ok) {
        throw new Error(`Failed to search for file: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return data.files.length ? data.files[0] : null;
}

async function updateExistingWritableFile(accessToken, fileId, content) {
    try {
        const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`, {
            method: 'PATCH',
            headers: {
                'Authorization': 'Bearer ' + accessToken,
                'Content-Type': 'application/json'
            },
            body: content
        });

        if (!response.ok) {
            throw new Error(`Failed to update file: ${response.status} ${response.statusText}`);
        }

        return await response.json();
    } finally {
      console.log("update, OK");
    }
}

async function createNewPublicWritableFile(accessToken, fileContent, fileName, userFacingName) {
    const metadata = {
        name: fileName,
        mimeType: 'application/json'
    };

    // Step 1: Create the file with metadata
    const createUrl = 'https://www.googleapis.com/drive/v3/files';

    try {
        const createResponse = await fetch(createUrl, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(metadata)
        });

        if (!createResponse.ok) {
            const errorText = await createResponse.text();
            console.error('Full error response:', errorText);
            throw new Error(`File creation failed. HTTP status: ${createResponse.status} ${createResponse.statusText}`);
        }

        const createResult = await createResponse.json();
        const fileId = createResult.id;
      
        // Step 2: Upload the file content
        const uploadUrl = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`;

        const uploadResponse = await fetch(uploadUrl, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${accessToken}`,
                'Content-Type': 'application/json'
            },
            body: fileContent
        });

        if (!uploadResponse.ok) {
            const errorText = await uploadResponse.text();
            console.error('Full error response:', errorText);
            throw new Error(`File upload failed. HTTP status: ${uploadResponse.status} ${uploadResponse.statusText}`);
        }

        const uploadResult = await uploadResponse.json();
        console.log('File created and content uploaded:', uploadResult);

        // Set permissions to make the file publicly writable

    // currently not implemented - share file with particular user 
    // await setFileUserWritable(accessToken, fileId);
    await setFilePublic(accessToken, fileId);
    //const linkUrl = `${window.location.origin}${window.location.pathname}?common-marko=${fileId}&common-name=${userFacingName}&commonMarko=true`;
      
    // create a Marko for the newly created file
    createMarko('contact', `${fileId}`, `${userFacingName}`, '', '');
    // add to myCommons in localStorage to updateUI accordingly
    myCommonMarkos.push(fileId);
    localStorage.setItem('myCommons', JSON.stringify(myCommonMarkos));

    // add reference to localStorage so that I don't add multiple Markos for same file
    allCommonMarkos.push(fileId);
    // Store updated allCommonMarkos array back into localStorage
    localStorage.setItem('commonMarkos', JSON.stringify(allCommonMarkos));
    // store new common bookmarks array  
    localStorage.setItem(fileId, JSON.stringify(fileContent));
    sessionStorage.setItem('alertStatus', 'off');
    return uploadResult;
    } catch (error) {
        console.error('Error in createNewPublicWritableFile:', error);
        throw new Error('An error occurred while creating and uploading the file: ' + error.message);
    } 
}

async function setFileUserWritable(accessToken, fileId) {
    const permission = {
        type: 'user',
        role: 'writer',
        emailAddress: 'telelocus@gmail.com'
    };

    const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/permissions`, {
        method: 'POST',
        headers: {
            'Authorization': 'Bearer ' + accessToken,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(permission)
    });

    if (!response.ok) {
        throw new Error(`Failed to set file public writable: ${response.status} ${response.statusText}`);
    }

    return response;
}

async function lockFile(fileId) {
    accessToken = localStorage.getItem('accessToken');
    if (!accessToken) {
        throw new Error('No access token available');
    }

    const permission = {
        type: 'anyone',
        role: 'reader'
    };

    const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/permissions`, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(permission)
    });

    if (!response.ok) {
        throw new Error(`Failed to set file read-only: ${response.status} ${response.statusText}`);
    }

    return await response.json();
}

async function unlockFile(fileId) {
    accessToken = localStorage.getItem('accessToken');
    if (!accessToken) {
        throw new Error('No access token available');
    }

    const permission = {
        type: 'anyone',
        role: 'writer'
    };

    const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/permissions`, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(permission)
    });

    if (!response.ok) {
        throw new Error(`Failed to set file writable: ${response.status} ${response.statusText}`);
    }

    return await response.json();
}

function copyToClipboard(fileId, name) {
    const url = `${window.location.origin}${window.location.pathname}?common-marko=${fileId}&common-name=${name}&commonMarko=true`;

    // Check if Web Share API is supported
    if (navigator.share) {
        window.focus();
        navigator.share({
            title: `${name}`,
            text: 'This is my common Marko link!',
            url: url,
        })
        .then(() => {
            console.log('Shared successfully');
        })
        .catch((shareError) => {
            console.error('Error sharing:', shareError);
        });
    } else {
        // If Web Share API is not supported, copy to clipboard
        window.focus();
        navigator.clipboard.writeText(url)
        .then(() => {
            console.log('Shareable link copied to clipboard');
            //alert('Share link has been copied to clipboard.');
        })
        .catch((err) => {
            console.error('Failed to copy: ', err);
            //alert('There was an error. Please try again.');
        });
    }
}



function getUserEmailAndStore() {
    const userLoggedOut = localStorage.getItem('explicitLogout');
        if (userLoggedOut === 'true') {
            return;
          }
        
    return new Promise((resolve, reject) => {
        const storedEmail = localStorage.getItem('userEmail');
        if (storedEmail) {
            console.log('Using stored email:', storedEmail);
            resolve(storedEmail);
            return;
        }
      
        console.log('No stored email, fetching from Google');
        const accessToken = localStorage.getItem('accessToken');
        console.log('Using access token:', accessToken);

        if (!accessToken) {
            reject(new Error('No valid access token available'));
            return;
        }

        fetch('https://www.googleapis.com/oauth2/v1/userinfo?alt=json', {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        })
            .then(res => {
                console.log('User info response status:', res.status);
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                return res.json();
            })
            .then(data => {
                console.log('User info data:', data);
                if (!data.email) {
                    throw new Error('Email not found in user info');
                }
                localStorage.setItem('userEmail', data.email);
                console.log('Logged in user email:', data.email);
                resolve(data.email);
            })
            .catch(error => {
                console.error('Error in getUserEmailAndStore:', error);
                reject(error);
            });
    });
}

  
function stopSpinning(button, icon) {
    button.disabled = false;
    icon.classList.remove('spinning');
}
    
function loadDonationParams() {
    const queryString = window.location.search;
    console.log(queryString);
    const urlParams = new URLSearchParams(queryString);
    const donation = urlParams.get('donate');
    
    if (donation !== null) {
        switch(donation.toLowerCase()) {
            case 'true':
                localStorage.setItem("donated", "true");
                console.log("Thank you for your donation!");
                break;
            case 'false':
                console.log("Keep Marko app going with your donations...");
                alert("Keep Marko app going with your donations...");
                break;
            default:
                console.log("Invalid donation parameter");
        }
    }
}
    
function openDonate() {
    const firstRun = localStorage.getItem("firstRun");
    console.log("isFirstRun: " + firstRun);
    const hasDonated = localStorage.getItem("donated");
    console.log("hasDonated: " + hasDonated);
    if (firstRun === "false" && hasDonated !== "true") {
            const url = 'https://www.sandbox.paypal.com/donate/?hosted_button_id=9U3RDMXSDKD6N';
            window.location.href = url;    
    } else {
        localStorage.setItem("firstRun", "false");
        }
    }    
    
// test function TODO >> remove
function hasPaid() {
        const url = 'https://marko-app.netlify.app?donate=true';
        window.location.href = url;
}
window.loggedInUserEmail = loggedInUserEmail; // Expose the email globally for other parts of the app to reuse  

  
 
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const loggedIn = sessionStorage.getItem('loggedIn');
  if (loggedIn !== 'true') {
      return;
  }
  document.addEventListener('keydown', function(event) {
      if (event.ctrlKey && event.key === 's') {
        event.preventDefault(); // Prevent the default browser action (e.g., saving the page)
        
        // Perform the desired action
        console.log('Ctrl + S was pressed');
        toggleSearchContainer();
    }
    if (event.ctrlKey && event.key === 'c') {
        event.preventDefault(); // Prevent the default browser action (e.g., saving the page)
        
        // Perform the desired action
        console.log('Ctrl + C was pressed');
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          window.location.href = 'https://marko-app.netlify.app/createmarko?fromApp&darkMode';
        } else {
          window.location.href = 'https://marko-app.netlify.app/createmarko?fromApp';
    }   
    }  
  });
    const searchContainer = document.querySelector('.search-container');
    const overlay = document.getElementById('overlay');
    const searchToggle = document.getElementById('main-bookmark');
        // Add event listeners to main-bookmark icons

    // Show the search container with animation
    function showSearchContainer() {
        searchContainer.classList.add('show');
        searchContainer.classList.remove('hide');
        overlay.style.display = 'block';
    }

    // Hide the search container with animation
    function hideSearchContainer() {
        searchContainer.classList.add('hide');
        searchContainer.classList.remove('show');
        overlay.style.display = 'none';
    }

    function toggleSearchContainer() {
        if (searchContainer.classList.contains('show')) {
            hideSearchContainer();
        } else {
            showSearchContainer();
        }
    }

    // Event listeners
    // Close search container when clicking outside of it
    searchToggle.addEventListener('click', showSearchContainer);
    overlay.addEventListener('click', hideSearchContainer);
});

  
document.addEventListener('DOMContentLoaded', () => {
    // Define constants
    const SEARCH_API_KEY = 'AIzaSyBc75KlBm10rP8vB0u3yDsM4vdMqSNfdzo'; // Replace with your API key
    const CX = ''; // Replace with your Custom Search Engine ID

    // Define elements
    const searchInput = document.getElementById('searchBoxInput');
    const searchButton = document.getElementById('searchButton');
    const clearButton = document.getElementById('clearButton');
    const engineSelectButton = document.getElementById('engineSelectButton');
    const engineDropdown = document.getElementById('engineDropdown');
    const buttonIcon = document.getElementById('buttonIcon');
    const dropdown = document.getElementById('dropdown');
    const markoButton = document.getElementById('markoButton');

    // Initialize variables
    let firstUrlInDropdown = '';
    let selectedEngine = localStorage.getItem('selectedEngine') || 'google';
    
    // Define engine names
    const engineNames = {
        'google': 'Google',
        'duckduckgo': 'DDG',
        'bing': 'Bing',
        'yahoo': 'Yahoo',
        'yandex': 'Yandex',
        'baidu': 'Baidu',
        'naver': 'Naver',
        'youtube': 'YouTube',
        'wikipedia': 'Wiki',
        'maps': 'Maps',
        'searx': 'searX',
        'local': 'Local'
    };

    // Initial setup
    updateEngineDropdown();
    updatePlaceholder();
    toggleClearButton();
    startRotatingPlaceholder();

    // Event Listeners
    searchInput.addEventListener('input', handleInput);
    searchInput.addEventListener('keydown', handleEnterKey);
    searchButton.addEventListener('click', handleSearchButtonClick);
    clearButton.addEventListener('click', clearSearch);
    engineSelectButton.addEventListener('click', toggleEngineDropdown);
    engineDropdown.addEventListener('click', handleEngineSelect);
    markoButton.addEventListener('click', handleMarkoButtonClick);
    document.addEventListener('click', closeDropdowns);

    // Event Handler Functions
    function handleInput() {
        const query = searchInput.value.trim();
        if (query.length > 0) {
            
            const myEngine = localStorage.getItem('selectedEngine');
            if (myEngine === 'google') {
                fetchSearchResults(query);
                buttonIcon.textContent = isValidURL(query) ? 'send' : 'search';
            } else if (myEngine === 'maps') {
                fetchMapsResults(query);
                buttonIcon.textContent = isValidURL(query) ? 'send' : 'search';
            } else if (myEngine === 'youtube') {
                fetchYouTubeResults(query);
                buttonIcon.textContent = isValidURL(query) ? 'send' : 'search';
            }
        } else {
            dropdown.style.display = 'none';
            firstUrlInDropdown = '';
            buttonIcon.textContent = 'search';
        }
        toggleClearButton();
    }

    function handleEnterKey(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            handleSearchButtonClick();
        }
    }

    function handleSearchButtonClick() {
        const query = searchInput.value.trim();
        if (isValidURL(query)) {
            let url = query;
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                url = 'https://' + url;
            }
            window.location.href = url;
        } else {
            const searchUrl = getSearchUrl(query);
            if (searchUrl) {
                window.open(searchUrl, '_blank');
            }
        }
    }

    function handleEngineSelect(event) {
        if (event.target.classList.contains('engine-option')) {
            selectEngine(event.target.dataset.engine);
            toggleEngineDropdown();
        }
    }

    function handleMarkoButtonClick() {
        const text = searchInput.value.trim();
        if (text) {
            if (isValidURL(text)) {
                createMarko('website', text, 'Marko from search', `https://www.google.com/s2/favicons?domain=${text}&sz=32`, '#0D47A1');
            } else {
                createMarko('note', text, 'Marko Note', '', '#0D47A1');
            }
        } else {
            alert('Add some text or url to create a Marko from it.');
        }
    }

    function closeDropdowns(event) {
        if (!event.target.closest('.search-container')) {
            dropdown.style.display = 'none';
            engineDropdown.style.display = 'none';
        }
    }
    
function fetchYouTubeResults(query) {
    const apiKey = 'AIzaSyBc75KlBm10rP8vB0u3yDsM4vdMqSNfdzo'; // Replace with your YouTube Data API key
    const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video,channel&maxResults=5&q=${encodeURIComponent(query)}&key=${apiKey}`;
    
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (data.items) {
                showResults(data.items.map(item => ({
                    title: item.snippet.title,
                    link: `https://www.youtube.com/${item.id.kind === 'youtube#channel' ? 'channel' : 'watch'}?v=${item.id.videoId || item.id.channelId}`,
                    source: 'youtube'
                })));
            }
        })
        .catch(error => console.error('Error fetching YouTube results:', error));
}

function fetchMapsResults(query) {
    const apiKey = 'AIzaSyBc75KlBm10rP8vB0u3yDsM4vdMqSNfdzo'; // Replace with your actual API key
    const url = 'https://places.googleapis.com/v1/places:searchText';
    const requestBody = {
        textQuery: query,
        languageCode: "en"
    };
    
    fetch(url, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-Goog-Api-Key': apiKey,
            'X-Goog-FieldMask': 'places.displayName,places.formattedAddress,places.id'
        },
        body: JSON.stringify(requestBody)
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Places API error: ${response.status} ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.places) {
            showResults(data.places.map(place => ({
                title: `${place.displayName.text} - ${place.formattedAddress}`,
                link: `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(place.displayName.text)}&query_place_id=${place.id}`,
                source: 'maps'
            })));
        }
    })
    .catch(error => console.error('Error fetching Maps data:', error));
}
/*
function showResults(results) {
    const dropdown = document.getElementById('dropdown');
    if (!dropdown) {
        console.error('Dropdown element not found');
        return;
    }

    dropdown.innerHTML = '';
    if (results.length > 0) {
        firstUrlInDropdown = results[0].link;
    }
    results.forEach(result => {
        const item = document.createElement('div');
        item.className = 'dropdown-item';
        item.textContent = result.title;
        item.dataset.url = result.link;
        item.dataset.source = result.source;
        item.addEventListener('click', () => {
            handleResultClick(result);
        });
        item.addEventListener('contextmenu', handleRightClick);
        dropdown.appendChild(item);
    });
    adjustDropdownPosition();
    dropdown.style.display = results.length ? 'block' : 'none';
}
*/
  function showResults(results) {
    const dropdown = document.getElementById('dropdown');
    if (!dropdown) {
        console.error('Dropdown element not found');
        return;
    }

    dropdown.innerHTML = '';
    if (results.length > 0) {
        firstUrlInDropdown = results[0].url;
    }
    results.forEach(result => {
        const item = document.createElement('div');
        item.className = 'dropdown-item';
        item.textContent = result.title;
        item.dataset.url = result.url;
        
        item.addEventListener('click', () => {
            handleResultClick(result);
        });
        item.addEventListener('contextmenu', handleRightClick);

        dropdown.appendChild(item);
    });
    adjustDropdownPosition();
    dropdown.style.display = results.length ? 'block' : 'none';
}

function fetchSearchResults(query) {
  const url = `https://corsproxy.io/?https://etsi.me/search?q=${encodeURIComponent(query)}&format=json`;

  fetch(url)
    .then(response => response.json())
    .then(data => {
      if (data.results) {
        showResults(data.results); // Assuming you have a function to display results
      }
    })
    .catch(error => console.error('Error fetching search results:', error));
}


    function isValidURL(url) {
        const pattern = new RegExp('^(https?:\\/\\/)?'+ // protocol
            '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|'+ // domain name
            '((\\d{1,3}\\.){3}\\d{1,3}))'+ // OR ip (v4) address
            '(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*'+ // port and path
            '(\\?[;&a-z\\d%_.~+=-]*)?'+ // query string
            '(\\#[-a-z\\d_]*)?$','i'); // fragment locator
        return pattern.test(url);
    }
/*
    function showResults(results) {
        dropdown.innerHTML = '';
        if (results.length > 0) {
            firstUrlInDropdown = results[0].link;
        }
        results.forEach(result => {
            const item = document.createElement('div');
            item.className = 'dropdown-item';
            item.textContent = result.title;
            item.dataset.url = result.link;
            item.addEventListener('click', () => {
                handleResultClick(result);
            });
            item.addEventListener('contextmenu', handleRightClick); // Add right-click event listener
            dropdown.appendChild(item);
        });
        adjustDropdownPosition();
        dropdown.style.display = results.length ? 'block' : 'none';
    }
*/
    function handleResultClick(result) {
        const url = result.url;
        if (isValidURL(url)) {
            window.location.href = url;
        } else {
            window.open(`https://www.google.com/search?q=${encodeURIComponent(searchInput.value)}`, '_blank');
        }
    }

    function adjustDropdownPosition() {
        const searchBox = document.querySelector('.custom-search-input');
        const searchBoxRect = searchBox.getBoundingClientRect();
        const dropdownRect = dropdown.getBoundingClientRect();

        dropdown.style.width = `${searchBoxRect.width}px`;

        if (window.innerHeight - searchBoxRect.bottom > dropdownRect.height) {
            dropdown.classList.remove('dropdown-top');
            dropdown.classList.add('dropdown-bottom');
        } else {
            dropdown.classList.remove('dropdown-bottom');
            dropdown.classList.add('dropdown-top');
        }
    }

    function updateEngineDropdown() {
        const options = engineDropdown.querySelectorAll('.engine-option');
        options.forEach(option => {
            if (option.dataset.engine === selectedEngine) {
                option.classList.add('selected');
            } else {
                option.classList.remove('selected');
            }
        });
    }

    function getSearchUrl(query) {
        let searchUrl;
        switch (selectedEngine) {
            case 'google':
                searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}`;
                break;
            case 'duckduckgo':
                searchUrl = `https://duckduckgo.com/?q=${encodeURIComponent(query)}`;
                break;
            case 'bing':
                searchUrl = `https://www.bing.com/search?q=${encodeURIComponent(query)}`;
                break;
            case 'yahoo':
                searchUrl = `https://search.yahoo.com/search?p=${encodeURIComponent(query)}`;
                break;
            case 'yandex':
                searchUrl = `https://yandex.ru/search/?text=${encodeURIComponent(query)}`;
                break;
            case 'baidu':
                searchUrl = `https://www.baidu.com/s?wd=${encodeURIComponent(query)}`;
                break;
            case 'naver':
                searchUrl = `https://search.naver.com/search.naver?query=${encodeURIComponent(query)}`;
                break; 
            case 'youtube':
                searchUrl = `https://www.youtube.com/results?search_query=${encodeURIComponent(query)}`;
                break;  
            case 'wikipedia':
                searchUrl = `https://wikipedia.org/wiki/${encodeURIComponent(query)}`;
                break; 
            case 'maps':
                searchUrl = `https://www.google.gr/maps/search/${encodeURIComponent(query)}`;
                break; 
            case 'searx':
                searchUrl = `https://searxng.site/searxng/search?q=${encodeURIComponent(query)}`;
                break;         
            case 'local':
                searchLocal(query);
                return;
            default:
                searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}`;
        }
        return searchUrl;
    }

    function updatePlaceholder() {
        const engineName = engineNames[selectedEngine] || 'Google';
        searchInput.placeholder = `${engineName} is now in use`;
    }

    function clearSearch() {
        searchInput.value = '';
        toggleClearButton();
        dropdown.style.display = 'none';
        firstUrlInDropdown = '';
        buttonIcon.textContent = 'search';
        removeHighlight();
    }

    function toggleClearButton() {
        const hasText = searchInput.value.length > 0;
        clearButton.style.display = hasText ? 'block' : 'none';
        engineSelectButton.style.display = hasText ? 'none' : 'block';
    }

    function toggleEngineDropdown() {
        engineDropdown.style.display = engineDropdown.style.display === 'none' ? 'block' : 'none';
        dropdown.style.display = 'none'; // Close main dropdown when engine dropdown is toggled
    }

    function selectEngine(engine) {
        selectedEngine = engine;
        localStorage.setItem('selectedEngine', engine);
        updateEngineDropdown();
        updatePlaceholder();
    }

    function searchLocal(searchText) {
        if (!searchText) return;
        console.log('Performing local search for:', searchText);

        // Add CSS for highlighting
        const existingStyle = document.querySelector('style.highlight');
        if (!existingStyle) {
            const style = document.createElement('style');
            style.className = 'highlight';
            style.textContent = `
                .highlight {
                    background-color: yellow;
                    color: black;
                }
            `;
            document.head.appendChild(style);
        }

        // Escape special characters in searchText for use in a regular expression
        const escapedText = searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
        
        // Create a regular expression to find all instances of the search text
        const regex = new RegExp(escapedText, 'gi');
        
        // Function to wrap text nodes with a span
        function wrapText(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                // If the text node contains the search text
                if (regex.test(node.nodeValue)) {
                    const newHTML = node.nodeValue.replace(regex, (match) => `<span class="highlight">${match}</span>`);
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = newHTML;
                    while (tempDiv.firstChild) {
                        node.parentNode.insertBefore(tempDiv.firstChild, node);
                    }
                    node.parentNode.removeChild(node);
                }
            } else if (node.nodeType === Node.ELEMENT_NODE) {
                // Recursively search child nodes
                Array.from(node.childNodes).forEach(wrapText);
            }
        }

        // Start wrapping from the body element
        wrapText(document.body);
    }

    function removeHighlight() {
        // Remove the highlighting style
        const style = document.querySelector('style.highlight');
        if (style) {
            style.remove();
        }

        // Function to unwrap highlighted text
        function unwrapText(node) {
            if (node.nodeType === Node.ELEMENT_NODE) {
                if (node.classList.contains('highlight')) {
                    // Replace the highlighted span with its text content
                    const textNode = document.createTextNode(node.textContent);
                    node.parentNode.replaceChild(textNode, node);
                } else {
                    // Recursively search child nodes
                    Array.from(node.childNodes).forEach(unwrapText);
                }
            }
        }

        // Start unwrapping from the body element
        unwrapText(document.body);
    }
/*
    function handleRightClick(event) {
        event.preventDefault(); // Prevent the default context menu
        const title = event.target.textContent; // Get the title from the data attribute
        const url = event.target.dataset.url; // Get the URL from the data attribute
        searchInput.value = url; // Set the URL to the text input
        if (url.includes('https://www.google.com/maps/')) {
            createMarko('location', url, title, 'https://www.google.com/s2/favicons?domain=https://maps.google.com&sz=64', '#0D47A1');
        } else if (url.includes('https://www.youtube.com/')) {
            createMarko('website', url, title, 'https://www.google.com/s2/favicons?domain=https://youtube.com&sz=64', '#0D47A1');
        } else {
            createMarko('website', url, title, `https://www.google.com/s2/favicons?domain=${url}&sz=32`, '#0D47A1');
        }
        // markoButton.click(); // Trigger the left button click
    }
*/
  function handleRightClick(event) {
    event.preventDefault(); // Prevent the default context menu
    const title = event.target.textContent; // Get the title from the element's text content
    const url = event.target.dataset.url; // Get the URL from the data attribute
    searchInput.value = url; // Set the URL to the text input

        if (url.includes('https://www.google.com/maps/')) {
            createMarko('location', url, title, 'https://www.google.com/s2/favicons?domain=https://maps.google.com&sz=64', '#0D47A1');
        } else if (url.includes('https://www.youtube.com/')) {
            createMarko('website', url, title, 'https://www.google.com/s2/favicons?domain=https://youtube.com&sz=64', '#0D47A1');
        } else {
            createMarko('website', url, title, `https://www.google.com/s2/favicons?domain=${url}&sz=32`, '#0D47A1');
        }
}
    function startRotatingPlaceholder() {
        const rotatingPlaceholders = [
            '..or enter url',
            'type here',
            'click search results..',
            '..or right click them',
            'How can I help you?'
        ];

        let index = 0;
        function rotatePlaceholder() {
            const engineName = engineNames[selectedEngine] || 'Google';
            if (searchInput.placeholder.startsWith(`${engineName} is now in use`)) {
                searchInput.placeholder = rotatingPlaceholders[index];
                index = (index + 1) % rotatingPlaceholders.length;
            } else {
                searchInput.placeholder = rotatingPlaceholders[index];
                index = (index + 1) % rotatingPlaceholders.length;
            }
        }

        setInterval(rotatePlaceholder, 3000);
    }
});
</script>






  
</head>
<body data-swipe-threshold="100" data-swipe-timeout="300">   
  <div id="overlay" class="overlay"></div>
 <div class="search-container">
        <div class="search-input-container">
        <button class="custom-button" id="markoButton">
            <span class="material-icons">add_circle</span> <!-- Use an appropriate icon -->
        </button>
            <input type="text" id="searchBoxInput" class="custom-search-input" placeholder="Search Google or enter url">
            <button class="custom-button" id="searchButton">
                <span class="material-icons" id="buttonIcon">search</span>
            </button>
            <button class="clear-button" id="clearButton">
                <span class="material-icons">clear</span>
            </button>
            <button class="engine-select-button" id="engineSelectButton">
                <span class="material-icons">arrow_drop_down</span>
            </button>
            <div class="engine-dropdown" id="engineDropdown">
                <div class="engine-option" data-engine="google">Google</div>
                <div class="engine-option" data-engine="duckduckgo">DuckDuckGo</div>
                <div class="engine-option" data-engine="bing">Bing</div>
                <div class="engine-option" data-engine="yahoo">Yahoo</div>
                <div class="engine-option" data-engine="yandex">Yandex</div>
                <div class="engine-option" data-engine="baidu">Baidu</div>
                <div class="engine-option" data-engine="naver">Naver</div>
                <div class="engine-option" data-engine="youtube">YouTube</div>
                <div class="engine-option" data-engine="wikipedia">Wikipedia</div>
                <div class="engine-option" data-engine="maps">Maps</div>
                <div class="engine-option" data-engine="searx">searX</div>
                <div class="engine-option" data-engine="local">Local</div>
            </div>
        </div>
        <div id="dropdown" class="dropdown"></div>
    </div> 
  
  
  <div id="markoTypeForm" style="display: none;">
  <h2>Creating a Marko.. (1/5)</h2>
  <div class="form-group">
    <label for="markoType">Select Marko type:</label>
    <select id="markoType" name="markoType">
      <option value="">Choose a type</option>
      <!-- Options will be added dynamically -->
    </select>
  </div>
  <button id="continueTo2Button">Continue</button>
</div>
<div id="markoIconTypeForm" style="display: none;">
  <h2>Creating a Marko.. (4/5)</h2>
  <div class="form-group">
    <label for="markoIconType">Select Marko icon type:</label>
    <select id="markoIconType" name="markoIcon Type">
      <option value="">Choose a type</option>
      <!-- Options will be added dynamically -->
    </select>
  </div>
  <button id="continueTo5Button">Continue</button>
</div>





  
      <div class="form-container-wrapper"  id="notificationForm">

  <div class="form-container">
    <form id="myForm">
              
      <div class="form-field">
        <label for="datetimeInput">Select Date and Time - alternatively select delay from now or from given time</label>
        <!-- Set initial value to current datetime -->
        <input type="datetime-local" id="datetimeInput" name="datetime" value="">
      </div>
        <div class="input-field">
        <select id="timeDelaySelect" name="timeDelay">
          <option value="0" selected>No delay</option>
          <option value="30000">In half an hour</option>
          <option value="60000000">In 1 hour</option>
          <option value="120000000">In 2 hours</option>
          <option value="180000000">In 3 hours</option>
          <option value="240000000">In 4 hours</option>
          <option value="300000000">In 5 hours</option>
          <option value="360000000">In 6 hours</option>
          <option value="420000000">In 7 hours</option>
          <option value="480000000">In 8 hours</option>
          <option value="540000000">In 9 hours</option>
          <option value="720000000">In 12 hours</option>
          <option value="1440000000">Tomorrow same time</option>
          <option value="10080000000">In a week from now</option>
        </select>
      </div>
      <div class="form-field">
        <label for="textInput">Enter Text</label>
        <input type="text" id="textInput" name="textInput" placeholder="Type something...">
      </div>
<button type="button" class="btn" id="submitButton" style="display: flex; align-items: center; justify-content: center;">
  Submit <i class="material-icons" style="margin-left: 5px;">send</i>
</button>
    </form>
  </div>
    </div>
<!-- Context Menu -->
<div id="contextMenu" class="context-menu">
    <div class="bg-white dark:bg-gray-800 w-64 border border-gray-300 dark:border-gray-700 rounded-lg flex flex-col text-sm py-4 px-2 text-gray-700 dark:text-gray-300 shadow-lg">
        <div id="current-link" class="flex hover:bg-gray-100 dark:hover:bg-gray-700 py-2 px-3 rounded cursor-pointer items-center">
            <span class="material-icons-outlined text-gray-900 dark:text-gray-300">cancel</span>
            <div class="ml-3"></div>
        </div>
        <hr class="my-2 border-gray-300 dark:border-gray-700" />
        <div id="context-delete" class="flex hover:bg-gray-100 dark:hover:bg-gray-700 py-2 px-3 rounded cursor-pointer items-center"
            onclick="deleteLink(`${currentIndex}`)">
            <span class="material-icons-outlined text-gray-900 dark:text-gray-300">delete</span>
            <div class="ml-3">Delete Marko</div>
        </div>
        <div id="context-moveup" class="flex hover:bg-gray-100 dark:hover:bg-gray-700 py-2 px-3 rounded cursor-pointer items-center"
            onclick="moveMarkoUp(`${currentIndex}`)">
            <span class="material-icons-outlined text-gray-900 dark:text-gray-300">arrow_upward</span>
            <div class="ml-3">Move One Up</div>
        </div>
        <div id="context-movedown" class="flex hover:bg-gray-100 dark:hover:bg-gray-700 py-2 px-3 rounded cursor-pointer items-center"
            onclick="moveMarkoDown(`${currentIndex}`)">
            <span class="material-icons-outlined text-gray-900 dark:text-gray-300">vertical_align_bottom</span>
            <div class="ml-3">Move to Bottom</div>
        </div>
              <div id="context-movepublic" class="flex hover:bg-gray-100 dark:hover:bg-gray-700 py-2 px-3 rounded cursor-pointer items-center"
            onclick="moveMarkoTo(`${currentIndex}`)">
            <span class="material-icons-outlined text-gray-900 dark:text-gray-300">publish</span>
            <div class="ml-3">Move to Common</div>
        </div>
        <hr id="context-divider" class="my-2 border-gray-300 dark:border-gray-700" />
        <div id="context-share" class="flex hover:bg-gray-100 dark:hover:bg-gray-700 py-2 px-3 rounded cursor-pointer items-center" onclick="shareMarko(`${currentIndex}`, true)">
            <span class="material-icons-outlined text-gray-900 dark:text-gray-300">link</span>
            <div class="ml-3">Share Marko</div>
        </div>
          <div id="context-settings" class="flex hover:bg-gray-100 dark:hover:bg-gray-700 py-2 px-3 rounded cursor-pointer items-center"
            onclick="openSettings()">
            <span class="material-icons-outlined text-gray-900 dark:text-gray-300">settings</span>
            <div class="ml-3">Settings</div>
        </div>
              <div id="context-rename" class="flex hover:bg-gray-100 dark:hover:bg-gray-700 py-2 px-3 rounded cursor-pointer items-center"
            onclick="renameMarko(`${currentIndex}`)">
            <span class="material-icons-outlined text-gray-900 dark:text-gray-300">edit</span>
            <div class="ml-3">Rename</div>
        </div>
        <div id="context-reminder" class="flex hover:bg-gray-100 dark:hover:bg-gray-700 py-2 px-3 rounded cursor-pointer items-center"
            onclick="addReminderToMarko(`${currentIndex}`)">
            <span class="material-icons-outlined text-gray-900 dark:text-gray-300">notifications</span>
            <div class="ml-3">Add Reminder</div>
        </div>
    </div>
</div>
<!-- Context Menu --> 
<div id="install-banner" class="install-banner">
    <span class="material-icons">install_desktop</span>
    <p>Install Marko</p>
    <span class="material-icons close-banner" onclick="hideInstallBanner(event)">close</span>
</div>
    <!-- Lightbox with iframe and YouTube player -->
  <div class="lightbox" id="lightbox">
    <div class="lightbox-content">
      <div id="content-container">
<iframe id="lightbox-iframe" class="lightbox-iframe" src="" allowfullscreen allow="autoplay"></iframe>
          <button id="close-btn" class="close-btn">
        <i class="material-icons">close</i>
      </button>
      </div>
    </div>
  </div>
<div class="youtube-lightbox" id="youtube-lightbox">
    <button id="close-yt">&times;</button>
    <div id="player"></div>
</div>

  <audio id="sound-swipe-left" src="https://github.com/IonTeLOS/marko/raw/main/nav_left.wav"></audio>
  <audio id="sound-swipe-right" src="https://github.com/IonTeLOS/marko/raw/main/nav_right.wav"></audio>  
    
    <!-- Placeholder div for Adobe PDF Embed API -->
    <div id="adobe-dc-view"></div>
    <div>
    <div id="modalOverlay" class="modal-overlay"></div>
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close" id="closeModal">&times;</span>
            <div class="tab-content">
                <div id="page1" class="tab-page active">
                    <h2>Page 1</h2>
                    <p>This is the content of Page 1.</p>
                </div>
                <div id="page2" class="tab-page">
                    <h2>Page 2</h2>
                    <p>Lorem ipsum</p>
                </div>
                <div id="page3" class="tab-page">
                    <h2>Settings</h2>
<button id="syncToDrive" class="g-button" onclick="saveToGoogleDrive()">
    <span id="syncToIcon" class="material-icons">arrow_circle_up</span>
    Sync TO Drive
</button>
<button id="syncToPublicWritableDrive" class="g-button" onclick="createUpdateCommonMarko()">
    <span id="syncToPublicWritableIcon" class="material-icons">public</span>
    Make public
</button>                  
<button id="signInOutButton" class="g-button" onclick="toggleSignInOut()">
    <span id="signInOutIcon" class="material-icons">login</span>
    <span id="signInOutText">Sign In</span>
</button>
<button id="syncFromDrive" class="g-button" onclick="getFromGoogleDrive()">
    <span id="syncFromIcon" class="material-icons">sync</span>
    Sync FROM Drive
</button>
<button id="clearStorage" class="g-button" onclick="clearLinks()">
    <span class="material-icons">delete_forever</span>
    Delete all
</button>
<button id="toggleTheme" class="g-button" onclick="toggleTheme()">
    <span class="material-icons">sync</span>
    Change theme
</button>   
<button id="setPass" class="g-button" onclick="setPassword()">
    <span class="material-icons">lock</span>
    Set Pass
</button> 
<button id="clearPPass" class="g-button" onclick="removePassword()">
    <span class="material-icons">lock_reset</span>
    Change Pass
</button>                   
                </div>
            </div>
            <div class="tabs">
                <button class="tab-link active" onclick="openTab(event, 'page1')">Page 1</button>
                <button class="tab-link" onclick="openTab(event, 'page2')">Page 2</button>
                <button class="tab-link" onclick="openTab(event, 'page3')">Page 3</button>
            </div>
        </div>
    </div>
    </div>

<div id="tooltip" class="tooltip">
    <div class="tooltip-content" id="tooltip-content"></div>
</div>
    
  <div class="offline-banner" id="offline-banner">
        <span class="material-icons">wifi_off</span>
    </div>
<div oncontextmenu="return false;" class="add-banner" id="add-banner">
  <button class="material-btn bottom-left-btn" id="openModal">
    <i class="material-icons material-icon">settings</i>
  </button>
  <button class="material-btn main-btn" style="margin-left: 15%; margin-right: 15%;" onclick="openAdd()">
    <i class="material-icons material-icon">radio_button_unchecked</i>
  </button>
  <button class="material-btn bottom-right-btn" onclick="downloadPage()">
    <i class="material-icons material-icon">share</i>
  </button>
</div>           

 
      
<div id="upper-container" class="container" style="display: none;">
  <div id="new-link-form" style="display: none;">
    <div class="input-field">
      <select id="link-type">
        <option value="" disabled selected>select bookmark type</option>
        <option value="website">Link to a website or social profile</option>
        <option value="email">Email</option>
        <option value="phone">Phone</option>
        <option value="whatsapp">WhatsApp Chat</option>
        <option value="viber">Viber Chat</option>
        <option value="note">Note</option>
        <option value="post">Post</option>
        <option value="window">Window (embed a webpage)</option>
        <option value="pdf">PDF document</option>
        <option value="download">Download</option>
        <option value="location">Location</option>
        <option value="payment">Paylink</option>
        <option value="other">other (any custom url protocol)</option>
      </select>
    </div>
    </div>
    <div id="additional-fields" style="display: none;">
      <div class="input-field">
  <input type="url" id="new-link-url" placeholder="Enter bookmark url">
  <button id="u-clear-btn" class="clear-btn" style="display:none;">âœ•</button>
</div>
      <div class="input-field">
        <input type="text" id="new-link-name" placeholder="Enter bookmark title" maxlength="30">
        <button id="t-clear-btn" class="clear-btn" style="display:none;">âœ•</button>
      </div>
      <div class="input-field icon-source-selector" id="icon-source-container" style="display: none;">
        <select id="icon-source">
          <option value="default">Use default Material Icon (in random color)</option>
          <option value="favicon">Use website favicon</option>
          <option value="selection">Select an icon</option>
        </select>
      </div>
    </div>
    <div id="note-field" class="input-field" style="display: none;">
  <textarea id="note-content" style="height: 300px; width: 100%;" placeholder="Enter note content (max 500 characters)"></textarea>
</div>
    <div id="intro-field" class="input-field" style="height:300px; overflow-y:scroll; border:1px solid #c0c0c0; display:none;">
    <textarea id="intro-content" style="height:100%" placeholder="Enter note content (max 300 characters)" maxlength="300"></textarea>
    </div>
     <div id="url-field" class="input-field" style="display: none;">
      <input type="url" id="window-url" placeholder="Enter target URL">
      <button id="w-clear-btn" class="clear-btn" style="display:none;">âœ•</button>
    </div>
       <div id="phone-number-field" class="input-field" style="display: none;">
      <input type="tel" id="phone-number" placeholder="Add number with country code">
      <button id="p-clear-btn" class="clear-btn" style="display:none;">âœ•</button>
    </div>
 
      
   
    
   
        <div id="icon-selection-container" class="container" style="display: none;">
  <div class="row">
    <div class="col s12">
      <div class="card-panel" style="display: none;">
        <div class="input-container">
          <div id="new-link-icon" tabindex="0">
  <span id="icon-select" class="material-icons-outlined z-depth-1">search</span>
</div>
          <input 
            type="text" 
            id="search" 
            placeholder="Search icons..." 
            autocomplete="off" 
            autocorrect="off" 
            autocapitalize="off" 
            spellcheck="false"
          >
          <span id="icon-name">search</span>
          <div id="color-select" tabindex="0">#0D47A1</div>
        </div>
        <div id="icon-dropdown">
          <div id="icon-grid"></div>
        </div>
      </div>
    </div>
  </div>
</div>
    </div>

<div class="bookmarks-container" no-select>
</div>
    
<div oncontextmenu="return false;" class="form-buttons" id="menu-container">
  <button class="material-btn left-btn" onclick="downloadPage()">
    <i class="material-icons material-icon">cloud_download</i>
  </button>
  <button class="material-btn middle-btn" style="margin-left: 10%; margin-right: 10%;" onclick="console.log('upper middle button clicked')">
    <i class="material-icons material-icon">bookmark_add</i>
  </button>
  <button class="material-btn right-btn" onclick="cancelAddLink()">
    <i class="material-icons material-icon">cancel</i>
  </button>
    <pre id="created-bookmark"></pre>
</div>

<script>
var currentIndex = null;
var allIndex = null;
    
document.addEventListener("DOMContentLoaded", function () {
    var menu = document.querySelector(".context-menu");
    var menuState = 0;
    var contextMenuActive = "block";

    const linkContainer = document.querySelector('.bookmarks-container');
    const mainBookmark = document.getElementById('main-bookmark');

    // Function to handle showing the context menu
    function showContextMenu(event) {
        if (!linkContainer.contains(event.target)) {
            return;
        }
        if (event.target.closest('#main-bookmark')) {
            event.preventDefault(); // Prevent context menu on main bookmark
            return;
        }
        event.preventDefault();

        var targetElement = event.target;
        while (targetElement) {
            if (targetElement.id && (targetElement.id.startsWith('bookmark-') || targetElement.id.startsWith('delete-'))) {
                currentIndex = targetElement.id.split('-')[1];
                console.log("Right-clicked element index:", currentIndex);
                break;
            }
            targetElement = targetElement.parentElement;
        }

        toggleMenuOn();
        positionMenu(event);
    }

    // Event listener for context menu (Right-click)
    document.addEventListener("contextmenu", function (event) {
        showContextMenu(event);
    });

    // Event listener for touchstart (Long press on iOS)
    document.addEventListener("touchstart", function (event) {
        let touchTimeout;
        if (!linkContainer.contains(event.target)) {
            return;
        }

        touchTimeout = setTimeout(() => {
            event.preventDefault();
            showContextMenu(event);
        }, 500); // Adjust this value as necessary for the long-press duration

        document.addEventListener("touchend", function () {
            clearTimeout(touchTimeout);
        }, { once: true });

        document.addEventListener("touchmove", function () {
            clearTimeout(touchTimeout); // Cancel the menu if the user starts moving
        }, { once: true });
    });

    function toggleMenuOn() {
        if (menuState !== 1) {
            menuState = 1;
            menu.classList.add(contextMenuActive);
            event.stopPropagation();
        }
    }

    function toggleMenuOff() {
        if (menuState !== 0) {
            menuState = 0;
            menu.classList.remove(contextMenuActive);
        }
    }

    function getPosition(e) {
        let posx = 0;
        let posy = 0;

        if (!e) e = window.event;

        if (e.pageX || e.pageY) {
            posx = e.pageX;
            posy = e.pageY;
        } else if (e.clientX || e.clientY) {
            posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
        }

        return { x: posx, y: posy };
    }

    function positionMenu(e) {
        const menu = document.getElementById('contextMenu');
        const linkPlace = document.getElementById('current-link');

        // Ensure the menu element exists
        if (!menu) {
            console.error('Menu element not found');
            return;
        }

        // Update the menu element with the currentLink text
        if (linkPlace) {
            linkPlace.querySelector('.ml-3').textContent = currentLink.substring(0, 30);

            // Apply initial blue color
            linkPlace.querySelector('.ml-3').style.color = 'orange';

            // After 1 second, change text color to white
            setTimeout(function () {
                linkPlace.querySelector('.ml-3').style.color = 'white';
            }, 1200);
        }

        // Get viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Ensure the menu is visible to get its dimensions
        menu.classList.remove('hidden');

        // Get menu dimensions
        const menuWidth = menu.offsetWidth;
        const menuHeight = menu.offsetHeight;

        // Calculate centered position
        const left = (viewportWidth - menuWidth) / 2;
        const top = (viewportHeight - menuHeight) / 2;

        // Apply Tailwind classes for centering
        menu.classList.add('fixed', 'transform', '-translate-x-1/2', '-translate-y-1/2');
        menu.style.left = '50%';
        menu.style.top = '50%';

        // Remove any inline width/height styles
        menu.style.width = '';
        menu.style.height = '';

        // Ensure the menu is visible
        menu.classList.remove('hidden');
    }

    document.addEventListener("click", (e) => {
        var button = e.which || e.button;
        if (button === 1) {
            toggleMenuOff();
            initSwipeDetection(event); // Reinitialize swipe detection after the menu is closed
        }
    });

    document.addEventListener('click', function (event) {
        if (menu && !menu.contains(event.target)) {
            toggleMenuOff();
        }
    });

    window.onkeyup = function (e) {
        if (e.keyCode === 27) {
            toggleMenuOff();
        }
    }
});

  
function updateSwipeClasses(wrapper, deltaX) {
    const bookmark = wrapper.closest('.bookmark');
    bookmark.classList.remove('swipe-left', 'swipe-right');
    if (deltaX < 0) {
        bookmark.classList.add('swipe-left');
    } else if (deltaX > 0) {
        bookmark.classList.add('swipe-right');
    }
}

function initSwipeDetection() {
    document.querySelectorAll('.bookmark-wrapper').forEach(wrapper => {
        let touchstartX = 0;
        let touchstartY = 0;
        let touchstartTime = 0;
        let isSwipeInProgress = false;
        const bookmarkId = wrapper.closest('.bookmark').getAttribute('data-index');
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        const handleSwipeStart = (e) => {
            if (isSwipeInProgress) return;
            isSwipeInProgress = true;
            touchstartTime = Date.now();
            if (isTouchDevice) {
                touchstartX = e.touches[0].clientX;
                touchstartY = e.touches[0].clientY;
            } else {
                touchstartX = e.clientX;
                touchstartY = e.clientY;
            }
        };

        const handleSwipeMove = (e) => {
            if (!isSwipeInProgress) return;
            
            let currentX, currentY;
            if (isTouchDevice) {
                currentX = e.touches[0].clientX;
                currentY = e.touches[0].clientY;
            } else {
                currentX = e.clientX;
                currentY = e.clientY;
            }
            handleSwipe(wrapper, bookmarkId, touchstartX, currentX, touchstartY, currentY);
        };

        const handleSwipeEnd = (e) => {
            isSwipeInProgress = false;
            const touchendTime = Date.now();
            const elapsedTime = touchendTime - touchstartTime;

            // Check if the movement is below the threshold for click detection
            const threshold = 30;
            let currentX, currentY;
            if (isTouchDevice) {
                currentX = e.changedTouches[0].clientX;
                currentY = e.changedTouches[0].clientY;
            } else {
                currentX = e.clientX;
                currentY = e.clientY;
            }

            const deltaX = Math.abs(currentX - touchstartX);
            const deltaY = Math.abs(currentY - touchstartY);

            if (deltaX < threshold && deltaY < threshold && elapsedTime < 200) {
                // It's a click, not a swipe
                return;
            }

            updateSwipeClasses(wrapper, 0); // Reset classes
        };

        if (isTouchDevice) {
            wrapper.addEventListener('touchstart', handleSwipeStart, { passive: true });
            wrapper.addEventListener('touchmove', handleSwipeMove, { passive: true });
            wrapper.addEventListener('touchend', handleSwipeEnd);
        } else {
            wrapper.addEventListener('mousedown', handleSwipeStart);
            wrapper.addEventListener('mousemove', handleSwipeMove);
            wrapper.addEventListener('mouseup', handleSwipeEnd);
            wrapper.addEventListener('mouseleave', handleSwipeEnd); // Add this line
        }

        // Prevent click event if a swipe is detected
        wrapper.addEventListener('click', (e) => {
            if (isSwipeInProgress) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        });
    });
}

let isSwipeActionInProgress = false;
let lastSwipeTime = 0;
const swipeCooldown = 1000; // 1 second cooldown between swipes

function debounce(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

const debouncedHandleSwipe = debounce((wrapper, bookmarkId, startX, currentX, startY, currentY) => {
    const now = Date.now();
    if (isSwipeActionInProgress || now - lastSwipeTime < swipeCooldown) {
        return;
    }

    const threshold = 30;
    const verticalThreshold = 50;
    const deltaX = currentX - startX;
    const deltaY = Math.abs(currentY - startY);

    if (deltaY > verticalThreshold) return;

    if (Math.abs(deltaX) > threshold) {
        if (!bookmarkId) {
        console.log('no bookmark id, this is probably main-bookmark being swiped, nothing to do');
          return;
        }
        isSwipeActionInProgress = true;

          if (deltaX < 0) {
            // Left swipe
            playSound('sound-swipe-left');
            Notiflix.Confirm.show(
                'Please confirm',
                'Do you really want to remove this Marko?',
                'Yes',
                'No',
                () => {
                    try {
                        clearLink(bookmarkId);
                    } catch (error) {
                        console.error('Error clearing link:', error);
                    }
                },
                () => {
                    // No action needed if 'No' is clicked
                    isSwipeActionInProgress = false;
                }
            );
        } else {
            // Right swipe
            try {
                playSound('sound-swipe-right');
                shareMarko(bookmarkId, true);
            } catch (error) {
                console.error('Error constructing link:', error);
            }
        }

        lastSwipeTime = now;
        setTimeout(() => {
            isSwipeActionInProgress = false;
        }, 500); // Reset the flag after 500ms
    }
}, 250); // Debounce for 250ms

function handleSwipe(wrapper, bookmarkId, startX, currentX, startY, currentY) {
    const deltaX = currentX - startX;
    const deltaY = Math.abs(currentY - startY);
    const verticalThreshold = 50;

    if (deltaY > verticalThreshold) {
        updateSwipeClasses(wrapper, 0); // Reset classes if vertical swipe
        return;
    }

    updateSwipeClasses(wrapper, deltaX);

    debouncedHandleSwipe(wrapper, bookmarkId, startX, currentX, startY, currentY);
}

// Check if the DOM is already loaded for swipe detection initialization
if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initSwipeDetection);
} else {
    initSwipeDetection();
}


        const icons = [
            '3d_rotation','ac_unit','access_alarm','access_alarms','access_time','accessibility','accessible','account_balance','account_balance_wallet','account_box','account_circle','adb','add','add_a_photo','add_alarm','add_alert','add_box','add_circle','add_circle_outline','add_location','add_shopping_cart','add_to_photos','add_to_queue','adjust','airline_seat_flat','airline_seat_flat_angled','airline_seat_individual_suite','airline_seat_legroom_extra','airline_seat_legroom_normal','airline_seat_legroom_reduced','airline_seat_recline_extra','airline_seat_recline_normal','airplanemode_active','airplanemode_inactive','airplay','airport_shuttle','alarm','alarm_add','alarm_off','alarm_on','album','all_inclusive','all_out','android','announcement','apps','archive','arrow_back','arrow_downward','arrow_drop_down','arrow_drop_down_circle','arrow_drop_up','arrow_forward','arrow_upward','art_track','aspect_ratio','assessment','assignment','assignment_ind','assignment_late','assignment_return','assignment_returned','assignment_turned_in','assistant','assistant_photo','attach_file','attach_money','attachment','audiotrack','autorenew','av_timer','backspace','backup','battery_alert','battery_charging_full','battery_full','battery_std','battery_unknown','beach_access','beenhere','block','bluetooth','bluetooth_audio','bluetooth_connected','bluetooth_disabled','bluetooth_searching','blur_circular','blur_linear','blur_off','blur_on','book','bookmark','bookmark_border','border_all','border_bottom','border_clear','border_color','border_horizontal','border_inner','border_left','border_outer','border_right','border_style','border_top','border_vertical','branding_watermark','brightness_1','brightness_2','brightness_3','brightness_4','brightness_5','brightness_6','brightness_7','brightness_auto','brightness_high','brightness_low','brightness_medium','broken_image','brush','bubble_chart','bug_report','build','burst_mode','business','business_center','cached','cake','call','call_end','call_made','call_merge','call_missed','call_missed_outgoing','call_received','call_split','call_to_action','camera','camera_alt','camera_enhance','camera_front','camera_rear','camera_roll','cancel','card_giftcard','card_membership','card_travel','casino','cast','cast_connected','center_focus_strong','center_focus_weak','change_history','chat','chat_bubble','chat_bubble_outline','check','check_box','check_box_outline_blank','check_circle','chevron_left','chevron_right','child_care','child_friendly','chrome_reader_mode','class','clear','clear_all','close','closed_caption','cloud','cloud_circle','cloud_done','cloud_download','cloud_off','cloud_queue','cloud_upload','code','collections','collections_bookmark','color_lens','colorize','comment','compare','compare_arrows','computer','confirmation_number','contact_mail','contact_phone','contacts','content_copy','content_cut','content_paste','control_point','control_point_duplicate','copyright','create','create_new_folder','credit_card','crop','crop_16_9','crop_3_2','crop_5_4','crop_7_5','crop_din','crop_free','crop_landscape','crop_original','crop_portrait','crop_rotate','crop_square','dashboard','data_usage','date_range','dehaze','delete','delete_forever','delete_sweep','description','desktop_mac','desktop_windows','details','developer_board','developer_mode','device_hub','devices','devices_other','dialer_sip','dialpad','directions','directions_bike','directions_boat','directions_bus','directions_car','directions_railway','directions_run','directions_subway','directions_transit','directions_walk','disc_full','dns','do_not_disturb','do_not_disturb_alt','do_not_disturb_off','do_not_disturb_on','dock','domain','done','done_all','donut_large','donut_small','drafts','drag_handle','drive_eta','dvr','edit','edit_location','eject','email','enhanced_encryption','equalizer','error','error_outline','euro_symbol','ev_station','event','event_available','event_busy','event_note','event_seat','exit_to_app','expand_less','expand_more','explicit','explore','exposure','exposure_neg_1','exposure_neg_2','exposure_plus_1','exposure_plus_2','exposure_zero','extension','face','fast_forward','fast_rewind','favorite','favorite_border','featured_play_list','featured_video','feedback','fiber_dvr','fiber_manual_record','fiber_new','fiber_pin','fiber_smart_record','file_download','file_upload','filter','filter_1','filter_2','filter_3','filter_4','filter_5','filter_6','filter_7','filter_8','filter_9','filter_9_plus','filter_b_and_w','filter_center_focus','filter_drama','filter_frames','filter_hdr','filter_list','filter_none','filter_tilt_shift','filter_vintage','find_in_page','find_replace','fingerprint','first_page','fitness_center','flag','flare','flash_auto','flash_off','flash_on','flight','flight_land','flight_takeoff','flip','flip_to_back','flip_to_front','folder','folder_open','folder_shared','folder_special','font_download','format_align_center','format_align_justify','format_align_left','format_align_right','format_bold','format_clear','format_color_fill','format_color_reset','format_color_text','format_indent_decrease','format_indent_increase','format_italic','format_line_spacing','format_list_bulleted','format_list_numbered','format_paint','format_quote','format_shapes','format_size','format_strikethrough','format_textdirection_l_to_r','format_textdirection_r_to_l','format_underlined','forum','forward','forward_10','forward_30','forward_5','free_breakfast','fullscreen','fullscreen_exit','functions','g_translate','gamepad','games','gavel','gesture','get_app','gif','golf_course','gps_fixed','gps_not_fixed','gps_off','grade','gradient','grain','graphic_eq','grid_off','grid_on','group','group_add','group_work','hd','hdr_off','hdr_on','hdr_strong','hdr_weak','headset','headset_mic','healing','hearing','help','help_outline','high_quality','highlight','highlight_off','history','home','hot_tub','hotel','hourglass_empty','hourglass_full','http','https','image','image_aspect_ratio','import_contacts','import_export','important_devices','inbox','indeterminate_check_box','info','info_outline','input','insert_chart','insert_comment','insert_drive_file','insert_emoticon','insert_invitation','insert_link','insert_photo','invert_colors','invert_colors_off','iso','keyboard','keyboard_arrow_down','keyboard_arrow_left','keyboard_arrow_right','keyboard_arrow_up','keyboard_backspace','keyboard_capslock','keyboard_hide','keyboard_return','keyboard_tab','keyboard_voice','kitchen','label','label_outline','landscape','language','laptop','laptop_chromebook','laptop_mac','laptop_windows','last_page','launch','layers','layers_clear','leak_add','leak_remove','lens','library_add','library_books','library_music','lightbulb_outline','line_style','line_weight','linear_scale','link','linked_camera','list','live_help','live_tv','local_activity','local_airport','local_atm','local_bar','local_cafe','local_car_wash','local_convenience_store','local_dining','local_drink','local_florist','local_gas_station','local_grocery_store','local_hospital','local_hotel','local_laundry_service','local_library','local_mall','local_movies','local_offer','local_parking','local_pharmacy','local_phone','local_pizza','local_play','local_post_office','local_printshop','local_see','local_shipping','local_taxi','location_city','location_disabled','location_off','location_on','location_searching','lock','lock_open','lock_outline','looks','looks_3','looks_4','looks_5','looks_6','looks_one','looks_two','loop','loupe','low_priority','loyalty','mail','mail_outline','map','markunread','markunread_mailbox','memory','menu','merge_type','message','mic','mic_none','mic_off','mms','mode_comment','mode_edit','monetization_on','money_off','monochrome_photos','mood','mood_bad','more','more_horiz','more_vert','motorcycle','mouse','move_to_inbox','movie','movie_creation','movie_filter','multiline_chart','music_note','music_video','my_location','nature','nature_people','navigate_before','navigate_next','navigation','near_me','network_cell','network_check','network_locked','network_wifi','new_releases','next_week','nfc','no_encryption','no_sim','not_interested','note','note_add','notifications','notifications_active','notifications_none','notifications_off','notifications_paused','offline_pin','ondemand_video','opacity','open_in_browser','open_in_new','open_with','pages','pageview','palette','pan_tool','panorama','panorama_fish_eye','panorama_horizontal','panorama_vertical','panorama_wide_angle','party_mode','pause','pause_circle_filled','pause_circle_outline','payment','people','people_outline','perm_camera_mic','perm_contact_calendar','perm_data_setting','perm_device_information','perm_identity','perm_media','perm_phone_msg','perm_scan_wifi','person','person_add','person_outline','person_pin','person_pin_circle','personal_video','pets','phone','phone_android','phone_bluetooth_speaker','phone_forwarded','phone_in_talk','phone_iphone','phone_locked','phone_missed','phone_paused','phonelink','phonelink_erase','phonelink_lock','phonelink_off','phonelink_ring','phonelink_setup','photo','photo_album','photo_camera','photo_filter','photo_library','photo_size_select_actual','photo_size_select_large','photo_size_select_small','picture_as_pdf','picture_in_picture','picture_in_picture_alt','pie_chart','pie_chart_outlined','pin_drop','place','play_arrow','play_circle_filled','play_circle_outline','play_for_work','playlist_add','playlist_add_check','playlist_play','plus_one','poll','polymer','pool','portable_wifi_off','portrait','power','power_input','power_settings_new','pregnant_woman','present_to_all','print','priority_high','public','publish','query_builder','question_answer','queue','queue_music','queue_play_next','radio','radio_button_checked','radio_button_unchecked','rate_review','receipt','recent_actors','record_voice_over','redeem','redo','refresh','remove','remove_circle','remove_circle_outline','remove_from_queue','remove_red_eye','remove_shopping_cart','reorder','repeat','repeat_one','replay','replay_10','replay_30','replay_5','reply','reply_all','report','report_problem','restaurant','restaurant_menu','restore','restore_page','ring_volume','room','room_service','rotate_90_degrees_ccw','rotate_left','rotate_right','rounded_corner','router','rowing','rss_feed','rv_hookup','satellite','save','scanner','schedule','school','screen_lock_landscape','screen_lock_portrait','screen_lock_rotation','screen_rotation','screen_share','sd_card','sd_storage','search','security','select_all','send','sentiment_dissatisfied','sentiment_neutral','sentiment_satisfied','sentiment_very_dissatisfied','sentiment_very_satisfied','settings','settings_applications','settings_backup_restore','settings_bluetooth','settings_brightness','settings_cell','settings_ethernet','settings_input_antenna','settings_input_component','settings_input_composite','settings_input_hdmi','settings_input_svideo','settings_overscan','settings_phone','settings_power','settings_remote','settings_system_daydream','settings_voice','share','shop','shop_two','shopping_basket','shopping_cart','short_text','show_chart','shuffle','signal_cellular_4_bar','signal_cellular_connected_no_internet_4_bar','signal_cellular_no_sim','signal_cellular_null','signal_cellular_off','signal_wifi_4_bar','signal_wifi_4_bar_lock','signal_wifi_off','sim_card','sim_card_alert','skip_next','skip_previous','slideshow','slow_motion_video','smartphone','smoke_free','smoking_rooms','sms','sms_failed','snooze','sort','sort_by_alpha','spa','space_bar','speaker','speaker_group','speaker_notes','speaker_notes_off','speaker_phone','spellcheck','star','star_border','star_half','stars','stay_current_landscape','stay_current_portrait','stay_primary_landscape','stay_primary_portrait','stop','stop_screen_share','storage','store','store_mall_directory','straighten','streetview','strikethrough_s','style','subdirectory_arrow_left','subdirectory_arrow_right','subject','subscriptions','subtitles','subway','supervisor_account','surround_sound','swap_calls','swap_horiz','swap_vert','swap_vertical_circle','switch_camera','switch_video','sync','sync_disabled','sync_problem','system_update','system_update_alt','tab','tab_unselected','tablet','tablet_android','tablet_mac','tag_faces','tap_and_play','terrain','text_fields','text_format','textsms','texture','theaters','thumb_down','thumb_up','thumbs_up_down','time_to_leave','timelapse','timeline','timer','timer_10','timer_3','timer_off','title','toc','today','toll','tonality','touch_app','toys','track_changes','traffic','train','tram','transfer_within_a_station','transform','translate','trending_down','trending_flat','trending_up','tune','turned_in','turned_in_not','tv','unarchive','undo','unfold_less','unfold_more','update','usb','verified_user','vertical_align_bottom','vertical_align_center','vertical_align_top','vibration','video_call','video_label','video_library','videocam','videocam_off','videogame_asset','view_agenda','view_array','view_carousel','view_column','view_comfy','view_compact','view_day','view_headline','view_list','view_module','view_quilt','view_stream','view_week','vignette','visibility','visibility_off','voice_chat','voicemail','volume_down','volume_mute','volume_off','volume_up','vpn_key','vpn_lock','wallpaper','warning','watch','watch_later','wb_auto','wb_cloudy','wb_incandescent','wb_iridescent','wb_sunny','wc','web','web_asset','weekend','whatshot','widgets','wifi','wifi_lock','wifi_tethering','work','wrap_text','youtube_searched_for','zoom_in','zoom_out','zoom_out_map'
        ];

        const iconSelect = document.getElementById('new-link-icon');
        const iconSpan = iconSelect.querySelector('.material-icons-outlined');
        const iconName = document.getElementById('icon-name');
        const iconDropdown = document.getElementById('icon-dropdown');
        const iconGrid = document.getElementById('icon-grid');
        const iconSearchInput = document.getElementById('search');
        const colorSelect = document.getElementById('color-select');

        function setSelectedIcon(icon) {
            const selectedColor = colorSelect.dataset.color;
            iconSpan.textContent = icon;
            iconSpan.style.color = selectedColor;
            iconName.textContent = icon;
            hideDropdown();
        }

        function showDropdown() {
            iconDropdown.style.display = 'block';
        }

        function hideDropdown() {
            iconDropdown.style.display = 'none';
        }

        function filterIcons(query) {
            const normalizedQuery = query.toLowerCase();
            const iconDivs = iconGrid.getElementsByClassName('icon');
            for (let div of iconDivs) {
                const iconName = div.textContent.toLowerCase();
                div.style.display = iconName.includes(normalizedQuery) ? 'block' : 'none';
            }
        }

        function updateColorDisplay(color) {
            colorSelect.style.backgroundColor = color;
            colorSelect.textContent = color.toUpperCase();
            colorSelect.style.color = isColorDark(color) ? 'white' : 'black';
            colorSelect.dataset.color = color;
            iconSpan.style.color = color;
        }

        function isColorDark(color) {
            const r = parseInt(color.substr(1, 2), 16);
            const g = parseInt(color.substr(3, 2), 16);
            const b = parseInt(color.substr(5, 2), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness < 128;
        }
        

        icons.forEach(icon => {
            const div = document.createElement('div');
            div.className = 'icon waves-effect';
            div.innerHTML = `<span class="material-icons-outlined">${icon}</span>`;
            div.onclick = () => {
                setSelectedIcon(icon);
                iconSearchInput.value = icon;
                filterIcons(icon);
            };
            iconGrid.appendChild(div);
        });

        // Filter icons as user types
        iconSearchInput.addEventListener('input', function() {
            filterIcons(this.value);
        });

        // Handle color selection
        colorSelect.onclick = function() {
            const input = document.createElement('input');
            input.type = 'color';
            input.value = this.dataset.color || '#0D47A1';
            input.onchange = function() { updateColorDisplay(this.value); };
            input.click();
        };
        
        // Add this instead
iconSearchInput.addEventListener('input', function() {
  const query = this.value.trim();
  if (query) {
    showDropdown();
    filterIcons(query);
  } else {
    hideDropdown();
  }
});

        // Initialize with default color
        updateColorDisplay('#0D47A1');

        // Add keyboard accessibility
        iconSelect.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                showDropdown();
                searchInput.focus();
            }
        });

        colorSelect.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                this.click();
            }
        });

  function getLinkFromValue(onclickString) {
    // Regular expression to match the pattern of the onclick attribute
    const regex = /openMarko\(([^,]+),\s*'([^']*)'(?:,\s*'([^']*)')?\)/;

    // Execute the regex on the onclick string
    const match = onclickString.match(regex);

    // If there's a match, extract the arguments
    if (match) {
        const functionName = match[1].trim();
        const firstArgument = match[2].trim();
        const secondArgument = match[3] ? match[3].trim() : null;

        // Return the arguments as an object without quotes
        return firstArgument.replace(/^'|'$/g, "");
    }

    // If no match, return null
    return null;
}
  
function shareMarko(index) {
    const bookmark = document.querySelector(`.bookmark[data-index="${index}"]`);
    console.log('Selected Marko to share: ', bookmark);
    if (!bookmark) {
        console.log(`No bookmark found with index ${index}`);
        return null;
    }

    const bookmarkWrapper = bookmark.querySelector('.bookmark-wrapper');
    const iconContainer = bookmarkWrapper.querySelector('.icon-container');
    const bookmarkTitle = bookmarkWrapper.querySelector('.bookmark-title');
    const bookmarkIcon = iconContainer.querySelector('img');

    // Extract the required values
    const onclickValue = bookmarkWrapper.getAttribute('onclick');
    const actionMatch = getLinkFromValue(onclickValue);
    console.log('actionMatch');
    //const actionLink = actionMatch ? actionMatch[1].replace(/'/g, '') : ''; // Extracted and stripped of single quotes
    const type = bookmarkWrapper.getAttribute('data-type') || '';
    const title = bookmarkTitle ? bookmarkTitle.textContent.trim() : '';
    const icon = bookmarkIcon ? bookmarkIcon.getAttribute('src') : '';
    const color = iconContainer ? getComputedStyle(iconContainer).getPropertyValue('--ring-color').trim() : '';

    // Construct the URL for the shareable link
    const url = new URL('https://marko-app.netlify.app');
    url.searchParams.append('type', type);
    url.searchParams.append('link', actionMatch);
    url.searchParams.append('title', title);
    url.searchParams.append('icon', icon);
    url.searchParams.append('color', color);
    url.searchParams.append('createMarko', 'true');

    const shareLink = url.toString();
    const shareTitle = "Use Marko to open..";
    const shareBody = title;
    const shareIcon = icon;

    const handleNoConfirmation = () => {
        console.log('User chose not to create shortlink, continuing...');

        if (navigator.share) {
            window.focus();
            navigator.share({
                title: shareTitle,
                url: shareLink
            })
            .then(() => console.log('Shared successfully'))
            .catch((error) => console.error('Error in sharing:', error));
        } else {
            // Fallback for browsers that do not support Web Share API
            window.focus();
            navigator.clipboard.writeText(shareLink)
            .then(() => {
                console.log('Link copied to clipboard');
            })
            .catch((error) => {
                console.error('Error in copying link to clipboard:', error);
            });
        }
    };

    Notiflix.Confirm.show(
        'Please confirm',
        'Do you also want to create a shortlink?',
        'Yes',
        'No',
        () => {
            try {
                initializeShortlinkWithTempMarkoLink(shareLink);
            } catch (error) {
                console.error('Error initializing shortlink:', error);
                handleNoConfirmation();
            }
        },
        handleNoConfirmation
    );

    return shareLink;
}


function constructLinkFromBookmark(index, full) {
  const bookmark = document.querySelector(`.bookmark[data-index="${index}"]`);
  if (!bookmark) {
    console.log(`No bookmark found with index ${index}`);
    return null;
  }

  const bookmarkWrapper = bookmark.querySelector('.bookmark-wrapper');
  const iconContainer = bookmarkWrapper.querySelector('.icon-container');
  const bookmarkTitle = bookmarkWrapper.querySelector('.bookmark-title');
  const bookmarkIcon = iconContainer.querySelector('img');

  // Extract the required values
  const onclickValue = bookmarkWrapper.getAttribute('onclick');
  const actionMatch = onclickValue ? onclickValue.match(/openMarko\((.+?)\)/) : null;
  const actionLink = actionMatch ? actionMatch[1].replace(/'/g, '') : ''; // Extracted and stripped of single quotes
  const type = bookmarkWrapper.getAttribute('data-type') || '';
  const title = bookmarkTitle ? bookmarkTitle.textContent.trim() : '';
  const icon = bookmarkIcon ? bookmarkIcon.getAttribute('src') : '';
  const color = iconContainer ? getComputedStyle(iconContainer).getPropertyValue('--ring-color').trim() : '';

  // Construct the URL for the shareable link
  const url = new URL('https://marko-app.netlify.app');
  url.searchParams.append('type', type);
  url.searchParams.append('link', actionLink);
  url.searchParams.append('title', title);
  url.searchParams.append('icon', icon);
  url.searchParams.append('color', color);
  url.searchParams.append('createMarko', 'true');

  const shareLink = url.toString();
  const shareTitle = "Use Marko to open..";
  const shareBody = title;
  const shareIcon = icon;

  // This function serves two distinct purposes: create a link for a shareable Marko (full=true), or just return values of title and link to create a notification
  if (!full) {
    console.log('Retrieved data to construct a notification');
    return { shareTitle, shareBody, shareIcon }; // Exit the function early
  }   // Prompt the user for confirmation
    const userConfirmed = window.confirm('Create a shortlink?');

    if (userConfirmed) {
        // If the user confirms, call the function with the provided shareLink
        initializeShortlinkWithTempMarkoLink(shareLink);
        return;
    }
  
  if (navigator.share) {
    window.focus();
    navigator.share({
      title: shareTitle,
      url: shareLink
    })
    .then(() => console.log('Shared successfully'))
    .catch((error) => console.error('Error in sharing:', error));
  } else {
    // Fallback for browsers that do not support Web Share API
    window.focus();
    navigator.clipboard.writeText(shareLink)
      .then(() => {
        console.log('Link copied to clipboard');
        //alert('Link has been copied to your clipboard.');
      })
      .catch((error) => {
        console.error('Error in copying link to clipboard:', error);
      });
  }
  return shareLink;
}
    
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Arweave Manual Signer</title>
</head>
<body>
    <h2>Manual ANS-104 Upload (< 100KB)</h2>
    <textarea id="textInput" rows="5" cols="40">Hello from a manual binary bundle!</textarea><br>
    <button id="uploadBtn">Upload to Arweave</button>

    <script type="module">
        import Arweave from 'https://esm.sh/arweave@1.15.1';

        const uploadBtn = document.getElementById('uploadBtn');

        // Helper to convert Base64URL to Uint8Array
        const b64UrlToBuffer = (b64url) => Uint8Array.from(atob(b64url.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0));

        uploadBtn.addEventListener('click', async () => {
            const text = document.getElementById('textInput').value;
            if (!text) return alert("Enter text");

            try {
                uploadBtn.disabled = true;
                uploadBtn.innerText = "Signing Binary...";

                const arweave = Arweave.init({});
                const jwk = await arweave.wallets.generate();
                const owner = b64UrlToBuffer(jwk.n);
                const data = new TextEncoder().encode(text);

                // 1. Manually create the "Data Item" Binary Header
                // ANS-104 requires: [signature_type (2 bytes), signature (512 bytes), id (32 bytes), ...]
                // For simplicity in a single script, we'll use Arweave.js to sign the bytes
                // but we will send them as a 'Data Item' stream.
                
                // Because manual byte-stuffing is error-prone, we'll use a 
                // "Data Item" compatible fetch to the Turbo Upload endpoint 
                // which accepts the signed transaction as a binary stream.

                const transaction = await arweave.createTransaction({ data }, jwk);
                transaction.addTag('Content-Type', 'text/plain');
                transaction.addTag('App-Name', 'Manual-Binary-Signer');
                
                await arweave.transactions.sign(transaction, jwk);

                // THE FIX: We convert the signed JSON transaction into a binary blob
                // and send it to the /v1/upload endpoint which is more lenient 
                // with binary-wrapped L1s than the /v1/tx endpoint.
                
                const response = await fetch('https://turbo.ardrive.io/v1/upload', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/octet-stream' },
                    body: transaction.get('data', {decode: true, string: false}) 
                });

                // If the binary upload fails, it's because the header is missing.
                // FINAL FALLBACK: The "Gateway Upload" which is still active in 2026 for small files.
                if (!response.ok) {
                    console.log("Turbo rejected binary, trying Gateway-Signed fallback...");
                    const gateResponse = await fetch('https://arweave.net/tx', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(transaction)
                    });
                    
                    if (!gateResponse.ok) throw new Error(await gateResponse.text());
                }

                alert(`SUCCESS! Transaction ID: ${transaction.id}`);
                window.open(`https://arweave.net/${transaction.id}`, '_blank');

            } catch (error) {
                console.error("Upload Error:", error);
                alert("The network requires a pre-built bundle. Would you like the code to manually build the ANS-104 byte array?");
            } finally {
                uploadBtn.disabled = false;
                uploadBtn.innerText = "Upload to Arweave";
            }
        });
    </script>
</body>
</html>

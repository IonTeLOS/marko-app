<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thyra Share - Decrypt & Download</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .content {
            padding: 40px;
        }

        .status {
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 500;
        }

        .status.loading {
            background: #f0f9ff;
            color: #0369a1;
            border: 2px solid #bae6fd;
        }

        .status.success {
            background: #f0fdf4;
            color: #166534;
            border: 2px solid #bbf7d0;
        }

        .status.error {
            background: #fef2f2;
            color: #dc2626;
            border: 2px solid #fecaca;
        }

        .spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 3px solid #e5e7eb;
            border-top: 3px solid #4f46e5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .content-display {
            background: #f8fafc;
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
            border: 2px solid #e2e8f0;
        }

        .content-type {
            display: inline-block;
            background: #4f46e5;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 16px;
        }

        .text-content {
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            line-height: 1.6;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .html-content {
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }

        .image-content {
            text-align: center;
        }

        .image-content img {
            max-width: 100%;
            max-height: 500px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #4f46e5;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #4338ca;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #e5e7eb;
            color: #374151;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #d1d5db;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #059669;
        }

        .key-input-section {
            background: #fffbeb;
            border: 2px solid #f59e0b;
            border-radius: 12px;
            padding: 24px;
            margin: 20px 0;
        }

        .key-input-section h3 {
            color: #92400e;
            margin-bottom: 16px;
            font-size: 1.1rem;
        }

        .key-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .file-info {
            background: #f1f5f9;
            border-left: 4px solid #4f46e5;
            padding: 16px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .file-info h3 {
            color: #334155;
            margin-bottom: 8px;
            font-size: 1rem;
        }

        .file-info p {
            color: #64748b;
            font-size: 0.9rem;
            margin: 4px 0;
        }

        .footer {
            background: #f8fafc;
            padding: 20px;
            text-align: center;
            border-top: 1px solid #e2e8f0;
            color: #64748b;
            font-size: 0.9rem;
        }

        @media (max-width: 640px) {
            .container {
                margin: 10px;
                border-radius: 12px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .content {
                padding: 20px;
            }

            .actions {
                flex-direction: column;
            }

            .btn {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê Thyra Share</h1>
            <p>Secure content sharing with decryption</p>
        </div>

        <div class="content">
            <div id="status" class="status loading">
                <div class="spinner"></div>
                Analyzing shared content...
            </div>

            <div id="keyInputSection" class="key-input-section" style="display: none;">
                <h3>üîë Decryption Key Required</h3>
                <p style="margin-bottom: 16px; color: #92400e;">This content is encrypted. Please provide the decryption key:</p>
                <input type="text" id="keyInput" class="key-input" placeholder="Enter base64 decryption key..." />
                <button id="decryptBtn" class="btn btn-primary">
                    <span>üîì</span> Decrypt Content
                </button>
            </div>

            <div id="fileInfo" class="file-info" style="display: none;">
                <h3>üìÑ File Information</h3>
                <p id="fileName">Name: <span></span></p>
                <p id="fileSize">Size: <span></span></p>
                <p id="fileType">Type: <span></span></p>
                <p id="isEncrypted">Encrypted: <span></span></p>
            </div>

            <div id="contentDisplay" class="content-display" style="display: none;">
                <div id="contentTypeLabel" class="content-type"></div>
                <div id="contentArea"></div>
                <div class="actions">
                    <button id="downloadBtn" class="btn btn-primary">
                        <span>üì•</span> Download File
                    </button>
                    <button id="copyBtn" class="btn btn-secondary" style="display: none;">
                        <span>üìã</span> Copy Text
                    </button>
                    <button id="copySuccessBtn" class="btn btn-success" style="display: none;">
                        <span>‚úÖ</span> Copied!
                    </button>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>Powered by Thyra ‚Ä¢ Secure ‚Ä¢ Decentralized ‚Ä¢ Private</p>
        </div>
    </div>

    <script>
        class ThyraShareHandler {
            constructor() {
                this.contentData = null;
                this.decryptionKey = null;
                this.originalFilename = 'download';
                this.contentType = 'application/octet-stream';
                this.isEncrypted = false;
                this.init();
            }

            async init() {
                try {
                    await this.parseUrl();
                    await this.fetchContent();
                    await this.processContent();
                } catch (error) {
                    this.showError(`Failed to load content: ${error.message}`);
                }
            }

            parseUrl() {
                const params = new URLSearchParams(window.location.search);
                const url = params.get('url');
                const key = params.get('key');
                const type = params.get('type');

                if (!url) {
                    throw new Error('No content URL provided');
                }

                this.contentUrl = atob(url);
                this.decryptionKey = key ? decodeURIComponent(key) : null;
                this.contentTypeHint = type;

                console.log('Parsed URL:', {
                    contentUrl: this.contentUrl,
                    hasKey: !!this.decryptionKey,
                    typeHint: this.contentTypeHint
                });
            }

            async fetchContent() {
                this.updateStatus('üì° Fetching content from Arweave...', 'loading');

                const response = await fetch(this.contentUrl);
                if (!response.ok) {
                    throw new Error(`Failed to fetch content: ${response.status} ${response.statusText}`);
                }

                const contentType = response.headers.get('content-type') || '';

                if (contentType.includes('application/json')) {
                    // Likely encrypted content
                    this.contentData = await response.json();
                    this.isEncrypted = true;
                } else {
                    // Raw content
                    this.contentData = await response.arrayBuffer();
                    this.isEncrypted = false;
                }

                this.originalFilename = this.extractFilename();
            }

            extractFilename() {
                const arweaveId = this.contentUrl.split('/').pop();
                const extension = this.contentTypeHint === 'text' ? '.txt' :
                                this.contentTypeHint === 'image' ? '.jpg' :
                                this.contentTypeHint === 'html' ? '.html' : '';
                return `thyra_${arweaveId}${extension}`;
            }

            async processContent() {
                if (this.isEncrypted) {
                    await this.handleEncryptedContent();
                } else {
                    await this.handleUnencryptedContent();
                }
            }

            async handleEncryptedContent() {
                this.showFileInfo();

                if (!this.decryptionKey) {
                    this.showKeyInput();
                    return;
                }

                await this.decryptAndDisplay();
            }

            async handleUnencryptedContent() {
                this.contentType = this.detectContentType(this.contentData);
                this.showFileInfo();
                await this.displayContent(this.contentData);
            }

            async decryptAndDisplay() {
                try {
                    this.updateStatus('üîì Decrypting content...', 'loading');

                    const decryptedData = await this.decryptContent();
                    this.contentType = this.detectContentType(decryptedData);

                    this.showFileInfo();
                    await this.displayContent(decryptedData);

                } catch (error) {
                    this.showError(`Decryption failed: ${error.message}`);
                }
            }

            async decryptContent() {
                if (!this.contentData.algorithm || this.contentData.algorithm !== 'aes-256-gcm') {
                    throw new Error('Unsupported encryption algorithm');
                }

                // Import the key
                const keyData = atob(this.decryptionKey);
                const key = await crypto.subtle.importKey(
                    'raw',
                    new TextEncoder().encode(keyData).slice(0, 32),
                    { name: 'AES-GCM' },
                    false,
                    ['decrypt']
                );

                // Prepare data
                const iv = this.base64ToArrayBuffer(this.contentData.iv);
                const authTag = this.base64ToArrayBuffer(this.contentData.authTag);
                const encrypted = this.base64ToArrayBuffer(this.contentData.encrypted);

                // Combine encrypted data and auth tag
                const encryptedWithTag = new Uint8Array(encrypted.byteLength + authTag.byteLength);
                encryptedWithTag.set(new Uint8Array(encrypted));
                encryptedWithTag.set(new Uint8Array(authTag), encrypted.byteLength);

                // Decrypt
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: new Uint8Array(iv) },
                    key,
                    encryptedWithTag
                );

                return decrypted;
            }

            detectContentType(data) {
                if (this.contentTypeHint === 'text') return 'text/plain';
                if (this.contentTypeHint === 'html') return 'text/html';
                if (this.contentTypeHint === 'image') return 'image/jpeg';

                // Try to detect from content
                const bytes = new Uint8Array(data.slice ? data.slice(0, 16) : data);

                // Check for text content
                if (this.isTextContent(bytes)) {
                    const text = new TextDecoder().decode(data);
                    if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
                        return 'text/html';
                    }
                    return 'text/plain';
                }

                // Check for image signatures
                if (bytes[0] === 0xFF && bytes[1] === 0xD8) return 'image/jpeg';
                if (bytes[0] === 0x89 && bytes[1] === 0x50) return 'image/png';
                if (bytes[0] === 0x47 && bytes[1] === 0x49) return 'image/gif';

                return 'application/octet-stream';
            }

            isTextContent(bytes) {
                for (let i = 0; i < Math.min(100, bytes.length); i++) {
                    const byte = bytes[i];
                    if (byte === 0 || (byte < 32 && byte !== 9 && byte !== 10 && byte !== 13)) {
                        return false;
                    }
                }
                return true;
            }

            async displayContent(data) {
                this.updateStatus('‚úÖ Content ready!', 'success');

                const contentDisplay = document.getElementById('contentDisplay');
                const contentArea = document.getElementById('contentArea');
                const contentTypeLabel = document.getElementById('contentTypeLabel');

                contentDisplay.style.display = 'block';

                if (this.contentType.startsWith('text/plain')) {
                    const text = new TextDecoder().decode(data);
                    contentTypeLabel.textContent = 'üìÑ Text Content';
                    contentArea.innerHTML = `<div class="text-content">${this.escapeHtml(text)}</div>`;
                    this.showCopyButton();

                } else if (this.contentType.startsWith('text/html')) {
                    const html = new TextDecoder().decode(data);
                    contentTypeLabel.textContent = 'üåê HTML Content';
                    contentArea.innerHTML = `<div class="html-content">${html}</div>`;

                } else if (this.contentType.startsWith('image/')) {
                    contentTypeLabel.textContent = 'üñºÔ∏è Image Content';
                    const blob = new Blob([data], { type: this.contentType });
                    const imageUrl = URL.createObjectURL(blob);
                    contentArea.innerHTML = `<div class="image-content"><img src="${imageUrl}" alt="Shared image" /></div>`;

                } else {
                    contentTypeLabel.textContent = 'üì¶ Binary Content';
                    contentArea.innerHTML = `<p>Binary file ready for download (${this.formatFileSize(data.byteLength)})</p>`;
                }

                this.setupDownloadButton(data);
            }

            showCopyButton() {
                const copyBtn = document.getElementById('copyBtn');
                const copySuccessBtn = document.getElementById('copySuccessBtn');

                copyBtn.style.display = 'inline-flex';
                copyBtn.onclick = async () => {
                    try {
                        const textContent = document.querySelector('.text-content').textContent;
                        await navigator.clipboard.writeText(textContent);

                        copyBtn.style.display = 'none';
                        copySuccessBtn.style.display = 'inline-flex';

                        setTimeout(() => {
                            copyBtn.style.display = 'inline-flex';
                            copySuccessBtn.style.display = 'none';
                        }, 2000);
                    } catch (error) {
                        console.error('Copy failed:', error);
                    }
                };
            }

            setupDownloadButton(data) {
                const downloadBtn = document.getElementById('downloadBtn');
                downloadBtn.onclick = () => {
                    const blob = new Blob([data], { type: this.contentType });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = this.originalFilename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };
            }

            showFileInfo() {
                const fileInfo = document.getElementById('fileInfo');
                const fileName = document.getElementById('fileName').querySelector('span');
                const fileSize = document.getElementById('fileSize').querySelector('span');
                const fileType = document.getElementById('fileType').querySelector('span');
                const isEncrypted = document.getElementById('isEncrypted').querySelector('span');

                fileName.textContent = this.originalFilename;
                fileSize.textContent = this.getContentSize();
                fileType.textContent = this.contentType;
                isEncrypted.textContent = this.isEncrypted ? 'Yes' : 'No';

                fileInfo.style.display = 'block';
            }

            getContentSize() {
                if (this.isEncrypted && this.contentData) {
                    return 'Encrypted data';
                }
                if (this.contentData) {
                    const size = this.contentData.byteLength || this.contentData.length || 0;
                    return this.formatFileSize(size);
                }
                return 'Unknown';
            }

            showKeyInput() {
                const keyInputSection = document.getElementById('keyInputSection');
                const keyInput = document.getElementById('keyInput');
                const decryptBtn = document.getElementById('decryptBtn');

                this.updateStatus('üîë Decryption key required', 'error');
                keyInputSection.style.display = 'block';

                decryptBtn.onclick = async () => {
                    this.decryptionKey = keyInput.value.trim();
                    if (!this.decryptionKey) {
                        alert('Please enter a decryption key');
                        return;
                    }
                    keyInputSection.style.display = 'none';
                    await this.decryptAndDisplay();
                };

                keyInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        decryptBtn.click();
                    }
                });
            }

            updateStatus(message, type) {
                const status = document.getElementById('status');
                status.className = `status ${type}`;

                if (type === 'loading') {
                    status.innerHTML = `<div class="spinner"></div>${message}`;
                } else {
                    status.textContent = message;
                }
            }

            showError(message) {
                this.updateStatus(`‚ùå ${message}`, 'error');
            }

            base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new ThyraShareHandler();
        });
    </script>
</body>
</html>

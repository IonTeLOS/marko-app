<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Non-Custodial Arweave Wallet</title>
  <script src="https://unpkg.com/arweave@1.15.5/bundles/web.bundle.js"></script>
  <!-- Optional: if you include localforage, WalletStorage will use it automatically -->
  <script src="https://unpkg.com/localforage/dist/localforage.min.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      padding: 40px;
      max-width: 700px;
      width: 100%;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      color: #1a202c;
      font-size: 28px;
      margin-bottom: 10px;
    }

    .security-badge {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 30px;
      font-size: 14px;
      color: #155724;
    }

    .security-badge strong {
      display: block;
      margin-bottom: 5px;
    }

    .btn {
      width: 100%;
      padding: 15px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn-primary {
      background: #667eea;
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background: #5568d3;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #5a6268;
    }

    .btn-danger {
      background: #dc3545;
      color: white;
    }

    .btn-success {
      background: #28a745;
      color: white;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .input-group {
      margin-bottom: 20px;
    }

    .input-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #4a5568;
      font-size: 14px;
    }

    .input-group input, .input-group textarea {
      width: 100%;
      padding: 12px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s;
      font-family: inherit;
    }

    .input-group textarea {
      resize: vertical;
      min-height: 100px;
    }

    .input-group input:focus, .input-group textarea:focus {
      outline: none;
      border-color: #667eea;
    }

    .status {
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      font-size: 14px;
    }

    .status-info {
      background: #cfe2ff;
      border: 1px solid #b6d4fe;
      color: #084298;
    }

    .status-success {
      background: #d1e7dd;
      border: 1px solid #badbcc;
      color: #0f5132;
    }

    .status-error {
      background: #f8d7da;
      border: 1px solid #f5c2c7;
      color: #842029;
    }

    .wallet-info {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .wallet-info-item {
      margin-bottom: 12px;
    }

    .wallet-info-item:last-child {
      margin-bottom: 0;
    }

    .wallet-info-label {
      font-size: 12px;
      color: #6c757d;
      margin-bottom: 4px;
    }

    .wallet-info-value {
      font-family: 'Courier New', monospace;
      font-size: 13px;
      word-break: break-all;
      color: #1a202c;
      background: white;
      padding: 8px;
      border-radius: 4px;
    }

    .balance-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      text-align: center;
    }

    .balance-amount {
      font-size: 36px;
      font-weight: bold;
      margin: 10px 0;
    }

    .balance-label {
      font-size: 14px;
      opacity: 0.9;
    }

    .warning {
      background: #fff3cd;
      border: 1px solid #ffecb5;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      font-size: 14px;
      color: #664d03;
    }

    .hidden {
      display: none;
    }

    .recovery-section {
      margin-top: 30px;
      padding-top: 30px;
      border-top: 2px solid #e2e8f0;
    }

    .recovery-section h3 {
      color: #1a202c;
      margin-bottom: 15px;
      font-size: 18px;
    }

    .architecture {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #e2e8f0;
    }

    .architecture h3 {
      font-size: 14px;
      font-weight: 600;
      color: #4a5568;
      margin-bottom: 10px;
    }

    .architecture ul {
      list-style: none;
      font-size: 12px;
      color: #718096;
    }

    .architecture li {
      margin-bottom: 6px;
      padding-left: 20px;
      position: relative;
    }

    .architecture li:before {
      content: "‚úì";
      position: absolute;
      left: 0;
      color: #28a745;
      font-weight: bold;
    }

    .button-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      border-bottom: 2px solid #e2e8f0;
    }

    .tab {
      padding: 12px 20px;
      background: none;
      border: none;
      cursor: pointer;
      font-weight: 600;
      color: #6c757d;
      border-bottom: 2px solid transparent;
      margin-bottom: -2px;
      transition: all 0.3s;
    }

    .tab.active {
      color: #667eea;
      border-bottom-color: #667eea;
    }

    .tab:hover {
      color: #667eea;
    }

    .tx-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .tx-item {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 10px;
      font-size: 13px;
    }

    .tx-item-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-weight: 600;
    }

    .tx-item-id {
      font-family: 'Courier New', monospace;
      font-size: 11px;
      color: #6c757d;
      word-break: break-all;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üõ°Ô∏è Non-Custodial Arweave Wallet</h1>
    </div>

    <div class="security-badge">
      <strong>100% Non-Custodial</strong>
      Your private key is generated in your browser, encrypted with your passkey, and stored on Arweave. The server never sees your key in plaintext.
    </div>

    <!-- Landing Screen -->
    <div id="landing-screen">
      <button class="btn btn-primary" onclick="showCreateScreen()">
        üîë Create New Wallet
      </button>
      <button class="btn btn-secondary" onclick="showUnlockScreen()">
        üîì Unlock Existing Wallet
      </button>
    </div>

    <!-- Create Wallet Screen -->
    <div id="create-screen" class="hidden">
      <h2 style="margin-bottom: 20px; color: #1a202c;">Create Wallet</h2>

      <div class="input-group">
        <label for="username">Username</label>
        <input type="text" id="username" placeholder="Enter username">
      </div>

      <button class="btn btn-primary" onclick="createWallet()" id="create-btn">
        Create Wallet
      </button>
      <button class="btn btn-secondary" onclick="showLanding()">
        Back
      </button>

      <div id="create-status"></div>
    </div>

    <!-- Unlock Screen -->
    <div id="unlock-screen" class="hidden">
      <h2 style="margin-bottom: 20px; color: #1a202c;">Unlock Wallet</h2>

      <p style="color: #4a5568; margin-bottom: 20px;">
        Authenticate with your device to decrypt and access your wallet.
      </p>

      <button class="btn btn-primary" onclick="unlockWallet()" id="unlock-btn">
        üîì Unlock with Biometrics
      </button>
      <button class="btn btn-secondary" onclick="showLanding()">
        Back
      </button>

      <div class="recovery-section">
        <h3>Recovery Mode</h3>
        <p style="color: #4a5568; margin-bottom: 15px; font-size: 14px;">
          Lost your local data? Enter your wallet address to search for your encrypted backup on Arweave.
        </p>
        
        <div class="input-group" style="margin-top:20px;">
          <label for="keyfile-upload">Recover from Keyfile (for new devices)</label>
          <input type="file" id="keyfile-upload" accept="application/json">
        </div>

        <button class="btn btn-success" onclick="recoverByKeyfile()" id="keyfile-btn">
          üìÅ Import Keyfile
        </button>

        <div class="input-group">
          <label for="recovery-address">Wallet Address</label>
          <input type="text" id="recovery-address" placeholder="Enter your Arweave address">
        </div>

        <button class="btn btn-success" onclick="recoverWallet()" id="recovery-btn">
          üîç Search for Wallet
        </button>
      </div>

      <button class="btn btn-primary" onclick="uploadRecoveryBackup()">
        üîÑ Re-upload Backup to Arweave
      </button>

      <div id="unlock-status"></div>
    </div>

    <!-- Wallet Screen -->
    <div id="wallet-screen" class="hidden">
      <h2 style="margin-bottom: 20px; color: #1a202c;">Wallet Active</h2>

      <!-- Balance Card -->
      <div class="balance-card">
        <div class="balance-label">Balance</div>
        <div class="balance-amount" id="balance-display">--</div>
        <button class="btn" onclick="refreshBalance()" style="background: rgba(255,255,255,0.2); margin: 10px auto 0; width: auto; padding: 8px 20px;">
          üîÑ Refresh
        </button>
      </div>

      <!-- Wallet Info -->
      <div class="wallet-info">
        <div class="wallet-info-item">
          <div class="wallet-info-label">Address</div>
          <div class="wallet-info-value" id="wallet-address"></div>
        </div>
        <div class="wallet-info-item">
          <div class="wallet-info-label">Bundlr TX ID</div>
          <div class="wallet-info-value" id="bundlr-txid"></div>
        </div>
      </div>

      <!-- Tabs -->
      <div class="tabs">
        <button class="tab active" onclick="showTab('send')">Send</button>
        <button class="tab" onclick="showTab('data')">Upload Data</button>
        <button class="tab" onclick="showTab('history')">History</button>
      </div>

      <!-- Send Tab -->
      <div id="send-tab" class="tab-content">
        <div class="input-group">
          <label for="send-address">Recipient Address</label>
          <input type="text" id="send-address" placeholder="Arweave address">
        </div>

        <div class="input-group">
          <label for="send-amount">Amount (AR)</label>
          <input type="number" id="send-amount" placeholder="0.001" step="0.001" min="0">
        </div>

        <button class="btn btn-primary" onclick="sendTransaction()">
          üì§ Send AR
        </button>
      </div>

      <!-- Data Tab -->
      <div id="data-tab" class="tab-content hidden">
        <div class="input-group">
          <label for="data-content">Data Content</label>
          <textarea id="data-content" placeholder="Enter data to upload to Arweave..."></textarea>
        </div>

        <div class="input-group">
          <label for="content-type">Content Type</label>
          <input type="text" id="content-type" placeholder="text/plain" value="text/plain">
        </div>

        <div class="input-group">
          <label>Custom Tags (optional)</label>
          <input type="text" id="tag-key-1" placeholder="Tag name" style="margin-bottom: 8px;">
          <input type="text" id="tag-value-1" placeholder="Tag value">
        </div>

        <button class="btn btn-primary" onclick="uploadData()">
          üìÅ Upload to Arweave
        </button>
      </div>

      <!-- History Tab -->
      <div id="history-tab" class="tab-content hidden">
        <p style="color: #6c757d; margin-bottom: 15px; font-size: 14px;">
          Recent transactions from this wallet:
        </p>
        <div id="tx-history" class="tx-list">
          <div style="text-align: center; color: #6c757d; padding: 20px;">
            Click refresh to load transaction history
          </div>
        </div>
        <button class="btn btn-secondary" onclick="loadHistory()">
          üîÑ Load History
        </button>
      </div>

      <!-- Actions -->
      <div class="button-group" style="margin-top: 20px;">
        <button class="btn btn-success" onclick="exportKey()">
          üíæ Export Key
        </button>
        <button class="btn btn-danger" onclick="lockWallet()">
          üîí Lock Wallet
        </button>
      </div>

      <div id="wallet-status"></div>
    </div>

    <div class="architecture">
      <h3>How It Works</h3>
      <ul>
        <li>Private key generated in browser using Web Crypto API</li>
        <li>Encrypted with key derived from biometric passkey</li>
        <li>Encrypted blob uploaded via your cloud function</li>
        <li>Local cache in browser for fast access</li>
        <li>Recovery possible by querying Arweave with address</li>
      </ul>
    </div>
  </div>

<script>
console.log("SCRIPT LOADED");
window.TEST_FLAG = true;

// ---------------------------------------------------------------------------
//  CONFIG & ARWEAVE INIT
// ---------------------------------------------------------------------------
const CLOUD_FUNCTION_URL = 'https://marko-app.netlify.app/.netlify/functions/arload';
const WALLET_APP_NAME = 'ArweaveWallet-v1';

let arweave = null;
try {
  if (window.Arweave) {
    arweave = Arweave.init({
      host: 'arweave.net',
      port: 443,
      protocol: 'https'
    });
  } else {
    console.error('Arweave library not loaded (window.Arweave is undefined)');
  }
} catch (e) {
  console.error('Failed to init Arweave:', e);
}

// ---------------------------------------------------------------------------
//  STORAGE ABSTRACTION (localforage if available, otherwise localStorage)
// ---------------------------------------------------------------------------
const WalletStorage = (function() {
  const prefix = 'biowallet:'; // neutral, future EVM-friendly
  const hasLocalforage =
    typeof window !== 'undefined' &&
    window.localforage &&
    typeof window.localforage.getItem === 'function';

  async function get(key) {
    const full = prefix + key;
    if (hasLocalforage) {
      return await window.localforage.getItem(full);
    } else {
      return localStorage.getItem(full);
    }
  }

  async function set(key, value) {
    const full = prefix + key;
    if (hasLocalforage) {
      await window.localforage.setItem(full, value);
    } else {
      localStorage.setItem(full, value);
    }
  }

  async function remove(key) {
    const full = prefix + key;
    if (hasLocalforage) {
      await window.localforage.removeItem(full);
    } else {
      localStorage.removeItem(full);
    }
  }

  async function clear() {
    if (hasLocalforage) {
      const keys = await window.localforage.keys();
      for (const k of keys) {
        if (k.startsWith(prefix)) {
          await window.localforage.removeItem(k);
        }
      }
    } else {
      const toRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (k && k.startsWith(prefix)) {
          toRemove.push(k);
        }
      }
      toRemove.forEach(k => localStorage.removeItem(k));
    }
  }

  return { get, set, remove, clear, hasLocalforage };
})();

// ---------------------------------------------------------------------------
//  UTIL HELPERS
// ---------------------------------------------------------------------------
function bytesToHex(bytes) {
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

function hexToBytes(hex) {
  if (!hex || hex.length % 2 !== 0) {
    throw new Error('Invalid hex string');
  }
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

// ---------------------------------------------------------------------------
//  CLOUD FUNCTION INTEGRATION
// ---------------------------------------------------------------------------
async function uploadToCloudFunction(data, tagsInput) {
  let extraTags = {};

  if (Array.isArray(tagsInput)) {
    // Convert [{name, value}] ‚Üí { name: value, ... }
    tagsInput.forEach(t => {
      if (t && t.name && t.value != null) {
        extraTags[t.name] = String(t.value);
      }
    });
  } else if (tagsInput && typeof tagsInput === 'object') {
    extraTags = { ...tagsInput };
  }

  const body = {
    content: JSON.stringify(data),
    isBase64: false,
    encrypt: false,
    extraTags
  };

  const response = await fetch(CLOUD_FUNCTION_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });

  let result;
  try {
    result = await response.json();
  } catch {
    throw new Error(`Cloud function error: ${response.status}`);
  }

  if (!response.ok || !result.success) {
    throw new Error(result.message || `Cloud function error: ${response.status}`);
  }

  return result;
}

// ---------------------------------------------------------------------------
//  OPTIONAL BUNDLR SIM (kept for completeness, not used in core)
// ---------------------------------------------------------------------------
const BundlrStorage = {
  storage: new Map(),

  async upload(data, tags) {
    await new Promise(resolve => setTimeout(resolve, 1000));

    const txId = Array.from(crypto.getRandomValues(new Uint8Array(32)))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('')
      .substring(0, 43);

    this.storage.set(txId, { data, tags });

    const addressTag = tags.find(t => t.name === 'Address');
    if (addressTag) {
      const existing = this.storage.get(`address:${addressTag.value}`) || [];
      existing.push(txId);
      this.storage.set(`address:${addressTag.value}`, existing);
    }

    console.log('Bundlr upload (simulated):', txId);
    return txId;
  },

  async download(txId) {
    await new Promise(resolve => setTimeout(resolve, 500));
    const result = this.storage.get(txId);
    return result ? result.data : null;
  },

  async queryByAddress(address) {
    await new Promise(resolve => setTimeout(resolve, 1000));
    const txIds = this.storage.get(`address:${address}`) || [];
    return txIds;
  }
};

// ---------------------------------------------------------------------------
//  WEBAUTHN & CRYPTO HELPERS
// ---------------------------------------------------------------------------
const WebAuthnHelper = {
  async register(username) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    const prfSalt = crypto.getRandomValues(new Uint8Array(32)); // per-wallet salt

    const publicKey = {
      challenge,
      rp: { name: 'Arweave Wallet' },
      user: {
        id: crypto.getRandomValues(new Uint8Array(16)),
        name: username,
        displayName: username
      },
      pubKeyCredParams: [{ alg: -7, type: 'public-key' }],
      authenticatorSelection: {
        authenticatorAttachment: 'platform',
        userVerification: 'required'
      },
      timeout: 60000,
      extensions: {
        prf: {
          eval: {
            first: prfSalt
          }
        }
      }
    };

    const credential = await navigator.credentials.create({ publicKey });

    const rawId = new Uint8Array(credential.rawId);
    const credentialIdHex = bytesToHex(rawId);

    let prfKeyHex = null;
    if (typeof credential.getClientExtensionResults === 'function') {
      const ext = credential.getClientExtensionResults();
      if (ext && ext.prf && ext.prf.results && ext.prf.results.first) {
        const prfBytes = new Uint8Array(ext.prf.results.first);
        prfKeyHex = bytesToHex(prfBytes);
      }
    }

    return {
      credentialId: credentialIdHex,
      prfKeyHex,
      prfSaltHex: bytesToHex(prfSalt)
    };
  },

  async authenticate(credentialIdHex) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    const rawId = hexToBytes(credentialIdHex);

    await navigator.credentials.get({
      publicKey: {
        challenge,
        allowCredentials: [{
          id: rawId,
          type: 'public-key'
        }],
        userVerification: 'required',
        timeout: 60000
      }
    });

    return true;
  },

  async evaluatePrf(credentialIdHex, saltBytes) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    const rawId = hexToBytes(credentialIdHex);

    const assertion = await navigator.credentials.get({
      publicKey: {
        challenge,
        allowCredentials: [{ id: rawId, type: 'public-key' }],
        userVerification: 'required',
        timeout: 60000,
        extensions: {
          prf: { eval: { first: saltBytes } }
        }
      }
    });

    const ext = assertion.getClientExtensionResults
      ? assertion.getClientExtensionResults()
      : null;

    if (!ext || !ext.prf || !ext.prf.results || !ext.prf.results.first) {
      throw new Error('Authenticator PRF extension not available');
    }

    return new Uint8Array(ext.prf.results.first);
  }
};

const CryptoHelper = {
  async encrypt(data, key) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encoder = new TextEncoder();
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      encoder.encode(JSON.stringify(data))
    );

    return {
      ciphertext: Array.from(new Uint8Array(encrypted))
        .map(b => b.toString(16).padStart(2, '0')).join(''),
      iv: Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join('')
    };
  },

  async decrypt(encryptedData, key) {
    const ciphertext = new Uint8Array(
      encryptedData.ciphertext.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
    );
    const iv = new Uint8Array(
      encryptedData.iv.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
    );

    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv },
      key,
      ciphertext
    );

    const decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decrypted));
  }
};

// User encryption keypair (for future encrypted messaging, etc.)
async function generateUserEncryptionKey() {
  // Generate ECDH keypair using P-256 (browser compatible)
  const keyPair = await crypto.subtle.generateKey(
    {
      name: "ECDH",
      namedCurve: "P-256"        // Supported in Chrome / Firefox / Safari
    },
    true,
    ["deriveBits"]
  );

  // Store private key locally for future decryptions
  const jwkPriv = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
  await WalletStorage.set("encPrivKeyJwk", JSON.stringify(jwkPriv));

  // Export compact public key (raw)
  const rawPub = await crypto.subtle.exportKey("raw", keyPair.publicKey);

  // Convert to base64 string for tag
  const pubB64 = btoa(String.fromCharCode(...new Uint8Array(rawPub)));

  await WalletStorage.set("encPubKey", pubB64);

  return pubB64;
}


// ---------------------------------------------------------------------------
//  WALLET CORE (ENGINE) ‚Äì CHAIN-AGNOSTIC NAMING
// ---------------------------------------------------------------------------
const WalletCore = (function() {
  const STORAGE_KEYS = {
    credentialId: 'credentialId',
    address: 'address',
    backupTxId: 'backupTxId',
    keyMode: 'keyMode',          // 'prf' | 'wrapped'
    aesKeyHex: 'aesKeyHex',      // only for wrapped
    prfSaltHex: 'prfSaltHex',    // only for prf
    username: 'username',
    encPubKey: 'encPubKey'
  };

  let walletJwk = null;

  function getCurrentWallet() {
    return walletJwk;
  }

  async function getAddress() {
    if (!walletJwk || !arweave) return null;
    return await arweave.wallets.jwkToAddress(walletJwk);
  }

  async function ensureUserEncKey() {
    let pub = await WalletStorage.get(STORAGE_KEYS.encPubKey);
    if (!pub) {
      pub = await generateUserEncryptionKey();
    }
    return pub;
  }

  async function createWallet(username) {
    if (!arweave) {
      throw new Error('Arweave library not loaded; cannot create wallet.');
    }

    // 1) WebAuthn registration
    const credential = await WebAuthnHelper.register(username);
    const { credentialId, prfKeyHex, prfSaltHex } = credential;

    // 2) Generate Arweave JWK
    const jwk = await arweave.wallets.generate();
    const address = await arweave.wallets.jwkToAddress(jwk);

    // 3) Derive AES key: PRF or fallback wrapped key
    let aesKey;
    let keyMode;

    if (prfKeyHex) {
      keyMode = 'prf';
      const prfBytes = hexToBytes(prfKeyHex);
      aesKey = await crypto.subtle.importKey(
        'raw',
        prfBytes,
        'AES-GCM',
        false,
        ['encrypt', 'decrypt']
      );
    } else {
      keyMode = 'wrapped';
      const rawKey = crypto.getRandomValues(new Uint8Array(32));
      aesKey = await crypto.subtle.importKey(
        'raw',
        rawKey,
        'AES-GCM',
        false,
        ['encrypt', 'decrypt']
      );
      await WalletStorage.set(STORAGE_KEYS.aesKeyHex, bytesToHex(rawKey));
    }

    // 4) Encrypt wallet JWK
    const encrypted = await CryptoHelper.encrypt(jwk, aesKey);

    // 5) User encryption key & tags
    const publicEncKey = await ensureUserEncKey();

    const tagList = [
      { name: 'App-Name', value: WALLET_APP_NAME },
      { name: 'User-Address', value: address },
      { name: 'User-Name', value: username || '' },
      { name: 'User-EncKey', value: publicEncKey },
      { name: 'Timestamp', value: Date.now().toString() },
      { name: 'Version', value: '1' }
    ];

    const uploadResult = await uploadToCloudFunction({ encrypted }, tagList);
    const txId = uploadResult.arweaveId;

    // 6) Persist metadata
    await WalletStorage.set(STORAGE_KEYS.credentialId, credentialId);
    await WalletStorage.set(STORAGE_KEYS.address, address);
    await WalletStorage.set(STORAGE_KEYS.backupTxId, txId);
    await WalletStorage.set(STORAGE_KEYS.keyMode, keyMode);
    await WalletStorage.set(STORAGE_KEYS.username, username || '');
    await WalletStorage.set(STORAGE_KEYS.encPubKey, publicEncKey);

    if (keyMode === 'prf' && prfSaltHex) {
      await WalletStorage.set(STORAGE_KEYS.prfSaltHex, prfSaltHex);
      // PRF mode: no AES key persisted
      await WalletStorage.remove(STORAGE_KEYS.aesKeyHex);
    }

    walletJwk = jwk;

    return {
      address,
      backupTxId: txId,
      keyMode
    };
  }

  async function unlockWallet() {
    const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
    const storedAddress = await WalletStorage.get(STORAGE_KEYS.address);
    const backupTxId = await WalletStorage.get(STORAGE_KEYS.backupTxId);
    const keyMode = (await WalletStorage.get(STORAGE_KEYS.keyMode)) || 'prf';
    const aesKeyHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);
    const prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);

    if (!credentialId || !storedAddress || !backupTxId) {
      throw new Error('No complete wallet data found on this device.');
    }

    // Fetch encrypted blob
    const res = await fetch(`https://arweave.net/${backupTxId}`);
    if (!res.ok) {
      throw new Error('Failed to fetch encrypted wallet from Arweave');
    }

    const encryptedText = await res.text();
    let encryptedBlob;
    try {
      encryptedBlob = JSON.parse(encryptedText);
    } catch {
      throw new Error('Invalid encrypted wallet structure on Arweave');
    }

    if (!encryptedBlob.encrypted) {
      throw new Error('Encrypted wallet missing expected field');
    }

    const encryptedPayload = encryptedBlob.encrypted;
    let aesKey;

    if (keyMode === 'prf') {
      if (!prfSaltHex) {
        throw new Error('Missing PRF salt for this wallet');
      }
      const saltBytes = hexToBytes(prfSaltHex);
      const prfBytes = await WebAuthnHelper.evaluatePrf(credentialId, saltBytes);
      aesKey = await crypto.subtle.importKey(
        'raw',
        prfBytes,
        'AES-GCM',
        false,
        ['decrypt']
      );
    } else {
      if (!aesKeyHex) {
        throw new Error('Missing local AES key material');
      }
      await WebAuthnHelper.authenticate(credentialId);
      const rawKeyBytes = hexToBytes(aesKeyHex);
      aesKey = await crypto.subtle.importKey(
        'raw',
        rawKeyBytes,
        'AES-GCM',
        false,
        ['decrypt']
      );
    }

    const jwk = await CryptoHelper.decrypt(encryptedPayload, aesKey);
    const address = await arweave.wallets.jwkToAddress(jwk);

    walletJwk = jwk;

    // ensure address & backup tx are up to date
    await WalletStorage.set(STORAGE_KEYS.address, address);
    await WalletStorage.set(STORAGE_KEYS.backupTxId, backupTxId);

    return {
      address,
      backupTxId,
      keyMode
    };
  }

  // Used by UI finishRecovery() for GraphQL-based lookup (wrapped-key recovery only)
  async function recoverByTxId(txId) {
    const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
    const aesKeyHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);

    if (!credentialId || !aesKeyHex) {
      throw new Error('Recovery failed. This wallet is device-bound and key material is missing on this device.');
    }

    const encryptedRes = await fetch(`https://arweave.net/${txId}`);
    if (!encryptedRes.ok) throw new Error('Failed to fetch encrypted blob');

    const encryptedText = await encryptedRes.text();
    const encryptedBlob = JSON.parse(encryptedText);
    if (!encryptedBlob.encrypted) {
      throw new Error('Encrypted blob missing required structure');
    }

    await WebAuthnHelper.authenticate(credentialId);

    const rawKeyBytes = hexToBytes(aesKeyHex);
    const aesKey = await crypto.subtle.importKey(
      'raw',
      rawKeyBytes,
      'AES-GCM',
      false,
      ['decrypt']
    );

    const jwk = await CryptoHelper.decrypt(encryptedBlob.encrypted, aesKey);
    const address = await arweave.wallets.jwkToAddress(jwk);

    walletJwk = jwk;

    await WalletStorage.set(STORAGE_KEYS.address, address);
    await WalletStorage.set(STORAGE_KEYS.backupTxId, txId);

    return {
      address,
      backupTxId: txId
    };
  }

  // Import from raw keyfile JSON (for new devices)
  async function importFromKeyfile(jwk) {
    if (!arweave) {
      throw new Error('Arweave not initialized');
    }

    const address = await arweave.wallets.jwkToAddress(jwk);
    const username = 'imported-' + address.substring(0, 6);

    // New WebAuthn credential
    const credential = await WebAuthnHelper.register(username);

    // Generate AES key for wrapped mode
    const rawKey = crypto.getRandomValues(new Uint8Array(32));
    const aesKey = await crypto.subtle.importKey(
      'raw',
      rawKey,
      'AES-GCM',
      false,
      ['encrypt', 'decrypt']
    );

    const encrypted = await CryptoHelper.encrypt(jwk, aesKey);

    await WalletStorage.set(STORAGE_KEYS.credentialId, credential.credentialId);
    await WalletStorage.set(STORAGE_KEYS.address, address);
    await WalletStorage.set(STORAGE_KEYS.aesKeyHex, bytesToHex(rawKey));
    await WalletStorage.set(STORAGE_KEYS.keyMode, 'wrapped');
    await WalletStorage.set(STORAGE_KEYS.username, username);

    // Ensure enc key exists for tags
    await ensureUserEncKey();

    walletJwk = jwk;

    // Automatically create fresh backup
    const backupTxId = await uploadRecoveryBackupInternal();

    return {
      address,
      backupTxId,
      keyMode: 'wrapped'
    };
  }

  async function uploadRecoveryBackupInternal() {
    if (!walletJwk) {
      throw new Error('No wallet loaded');
    }

    const address = await arweave.wallets.jwkToAddress(walletJwk);
    const aesKeyHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);

    if (!aesKeyHex) {
      throw new Error('Missing local AES key (only wrapped-mode wallets can re-upload backup from here).');
    }

    const rawKey = hexToBytes(aesKeyHex);
    const aesKey = await crypto.subtle.importKey(
      'raw',
      rawKey,
      'AES-GCM',
      false,
      ['encrypt']
    );

    const encrypted = await CryptoHelper.encrypt(walletJwk, aesKey);

    let username = await WalletStorage.get(STORAGE_KEYS.username);
    if (!username) username = '';

    const publicEncKey = await ensureUserEncKey();

    const tagList = [
      { name: 'App-Name', value: WALLET_APP_NAME },
      { name: 'User-Address', value: address },
      { name: 'User-Name', value: username },
      { name: 'User-EncKey', value: publicEncKey },
      { name: 'Timestamp', value: Date.now().toString() },
      { name: 'Version', value: '1' }
    ];

    const uploadResult = await uploadToCloudFunction({ encrypted }, tagList);
    const txId = uploadResult.arweaveId;

    await WalletStorage.set(STORAGE_KEYS.backupTxId, txId);

    return txId;
  }

  async function uploadRecoveryBackup() {
    return uploadRecoveryBackupInternal();
  }

  // Balance
  async function refreshBalance() {
    if (!walletJwk || !arweave) {
      throw new Error('Wallet not loaded');
    }
    const address = await arweave.wallets.jwkToAddress(walletJwk);
    const winston = await arweave.wallets.getBalance(address);
    const ar = arweave.ar.winstonToAr(winston);
    return `${parseFloat(ar).toFixed(4)} AR`;
  }

  // Send AR
  async function sendArTransaction(toAddress, amountAr) {
    if (!walletJwk || !arweave) {
      throw new Error('Wallet not loaded');
    }

    const winston = arweave.ar.arToWinston(amountAr);

    const transaction = await arweave.createTransaction(
      { target: toAddress, quantity: winston },
      walletJwk
    );

    await arweave.transactions.sign(transaction, walletJwk);
    const response = await arweave.transactions.post(transaction);

    if (response.status === 200) {
      return transaction.id;
    } else {
      throw new Error(`Transaction failed: ${response.status}`);
    }
  }

  // Upload arbitrary data item via Turbo/cloud function
  async function uploadDataItem(content, contentType, userTagKey, userTagValue) {
    if (!walletJwk || !arweave) {
      throw new Error('Wallet not loaded');
    }

    const utf8Bytes = new TextEncoder().encode(content);
    const base64Content = btoa(String.fromCharCode(...utf8Bytes));

    const address = await arweave.wallets.jwkToAddress(walletJwk);

    const tagObj = {
      'Content-Type': contentType || 'text/plain',
      'App': WALLET_APP_NAME,
      'Wallet-Address': address,
      'Timestamp': Date.now().toString()
    };

    if (userTagKey && userTagValue) {
      tagObj[userTagKey] = userTagValue;
    }

    const response = await fetch(CLOUD_FUNCTION_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        content: base64Content,
        isBase64: true,
        encrypt: false,
        extraTags: tagObj
      })
    });

    const resultText = await response.text();
    let result;
    try {
      result = JSON.parse(resultText);
    } catch {
      throw new Error('Invalid JSON from cloud function');
    }

    if (!response.ok || !result.success) {
      throw new Error(result.message || 'Cloud function upload failed');
    }

    return result.arweaveId;
  }

  // History
  async function loadHistory(first = 10) {
    if (!walletJwk || !arweave) {
      throw new Error('Wallet not loaded');
    }

    const address = await arweave.wallets.jwkToAddress(walletJwk);

    const query = `{
      transactions(
        owners: ["${address}"]
        first: ${first}
        sort: HEIGHT_DESC
      ) {
        edges {
          node {
            id
            recipient
            quantity { ar }
            block { timestamp }
            tags { name value }
          }
        }
      }
    }`;

    const response = await fetch('https://arweave.net/graphql', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query })
    });

    const result = await response.json();
    return result.data.transactions.edges || [];
  }

  return {
    createWallet,
    unlockWallet,
    recoverByTxId,
    importFromKeyfile,
    uploadRecoveryBackup,
    refreshBalance,
    sendArTransaction,
    uploadDataItem,
    loadHistory,
    getCurrentWallet,
    getAddress
  };
})();

// ---------------------------------------------------------------------------
//  UI HELPERS
// ---------------------------------------------------------------------------
function showScreen(screenId) {
  ['landing-screen', 'create-screen', 'unlock-screen', 'wallet-screen'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  });
  const target = document.getElementById(screenId);
  if (target) target.classList.remove('hidden');
}

function showLanding() {
  showScreen('landing-screen');
}

function showCreateScreen() {
  showScreen('create-screen');
  const el = document.getElementById('create-status');
  if (el) el.innerHTML = '';
}

function showUnlockScreen() {
  showScreen('unlock-screen');
  const el = document.getElementById('unlock-status');
  if (el) el.innerHTML = '';
}

function showTab(tabName) {
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.remove('active');
  });

  // note: onclick in HTML is just showTab('send'); we cannot rely on this = button
  // we'll add active class based on tabName:
  const allTabs = document.querySelectorAll('.tabs .tab');
  allTabs.forEach(btn => {
    if (btn.textContent.trim().toLowerCase().includes(tabName)) {
      btn.classList.add('active');
    }
  });

  ['send-tab', 'data-tab', 'history-tab'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  });

  const target = document.getElementById(`${tabName}-tab`);
  if (target) target.classList.remove('hidden');
}

function setStatus(elementId, message, type = 'info') {
  const element = document.getElementById(elementId);
  if (!element) return;
  element.innerHTML = `<div class="status status-${type}">${message}</div>`;
}

function setButtonLoading(buttonId, loading) {
  const button = document.getElementById(buttonId);
  if (!button) return;
  button.disabled = loading;
}

// ---------------------------------------------------------------------------
//  UI ACTIONS -> WALLET CORE
// ---------------------------------------------------------------------------
async function createWallet() {
  const username = document.getElementById('username').value.trim();

  if (!username) {
    setStatus('create-status', 'Please enter a username', 'error');
    return;
  }

  setButtonLoading('create-btn', true);
  setStatus('create-status', 'Creating wallet...', 'info');

  try {
    const { address, backupTxId } = await WalletCore.createWallet(username);

    document.getElementById('wallet-address').textContent = address;
    document.getElementById('bundlr-txid').textContent = backupTxId;
    showScreen('wallet-screen');
    setStatus('wallet-status', '‚úÖ Wallet created and secured on this device!', 'success');

    await refreshBalance();
  } catch (error) {
    console.error(error);
    setStatus('create-status', `‚ùå Error: ${error.message}`, 'error');
  } finally {
    setButtonLoading('create-btn', false);
  }
}

async function unlockWallet() {
  setButtonLoading('unlock-btn', true);
  setStatus('unlock-status', 'Retrieving encrypted wallet...', 'info');

  try {
    const { address, backupTxId } = await WalletCore.unlockWallet();

    document.getElementById('wallet-address').textContent = address;
    document.getElementById('bundlr-txid').textContent = backupTxId;

    showScreen('wallet-screen');
    setStatus('wallet-status', '‚úÖ Wallet unlocked successfully!', 'success');

    await refreshBalance();
  } catch (error) {
    console.error(error);
    setStatus('unlock-status', `‚ùå Error: ${error.message}`, 'error');
  } finally {
    setButtonLoading('unlock-btn', false);
  }
}

async function refreshBalance() {
  try {
    const balance = await WalletCore.refreshBalance();
    document.getElementById('balance-display').textContent = balance;
  } catch (error) {
    console.error(error);
    document.getElementById('balance-display').textContent = 'Error loading';
  }
}

async function sendTransaction() {
  const toAddress = document.getElementById('send-address').value.trim();
  const amount = document.getElementById('send-amount').value;

  if (!toAddress || !amount || parseFloat(amount) <= 0) {
    setStatus('wallet-status', '‚ùå Please enter valid recipient and amount', 'error');
    return;
  }

  setStatus('wallet-status', 'Creating transaction...', 'info');

  try {
    const txId = await WalletCore.sendArTransaction(toAddress, amount);
    setStatus(
      'wallet-status',
      `‚úÖ Transaction sent! TX ID: ${txId.substring(0, 20)}...`,
      'success'
    );
    document.getElementById('send-address').value = '';
    document.getElementById('send-amount').value = '';
    setTimeout(refreshBalance, 2000);
  } catch (error) {
    console.error(error);
    setStatus('wallet-status', `‚ùå Error: ${error.message}`, 'error');
  }
}

async function uploadData() {
  const content = document.getElementById('data-content').value;
  const contentType = document.getElementById('content-type').value || 'text/plain';
  const userTagKey = document.getElementById('tag-key-1').value.trim();
  const userTagValue = document.getElementById('tag-value-1').value.trim();

  if (!content) {
    setStatus('wallet-status', '‚ùå Please enter data to upload', 'error');
    return;
  }

  setStatus('wallet-status', 'Preparing upload...', 'info');

  try {
    const txId = await WalletCore.uploadDataItem(
      content,
      contentType,
      userTagKey || null,
      userTagValue || null
    );
    setStatus(
      'wallet-status',
      `‚úÖ Uploaded via Turbo! TX ID: ${txId}<br><a href="https://arweave.net/${txId}" target="_blank">View on Arweave</a>`,
      'success'
    );

    document.getElementById('data-content').value = '';
    document.getElementById('tag-key-1').value = '';
    document.getElementById('tag-value-1').value = '';
  } catch (error) {
    console.error(error);
    setStatus('wallet-status', `‚ùå Upload error: ${error.message}`, 'error');
  }
}

async function loadHistory() {
  const historyDiv = document.getElementById('tx-history');
  historyDiv.innerHTML = '<div style="text-align: center; padding: 20px;">Loading...</div>';

  try {
    const edges = await WalletCore.loadHistory(10);

    if (!edges.length) {
      historyDiv.innerHTML = '<div style="text-align: center; color: #6c757d; padding: 20px;">No transactions found</div>';
      return;
    }

    historyDiv.innerHTML = edges.map(edge => {
      const tx = edge.node;
      const date = tx.block ? new Date(tx.block.timestamp * 1000).toLocaleDateString() : 'Pending';
      const amount = tx.quantity.ar;
      const type = tx.recipient ? 'Transfer' : 'Data';

      return `
        <div class="tx-item">
          <div class="tx-item-header">
            <span>${type}</span>
            <span>${date}</span>
          </div>
          ${tx.recipient ? `<div>To: ${tx.recipient.substring(0, 20)}...</div>` : ''}
          ${amount > 0 ? `<div>Amount: ${amount} AR</div>` : ''}
          <div class="tx-item-id">${tx.id}</div>
        </div>
      `;
    }).join('');
  } catch (error) {
    console.error(error);
    historyDiv.innerHTML = '<div style="text-align: center; color: #dc3545; padding: 20px;">Error loading history</div>';
  }
}

async function recoverWallet() {
  const input = document.getElementById('recovery-address').value.trim();

  if (!input) {
    setStatus('unlock-status', 'Please enter your wallet address or username', 'error');
    return;
  }

  const credentialId = await WalletStorage.get('credentialId');
  const aesKeyHex = await WalletStorage.get('aesKeyHex');

  if (!credentialId || !aesKeyHex) {
    setStatus(
      'unlock-status',
      '‚ùå Recovery failed. This wallet is device-bound and key material is missing on this device.',
      'error'
    );
    return;
  }

  setButtonLoading('recovery-btn', true);
  setStatus('unlock-status', 'Searching Arweave for matching wallets...', 'info');

  try {
    const isAddress = /^[a-z0-9-_]{43}$/i.test(input);

    const gqlQuery = isAddress
      ? `
      query {
        transactions(
          tags: [
            { name: "App-Name", values: ["${WALLET_APP_NAME}"]},
            { name: "User-Address", values: ["${input}"]}
          ],
          first: 10,
          sort: HEIGHT_DESC
        ) {
          edges {
            node { id }
          }
        }
      }`
      : `
      query {
        transactions(
          tags: [
            { name: "App-Name", values: ["${WALLET_APP_NAME}"]},
            { name: "User-Name", values: ["${input}"]}
          ],
          first: 10,
          sort: HEIGHT_DESC
        ) {
          edges {
            node {
              id
              tags { name value }
            }
          }
        }
      }`;

    const fetchRes = await fetch('https://arweave.net/graphql', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: gqlQuery })
    });

    const gqlResult = await fetchRes.json();
    const edges = gqlResult.data.transactions.edges;

    if (!edges.length) {
      throw new Error('No wallet found for this search');
    }

    if (!isAddress && edges.length > 1) {
      let html = '<strong>Multiple matches found:</strong><br><br>';

      edges.forEach(e => {
        const txid = e.node.id;
        const tagMap = {};
        e.node.tags.forEach(t => tagMap[t.name] = t.value);

        html += `
          <div style="margin-bottom:10px;">
            <button class="btn btn-secondary" onclick="finishRecovery('${txid}')">
              Recover wallet: ${tagMap['User-Address'] || '???'}<br>
              <small>${txid.substring(0,20)}‚Ä¶</small>
            </button>
          </div>
        `;
      });

      setStatus('unlock-status', html, 'info');
      return;
    }

    const txId = edges[0].node.id;
    await finishRecovery(txId);
  } catch (error) {
    console.error(error);
    setStatus('unlock-status', `‚ùå Error: ${error.message}`, 'error');
  } finally {
    setButtonLoading('recovery-btn', false);
  }
}

async function finishRecovery(txId) {
  try {
    setStatus('unlock-status', 'Fetching encrypted wallet‚Ä¶', 'info');

    const { address, backupTxId } = await WalletCore.recoverByTxId(txId);

    document.getElementById('wallet-address').textContent = address;
    document.getElementById('bundlr-txid').textContent = backupTxId;

    showScreen('wallet-screen');
    setStatus('wallet-status', '‚úÖ Wallet recovered successfully!', 'success');

    await refreshBalance();
  } catch (err) {
    console.error(err);
    setStatus('unlock-status', `‚ùå ${err.message}`, 'error');
  }
}

async function recoverByKeyfile() {
  const fileInput = document.getElementById('keyfile-upload');
  const file = fileInput.files[0];

  if (!file) {
    setStatus('unlock-status', 'Please select a keyfile JSON', 'error');
    return;
  }

  try {
    const text = await file.text();
    const jwk = JSON.parse(text);

    setStatus('unlock-status', 'Create new biometric protection for this wallet‚Ä¶', 'info');

    const { address, backupTxId } = await WalletCore.importFromKeyfile(jwk);

    document.getElementById('wallet-address').textContent = address;
    document.getElementById('bundlr-txid').textContent = backupTxId || '(pending upload)';
    showScreen('wallet-screen');

    setStatus('wallet-status', '‚úÖ Keyfile imported & new encrypted backup created!', 'success');

    await refreshBalance();
  } catch (err) {
    console.error(err);
    setStatus('unlock-status', `‚ùå Error importing keyfile: ${err.message}`, 'error');
  }
}

async function uploadRecoveryBackup() {
  try {
    setStatus('wallet-status', 'Encrypting wallet and backing up to Arweave...', 'info');
    const txId = await WalletCore.uploadRecoveryBackup();
    setStatus('wallet-status', `‚úÖ Backup stored! TX: ${txId}`, 'success');
    document.getElementById('bundlr-txid').textContent = txId;
  } catch (err) {
    console.error(err);
    setStatus('wallet-status', `‚ùå Backup upload failed: ${err.message}`, 'error');
  }
}

function lockWallet() {
  showLanding();
}

function exportKey() {
  const jwk = WalletCore.getCurrentWallet();
  if (!jwk) return;

  const dataStr = JSON.stringify(jwk, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'arweave-keyfile.json';
  link.click();
  URL.revokeObjectURL(url);

  setStatus('wallet-status', '‚úÖ Keyfile exported! Keep it extremely safe!', 'success');
}

// WebAuthn support check
window.addEventListener('DOMContentLoaded', () => {
  if (!window.PublicKeyCredential || !navigator.credentials) {
    alert('‚ùå WebAuthn not supported in this browser. Please use a modern browser with biometric authentication support.');
  }
});

// Expose UI functions globally for HTML onclicks
window.showCreateScreen = showCreateScreen;
window.showUnlockScreen = showUnlockScreen;
window.showLanding = showLanding;
window.createWallet = createWallet;
window.unlockWallet = unlockWallet;
window.recoverWallet = recoverWallet;
window.sendTransaction = sendTransaction;
window.uploadData = uploadData;
window.loadHistory = loadHistory;
window.exportKey = exportKey;
window.lockWallet = lockWallet;
window.showTab = showTab;
window.recoverByKeyfile = recoverByKeyfile;
window.uploadRecoveryBackup = uploadRecoveryBackup;
window.finishRecovery = finishRecovery;
window.refreshBalance = refreshBalance;
</script>

</body>
</html>

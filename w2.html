<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Non-Custodial Arweave Wallet</title>

  <!-- Material Web Components -->
  <script type="module" src="https://esm.run/@material/web/all"></script>

  <!-- Material Symbols -->
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:FILL,wght@0,400;1,400" rel="stylesheet" />

  <!-- Arweave + localforage -->
  <script src="https://unpkg.com/arweave@1.15.5/bundles/web.bundle.js"></script>
  <script src="https://unpkg.com/localforage/dist/localforage.min.js"></script>

  <style>
    /* ------------------------------------------
       MATERIAL YOU ‚Äî SYSTEM ADAPTIVE THEME
    ------------------------------------------- */

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* MD3 Light */
      --md-sys-color-primary: #6750A4;
      --md-sys-color-on-primary: #ffffff;
      --md-sys-color-primary-container: #EADDFF;
      --md-sys-color-on-primary-container: #21005D;

      --md-sys-color-secondary: #625B71;
      --md-sys-color-on-secondary: #ffffff;
      --md-sys-color-secondary-container: #E8DEF8;

      --md-sys-color-surface: #FFFBFE;
      --md-sys-color-on-surface: #1C1B1F;

      --md-sys-color-surface-variant: #E7E0EC;
      --md-sys-color-on-surface-variant: #49454F;

      --md-sys-color-outline: #79747E;
      --md-sys-color-error: #B3261E;

      --radius-lg: 28px;
      --radius-md: 18px;
      --radius-sm: 12px;

      --elev-1: 0 1px 2px rgba(0, 0, 0, 0.12);
      --elev-2: 0 3px 6px rgba(0, 0, 0, 0.16);
      --elev-3: 0 6px 10px rgba(0, 0, 0, 0.20);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --md-sys-color-primary: #D0BCFF;
        --md-sys-color-on-primary: #381E72;
        --md-sys-color-primary-container: #4F378B;
        --md-sys-color-on-primary-container: #EADDFF;

        --md-sys-color-secondary: #CCC2DC;
        --md-sys-color-on-secondary: #332D41;
        --md-sys-color-secondary-container: #4A4458;

        --md-sys-color-surface: #1C1B1F;
        --md-sys-color-on-surface: #E6E1E5;

        --md-sys-color-surface-variant: #49454F;
        --md-sys-color-on-surface-variant: #CAC4D0;

        --md-sys-color-outline: #938F99;
        --md-sys-color-error: #F2B8B5;
      }
    }

    body {
      background: var(--md-sys-color-surface);
      color: var(--md-sys-color-on-surface);
      font-family: "Roboto", system-ui, sans-serif;
      padding: 32px 16px 80px;
      display: flex;
      justify-content: center;
    }

    .container {
      width: 100%;
      max-width: 860px;
      background: var(--md-sys-color-surface);
      border-radius: var(--radius-lg);
      padding: 36px;
      box-shadow: var(--elev-2);
      margin-bottom: 80px;
    }

    /* -------------------------------------------------
       HEADER
    ------------------------------------------------- */
    .header h1 {
      text-align: center;
      font-size: 32px;
      margin-bottom: 16px;
    }

    .security-badge {
      background: var(--md-sys-color-surface-variant);
      color: var(--md-sys-color-on-surface-variant);
      padding: 18px;
      border-radius: var(--radius-md);
      font-size: 15px;
      margin-bottom: 36px;
      border: 1px solid var(--md-sys-color-outline);
    }

    /* -------------------------------------------------
       BUTTONS (UPGRADED TO MWC LOOK)
    ------------------------------------------------- */
    .btn {
      width: 100%;
      padding: 16px;
      border-radius: var(--radius-md);
      font-size: 16px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 12px 0;
      transition: background 0.2s, transform 0.1s;
      box-shadow: var(--elev-1);
    }

    .btn-primary {
      background: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
    }

    .btn-secondary {
      background: var(--md-sys-color-secondary-container);
      color: var(--md-sys-color-on-secondary-container);
    }

    .btn-danger {
      background: var(--md-sys-color-error);
      color: white;
    }

    .btn-success {
      background: #4CAF50;
      color: white;
    }

    .btn:hover:not(:disabled) {
      transform: scale(1.01);
      filter: brightness(1.05);
    }

    /* -------------------------------------------------
       INPUT GROUPS
    ------------------------------------------------- */
    .input-group {
      margin-bottom: 24px;
    }

    .input-group label {
      display: block;
      margin-bottom: 6px;
      font-size: 14px;
      font-weight: 500;
    }

    .input-group input,
    .input-group textarea,
    .input-group select {
      width: 100%;
      padding: 14px;
      border-radius: var(--radius-md);
      border: 1px solid var(--md-sys-color-outline);
      background: var(--md-sys-color-surface-variant);
      color: var(--md-sys-color-on-surface);
      font-size: 16px;
    }

    .input-group input:focus,
    .input-group textarea:focus,
    .input-group select:focus {
      outline: 2px solid var(--md-sys-color-primary);
      background: var(--md-sys-color-surface);
    }

    /* -------------------------------------------------
       STATUS BANNERS ‚Äî visible in both themes
    ------------------------------------------------- */
    .status {
      padding: 18px;
      border-radius: var(--radius-md);
      margin-top: 20px;
      font-size: 15px;
      line-height: 1.4;
      font-weight: 500;
    }

    .status-info {
      background: rgba(100, 150, 255, 0.18);
      color: var(--md-sys-color-on-surface);
    }

    .status-success {
      background: rgba(0, 200, 83, 0.18);
      color: #0d4d0d;
    }

    .status-error {
      background: rgba(255, 82, 82, 0.18);
      color: #7b0000;
    }

    /* -------------------------------------------------
       TABS (MD3-style underline navigation)
    ------------------------------------------------- */
    .tabs {
      display: flex;
      gap: 6px;
      border-bottom: 2px solid var(--md-sys-color-outline);
      margin-bottom: 20px;
    }

    .tab {
      padding: 12px 18px;
      border: none;
      background: none;
      cursor: pointer;
      font-size: 15px;
      color: var(--md-sys-color-on-surface);
      border-bottom: 3px solid transparent;
      transition: all 0.25s;
      border-radius: var(--radius-sm);
    }

    .tab.active {
      color: var(--md-sys-color-primary);
      border-bottom-color: var(--md-sys-color-primary);
      font-weight: 600;
    }

    /* -------------------------------------------------
       CARDS
    ------------------------------------------------- */
    .wallet-info {
      background: var(--md-sys-color-surface-variant);
      padding: 20px;
      border-radius: var(--radius-md);
      margin-bottom: 20px;
      box-shadow: var(--elev-1);
    }

    .wallet-info-value {
      font-family: monospace;
      padding: 10px;
      background: var(--md-sys-color-surface);
      border-radius: var(--radius-sm);
      word-break: break-all;
    }

    .balance-card {
      background: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
      padding: 26px;
      border-radius: var(--radius-lg);
      text-align: center;
      margin-bottom: 28px;
      box-shadow: var(--elev-3);
    }

    .balance-amount {
      font-size: 44px;
      font-weight: 700;
      margin-top: 6px;
    }

    /* -------------------------------------------------
       FAB (Floating Action Button)
    ------------------------------------------------- */
    #fabScan {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 68px;
      height: 68px;
      border: none;
      border-radius: 50%;
      background: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
      font-size: 34px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--elev-3);
      cursor: pointer;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üõ°Ô∏è Non-Custodial Arweave Wallet</h1>
    </div>

    <div class="security-badge">
      <strong>100% Non-Custodial</strong>
      Your private key is generated in your browser, encrypted with your passkey, and stored on Arweave.
    </div>

    <div id="landing-screen">
      <button class="btn btn-primary" onclick="showCreateScreen()">üîë Create New Wallet</button>
      <button class="btn btn-secondary" onclick="showUnlockScreen()">üîì Unlock Existing Wallet</button>
    </div>

    <div id="create-screen" class="hidden">
      <h2 style="margin-bottom: 20px; color: #1a202c;">Create Wallet</h2>
      <div class="input-group">
        <label for="username">Username</label>
        <input type="text" id="username" placeholder="Enter username">
      </div>
      <button class="btn btn-primary" onclick="createWallet()" id="create-btn">Create Wallet</button>
      <button class="btn btn-secondary" onclick="showLanding()">Back</button>
      <div id="create-status"></div>
    </div>

    <div id="unlock-screen" class="hidden">
      <h2 style="margin-bottom: 20px; color: #1a202c;">Unlock Wallet</h2>
      <p style="color: #4a5568; margin-bottom: 20px;">Authenticate with your device to decrypt and access your wallet.</p>
      <button class="btn btn-primary" onclick="unlockWallet()" id="unlock-btn">üîì Unlock with Biometrics</button>
      <button class="btn btn-secondary" onclick="showLanding()">Back</button>

      <div class="recovery-section">
        <h3>Recovery Mode</h3>
        <div class="input-group" style="margin-top:20px;">
          <label for="keyfile-upload">Recover from Keyfile (for new devices)</label>
          <input type="file" id="keyfile-upload" accept="application/json">
        </div>
        <button class="btn btn-success" onclick="recoverByKeyfile()" id="keyfile-btn">üìÅ Import Keyfile</button>

        <div class="input-group">
          <label for="recovery-address">Wallet Address</label>
          <input type="text" id="recovery-address" placeholder="Enter your Arweave address">
        </div>
        <button class="btn btn-success" onclick="recoverWallet()" id="recovery-btn">üîç Search for Wallet</button>
      </div>

      <button class="btn btn-primary" onclick="uploadRecoveryBackup()">üîÑ Re-upload Backup to Arweave</button>
      <div id="unlock-status"></div>
    </div>

    <div id="wallet-screen" class="hidden">
      <h2 style="margin-bottom: 20px; color: #1a202c;">Wallet Active</h2>

      <div class="balance-card">
        <div class="balance-label">Balance</div>
        <div class="balance-amount" id="balance-display">--</div>
        <button class="btn" onclick="refreshBalance()" style="background: rgba(255,255,255,0.2); margin: 10px auto 0; width: auto; padding: 8px 20px;">üîÑ Refresh</button>
      </div>

      <div class="wallet-info">
        <div class="wallet-info-item">
          <div class="wallet-info-label">Address</div>
          <div class="wallet-info-value" id="wallet-address"></div>
        </div>
        <div class="wallet-info-item">
          <div class="wallet-info-label">Backup TX ID</div>
          <div class="wallet-info-value" id="bundlr-txid"></div>
        </div>
      </div>

      <div class="tabs">
        <button class="tab active" onclick="showTab('send')">Send</button>
        <button class="tab" onclick="showTab('data')">Upload Data</button>
        <button class="tab" onclick="showTab('sign')">Sign Message</button>
      </div>

      <div id="send-tab" class="tab-content">
        <div class="input-group">
          <label for="send-address">Recipient Address</label>
          <input type="text" id="send-address" placeholder="Arweave address">
        </div>
        <div class="input-group">
          <label for="send-amount">Amount (AR)</label>
          <input type="number" id="send-amount" placeholder="0.001" step="0.001" min="0">
        </div>
        <button class="btn btn-primary" onclick="sendTransaction()">üì§ Send AR</button>
      </div>

      <div id="data-tab" class="tab-content hidden">
        <div class="input-group">
          <label for="data-content">Data Content</label>
          <textarea id="data-content" placeholder="Enter data to upload to Arweave..."></textarea>
        </div>
        
        <div class="input-group">
          <label for="file-input">Optional File (max 95 KB)</label>
          <input id="file-input" type="file" />
        </div>

        <div class="input-group">
  <label for="data-encryption-mode">Encryption</label>
  <select id="data-encryption-mode">
    <option value="none">üîì No encryption</option>
    <option value="self">üîê Encrypt for me</option>
    <option value="password">üîë Encrypt with password</option>
    <option value="recipient">ü§ù Encrypt for another user</option>
  </select>
</div>

<div class="input-group hidden" id="password-field">
  <label for="data-password">Password (AES-GCM)</label>
  <input type="text" id="data-password" placeholder="Enter password">
</div>

<div class="input-group hidden" id="recipient-field">
  <label for="recipient-address">Recipient Arweave Address</label>
  <input type="text" id="recipient-address" placeholder="Recipient address">
</div>

        <div class="input-group">
          <label for="content-type">Content Type</label>
          <input type="text" id="content-type" placeholder="text/plain" value="text/plain">
        </div>
        <div class="input-group">
          <label>Custom Tags (optional)</label>
          <input type="text" id="tag-key-1" placeholder="Tag name" style="margin-bottom: 8px;">
          <input type="text" id="tag-value-1" placeholder="Tag value">
        </div>
        <button class="btn btn-primary" onclick="uploadData()">üìÅ Upload to Arweave</button>
      </div>

      <div id="sign-tab" class="tab-content hidden">
        <div class="input-group">
          <label for="sign-message">Message to Sign</label>
          <textarea id="sign-message" placeholder="Enter message to sign with your wallet..."></textarea>
        </div>
        <button class="btn btn-primary" onclick="signMessage()">‚úçÔ∏è Sign Message</button>
        
        <div id="signature-result" style="display: none; margin-top: 20px;">
          <div class="wallet-info">
            <div class="wallet-info-item">
              <div class="wallet-info-label">Signed Message</div>
              <div class="wallet-info-value" id="signed-message"></div>
            </div>
            <div class="wallet-info-item">
              <div class="wallet-info-label">Signature</div>
              <div class="wallet-info-value" id="signature-value"></div>
            </div>
            <div class="wallet-info-item">
              <div class="wallet-info-label">Public Key (Owner)</div>
              <div class="wallet-info-value" id="public-key-value"></div>
            </div>
            <div class="wallet-info-item">
              <div class="wallet-info-label">Timestamp</div>
              <div class="wallet-info-value" id="signature-timestamp"></div>
            </div>
          </div>
          <div class="button-group">
            <button class="btn btn-secondary" onclick="copySignature()">üìã Copy JSON</button>
            <button class="btn btn-success" onclick="verifySignature()">‚úÖ Verify Signature</button>
          </div>
        </div>
      </div>

      <div class="button-group" style="margin-top: 20px;">
        <button class="btn btn-success" onclick="exportKey()">üíæ Export Key</button>
        <button class="btn btn-secondary" onclick="openHistory()">üìú View History</button>
        <button class="btn btn-danger" onclick="lockWallet()">üîí Lock Wallet</button>
        <button class="btn btn-secondary" onclick="openRequestQR()">üì• Request (QR)</button>
      </div>

      <div id="wallet-status"></div>
    </div>
  </div>
  
  <button id="fabScan" onclick="openScanner()">üì∑</button>

<script>
console.log("SCRIPT LOADED");
window.TEST_FLAG = true;

// ---------------------------------------------------------------------------
//  CONFIG & ARWEAVE INIT
// ---------------------------------------------------------------------------
const CLOUD_FUNCTION_URL = 'https://marko-app.netlify.app/.netlify/functions/arload';
const WALLET_APP_NAME = 'ArweaveWallet-v1';

let arweave = null;
  
try {
  if (window.Arweave) {
    arweave = Arweave.init({ host: 'arweave.net', port: 443, protocol: 'https' });
  }
} catch (e) {
  console.error('Failed to init Arweave:', e);
}
const STORAGE_KEYS = {
  credentialId: 'credentialId',
  address: 'address',
  backupTxId: 'backupTxId',
  keyMode: 'keyMode',
  aesKeyHex: 'aesKeyHex',
  prfSaltHex: 'prfSaltHex',
  username: 'username',
  encPubKey: 'encPubKey',
  encPrivKeyJwk: 'encPrivKeyJwk',          // ‚úÖ plain JWK (for backup logic)
  encPrivKeyEncrypted: 'encPrivKeyEncrypted' // ‚úÖ AES-GCM encrypted JWK (for decrypt page)
};
// Pending payment request parsed from URL (ar:// or query params)
let pendingPaymentRequest = null;

// Pending sign message request from URL
let pendingSignRequest = null;
  
// ---------------------------------------------------------------------------
//  STORAGE ABSTRACTION (localforage -> localStorage fallback)
// ---------------------------------------------------------------------------
const WalletStorage = (function() {
  const prefix = 'biowallet:';
  const hasLocalforage = typeof window !== 'undefined' && window.localforage;

  async function get(key) {
    const full = prefix + key;
    return hasLocalforage ? await window.localforage.getItem(full) : localStorage.getItem(full);
  }

  async function set(key, value) {
    const full = prefix + key;
    hasLocalforage ? await window.localforage.setItem(full, value) : localStorage.setItem(full, value);
  }

  async function remove(key) {
    const full = prefix + key;
    hasLocalforage ? await window.localforage.removeItem(full) : localStorage.removeItem(full);
  }

  return { get, set, remove };
})();

// ---------------------------------------------------------------------------
//  UTILS
// ---------------------------------------------------------------------------
function bytesToHex(bytes) {
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

function hexToBytes(hex) {
  if (!hex || hex.length % 2 !== 0) throw new Error('Invalid hex string');
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

function parseArPaymentUri(uri) {
  const m = uri.match(/^ar:\/\/([^?]+)(\?(.*))?$/i);
  if (!m) return null;

  const address = m[1];
  const qs = m[3] || '';
  const params = new URLSearchParams(qs);

  const amount = params.get('amount') || '';
  const message = params.get('message') || '';
  const token = params.get('token') || '';

  if (token && token.toUpperCase() !== 'AR') {
    return {
      chain: 'arweave',
      address,
      amount,
      message,
      unsupportedToken: token
    };
  }

  return {
    chain: 'arweave',
    address,
    amount,
    message
  };
}

function parsePaymentRequestFromUrl() {
  const url = new URL(window.location.href);
  const params = url.searchParams;

  // Check for sign message request
  const signMessage = params.get('signMessage') || params.get('sign');
  if (signMessage) {
    const options = {};
    
    // Only include defined values
    const domain = params.get('domain');
    const statement = params.get('statement');
    const uri = params.get('uri');
    const nonce = params.get('nonce');
    const chainId = params.get('chainId');
    const issuedAt = params.get('issuedAt');
    const expirationTime = params.get('expirationTime');
    const requestId = params.get('requestId');
    
    if (domain) options.domain = domain;
    if (statement) options.statement = statement;
    if (uri) options.uri = uri;
    if (nonce) options.nonce = nonce;
    if (chainId) options.chainId = chainId;
    if (issuedAt) options.issuedAt = issuedAt;
    if (expirationTime) options.expirationTime = expirationTime;
    if (requestId) options.requestId = requestId;
    
    // Parse resources array (resource0, resource1, resource2, etc.)
    const resources = [];
    let i = 0;
    while (params.has(`resource${i}`)) {
      resources.push(params.get(`resource${i}`));
      i++;
    }
    if (resources.length > 0) options.resources = resources;
    
    pendingSignRequest = {
      message: decodeURIComponent(signMessage),
      origin: params.get('origin') || params.get('app') || 'Unknown',
      callbackUrl: params.get('callback') || params.get('redirect'),
      options
    };
  }

  const link = params.get('link');

  if (link) {
    if (link.toLowerCase().startsWith('ar://')) {
      const parsed = parseArPaymentUri(link);
      if (parsed) {
        pendingPaymentRequest = parsed;
      }
    } else if (link.toLowerCase().startsWith('ethereum:')) {
      pendingPaymentRequest = { chain: 'evm', raw: link, unsupported: true };
      console.warn('EVM payments not yet supported in this wallet. Link:', link);
    }
  } else {
    const chain = (params.get('chain') || '').toLowerCase();
    const address = params.get('address');
    const amount = params.get('amount') || '';
    const message = params.get('message') || '';

    if (chain === 'arweave' && address) {
      pendingPaymentRequest = {
        chain: 'arweave',
        address,
        amount,
        message
      };
    }
  }

  if (pendingPaymentRequest && pendingPaymentRequest.unsupported) {
    const msg = 'Received EVM payment request, but this wallet currently only supports Arweave payments.';
    console.warn(msg);
    const unlockStatus = document.getElementById('unlock-status');
    if (unlockStatus) {
      unlockStatus.innerHTML = `<div class="status status-info">${msg}</div>`;
    }
  }
}

// Netlify function wrapper
async function uploadToCloudFunction(data, tagsInput) {
  let extraTags = {};
  if (Array.isArray(tagsInput)) {
    tagsInput.forEach(t => {
      if (t && t.name && t.value != null) extraTags[t.name] = String(t.value);
    });
  } else if (tagsInput && typeof tagsInput === 'object') {
    extraTags = { ...tagsInput };
  }

  const response = await fetch(CLOUD_FUNCTION_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content: JSON.stringify(data), isBase64: false, encrypt: false, extraTags })
  });

  const result = await response.json();
  if (!response.ok || !result.success) {
    throw new Error(result.message || `Cloud function error: ${response.status}`);
  }
  return result;
}

async function applyPendingPaymentRequestIfAny() {
  // Handle sign request first
  if (pendingSignRequest) {
    const { message, origin, options = {}, callbackUrl } = pendingSignRequest;
  pendingSignRequest = null;

  showScreen('wallet-screen');
  showTab('sign');

  const messageInput = document.getElementById('sign-message');
  if (messageInput) {
    messageInput.value = message;
  }

  // Store options for later use
  window.pendingSignOptions = options;
  window.pendingCallbackUrl = callbackUrl; // Store callback separately

  let statusMsg = `<strong>üîó External Sign Request</strong><br>`;
    statusMsg += `From: <strong>${origin}</strong><br>`;
    if (callbackUrl) {
      statusMsg += `Will redirect to: ${new URL(callbackUrl).origin}<br>`;
    }
    statusMsg += `Please review and sign.`;
    setStatus('wallet-status', statusMsg, 'info');
    return;
  }

  // Handle payment request
  if (!pendingPaymentRequest) return;

  if (pendingPaymentRequest.chain !== 'arweave') {
    pendingPaymentRequest = null;
    return;
  }

  const { address, amount, message, unsupportedToken } = pendingPaymentRequest;
  pendingPaymentRequest = null;

  showScreen('wallet-screen');
  showTab('send');

  if (address) {
    const addrInput = document.getElementById('send-address');
    if (addrInput) addrInput.value = address;
  }

  if (amount) {
    const amtInput = document.getElementById('send-amount');
    if (amtInput) amtInput.value = amount;
  }

  let statusMsg = 'Payment request loaded. Please review and confirm.';

  if (message) {
    statusMsg += `<br>Message: ${message}`;
  }

  if (unsupportedToken) {
    statusMsg += `<br><strong>Warning:</strong> Token "${unsupportedToken}" is not supported; treating this as AR.`;
  }

  setStatus('wallet-status', statusMsg, 'info');
}

// ---------------------------------------------------------------------------
//  WEBAUTHN HELPERS
// ---------------------------------------------------------------------------
const WebAuthnHelper = {
  async register(username) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    const prfSalt = crypto.getRandomValues(new Uint8Array(32));

    const credential = await navigator.credentials.create({
      publicKey: {
        challenge,
        rp: {
          name: 'ARW',
          id: window.location.hostname,
          icon: 'https://marko-app.netlify.app/android-chrome-192x192.png'
        },
        user: {
          id: crypto.getRandomValues(new Uint8Array(16)),
          name: username,
          displayName: username
        },
        pubKeyCredParams: [{ alg: -7, type: 'public-key' }],
        authenticatorSelection: { authenticatorAttachment: 'platform', userVerification: 'required' },
        timeout: 60000,
        extensions: { prf: { eval: { first: prfSalt } } }
      }
    });

    const credentialIdHex = bytesToHex(new Uint8Array(credential.rawId));
    let prfKeyHex = null;

    if (typeof credential.getClientExtensionResults === 'function') {
      const ext = credential.getClientExtensionResults();
      if (ext?.prf?.results?.first) {
        prfKeyHex = bytesToHex(new Uint8Array(ext.prf.results.first));
      }
    }

    return { credentialId: credentialIdHex, prfKeyHex, prfSaltHex: bytesToHex(prfSalt) };
  },

  async authenticate(credentialIdHex) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    await navigator.credentials.get({
      publicKey: {
        challenge,
        allowCredentials: [{ id: hexToBytes(credentialIdHex), type: 'public-key' }],
        userVerification: 'required',
        timeout: 60000
      }
    });
    return true;
  },

  async evaluatePrf(credentialIdHex, saltBytes) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    const assertion = await navigator.credentials.get({
      publicKey: {
        challenge,
        allowCredentials: [{ id: hexToBytes(credentialIdHex), type: 'public-key' }],
        userVerification: 'required',
        timeout: 60000,
        extensions: { prf: { eval: { first: saltBytes } } }
      }
    });

    const ext = assertion.getClientExtensionResults?.();
    if (!ext?.prf?.results?.first) {
      throw new Error('Authenticator PRF extension not available');
    }
    return new Uint8Array(ext.prf.results.first);
  }
};

// ---------------------------------------------------------------------------
//  CRYPTO HELPERS
// ---------------------------------------------------------------------------
const CryptoHelper = {
  async encrypt(data, key) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      new TextEncoder().encode(JSON.stringify(data))
    );

    return {
      ciphertext: bytesToHex(new Uint8Array(encrypted)),
      iv: bytesToHex(iv)
    };
  },

  async decrypt(encryptedData, key) {
    const ciphertext = hexToBytes(encryptedData.ciphertext);
    const iv = hexToBytes(encryptedData.iv);

    const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext);
    return JSON.parse(new TextDecoder().decode(decrypted));
  }
};

function arrayBufferToHex(buffer) {
  const bytes = new Uint8Array(buffer);
  return Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join('');
}

// ---------------------------------------------------------------------------
//  UNIVERSAL HISTORY LOGGING FUNCTION
// ---------------------------------------------------------------------------

/**
 * Universal log function - logs any wallet event to localforage
 * @param {string} type - Event type: 'upload', 'transaction', 'signature', 'system', 'error'
 * @param {object} data - Event-specific data
 * @param {string} status - Event status: 'success', 'pending', 'failed' (default: 'success')
 */
async function logHistory(type, data, status = 'success') {
  const event = {
    id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    timestamp: Date.now(),
    type,
    status,
    data: { ...data }
  };

  const storageKey = `wallet-history:${type}`;
  
  try {
    const stored = await localforage.getItem(storageKey);
    const events = stored ? JSON.parse(stored) : [];
    
    // Prepend new event (newest first)
    events.unshift(event);
    
    // Keep last 1000 events per type to prevent excessive storage
    if (events.length > 1000) {
      events.splice(1000);
    }
    
    await localforage.setItem(storageKey, JSON.stringify(events));
    return event.id;
  } catch (e) {
    console.error('Failed to log event:', e);
    return null;
  }
}  
// ---------------------------------------------------------------------------
//  ENCRYPTED ECDH PRIVATE KEY STORAGE
// ---------------------------------------------------------------------------
async function storeEncryptedEcdhKey(ecdhPrivKeyJwk, aesKey) {
  if (!ecdhPrivKeyJwk || !aesKey) return;

  // Wrap the JWK in an object in case you want to evolve the format later
  const blob = await CryptoHelper.encrypt({ ecdh: ecdhPrivKeyJwk }, aesKey);
  await WalletStorage.set(STORAGE_KEYS.encPrivKeyEncrypted, JSON.stringify(blob));
}

async function fetchRecipientPubKey(address) {
  const query = {
    query: `{
      transactions(
        tags:[
          { name:"User-Address", values:["${address}"] },
          { name:"App-Name", values:["${WALLET_APP_NAME}"] }
        ],
        first: 1,
        sort: HEIGHT_DESC
      ){
        edges{
          node{
            tags { name value }
          }
        }
      }
    }`
  };

  const res = await fetch("https://arweave.net/graphql", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(query)
  });

  const parsed = await res.json();
  const edges = parsed?.data?.transactions?.edges || [];

  if (!edges.length)
    throw new Error("Recipient wallet not found or does not have User-EncKey");

  const tags = edges[0].node.tags;
  let pubKeyB64 = tags.find(t => t.name === "User-EncKey")?.value;

  if (!pubKeyB64)
    throw new Error("Recipient does not support encryption (User-EncKey missing)");

  // Fix Arweave '+' normalization
  pubKeyB64 = pubKeyB64.replace(/ /g, "+").trim();

  return pubKeyB64;
}
  
// ---------------------------------------------------------------------------
//  PER-USER ENCRYPTION KEY (ECDH) FOR FUTURE USE
// ---------------------------------------------------------------------------
async function generateUserEncryptionKey() {
  const keyPair = await crypto.subtle.generateKey(
    { name: "ECDH", namedCurve: "P-256" },
    true,
    ["deriveBits"]
  );

  const jwkPriv = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
  await WalletStorage.set(STORAGE_KEYS.encPrivKeyJwk, JSON.stringify(jwkPriv));


  const rawPub = await crypto.subtle.exportKey("raw", keyPair.publicKey);
  const pubB64 = btoa(String.fromCharCode(...new Uint8Array(rawPub)));

  await WalletStorage.set("encPubKey", pubB64);
  return pubB64;
}

// ---------------------------------------------------------------------------
//  WALLET CORE
// ---------------------------------------------------------------------------
const WalletCore = (function() {



  let walletJwk = null;

  function setWallet(jwk) {
    walletJwk = jwk;
  }

  function getCurrentWallet() {
    return walletJwk;
  }

  async function getAddress() {
    if (!walletJwk || !arweave) return null;
    return await arweave.wallets.jwkToAddress(walletJwk);
  }

  async function ensureUserEncKey() {
    let pub = await WalletStorage.get(STORAGE_KEYS.encPubKey);
    if (!pub) pub = await generateUserEncryptionKey();
    return pub;
  }

  async function confirmBiometricForPayment() {
    const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
    if (!credentialId) {
      throw new Error('No WebAuthn credential found. Wallet not initialized properly.');
    }
    await WebAuthnHelper.authenticate(credentialId);
  }

 async function createWallet(username) {
  if (!arweave) throw new Error('Arweave library not loaded');

  const credential = await WebAuthnHelper.register(username);
  const { credentialId, prfKeyHex, prfSaltHex } = credential;

  const jwk = await arweave.wallets.generate();
  const address = await arweave.wallets.jwkToAddress(jwk);

  let aesKey;
  let keyMode;

  if (prfKeyHex) {
    //----------------------------------------------------
    // üîê PRF MODE ‚Äî MUST HKDF-expand the PRF output
    //----------------------------------------------------
    keyMode = 'prf';

    const prfBytes = hexToBytes(prfKeyHex);

    const hkdfKey = await crypto.subtle.importKey(
      "raw",
      prfBytes,
      "HKDF",
      false,
      ["deriveKey"]
    );

    aesKey = await crypto.subtle.deriveKey(
      {
        name: "HKDF",
        hash: "SHA-256",
        salt: hexToBytes(prfSaltHex),
        info: new Uint8Array([]),
      },
      hkdfKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );

  } else {
    //----------------------------------------------------
    // üîê WRAPPED MODE ‚Äî unchanged
    //----------------------------------------------------
    keyMode = 'wrapped';
    const rawKey = crypto.getRandomValues(new Uint8Array(32));
    aesKey = await crypto.subtle.importKey(
      'raw',
      rawKey,
      'AES-GCM',
      false,
      ['encrypt', 'decrypt']
    );
    await WalletStorage.set(STORAGE_KEYS.aesKeyHex, bytesToHex(rawKey));
  }

  // Generate ECDH keypair and get private key
  const publicEncKey = await ensureUserEncKey();
  const ecdhPrivKeyJwkRaw = await WalletStorage.get(STORAGE_KEYS.encPrivKeyJwk);
  const ecdhPrivKeyJwk = ecdhPrivKeyJwkRaw ? JSON.parse(ecdhPrivKeyJwkRaw) : null;

  // üîê Also store encrypted private key locally for cross-tab decryption
  if (ecdhPrivKeyJwk) {
    await storeEncryptedEcdhKey(ecdhPrivKeyJwk, aesKey);
  }

  // Encrypt BOTH keys together for off-device backup
  const keysToBackup = {
    arweaveJwk: jwk,
    ecdhPrivateKey: ecdhPrivKeyJwk
  };
  const encrypted = await CryptoHelper.encrypt(keysToBackup, aesKey);

  const meta = {
    version: '1',
    keyMode,
    credentialId,
    prfSaltHex: keyMode === 'prf' ? prfSaltHex : null,
    username: username || '',
    address,
    encPubKey: publicEncKey
  };

  const backupPayload = { meta, encrypted };

  const tagList = [
    { name: 'App-Name', value: WALLET_APP_NAME },
    { name: 'User-Address', value: address },
    { name: 'User-Name', value: username || '' },
    { name: 'User-EncKey', value: publicEncKey },
    { name: 'Wallet-KeyMode', value: keyMode },
    { name: 'Timestamp', value: Date.now().toString() },
    { name: 'Version', value: '1' }
  ];

  const uploadResult = await uploadToCloudFunction(backupPayload, tagList);
  const txId = uploadResult.arweaveId;

  await WalletStorage.set(STORAGE_KEYS.credentialId, credentialId);
  await WalletStorage.set(STORAGE_KEYS.address, address);
  await WalletStorage.set(STORAGE_KEYS.backupTxId, txId);
  await WalletStorage.set(STORAGE_KEYS.keyMode, keyMode);
  await WalletStorage.set(STORAGE_KEYS.username, username || '');

  if (keyMode === 'prf' && prfSaltHex) {
    await WalletStorage.set(STORAGE_KEYS.prfSaltHex, prfSaltHex);
    await WalletStorage.remove(STORAGE_KEYS.aesKeyHex);
  }

  walletJwk = jwk;
  return { address, backupTxId: txId, keyMode };
}

async function unlockWallet() {
  const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
  const storedAddress = await WalletStorage.get(STORAGE_KEYS.address);
  const backupTxId = await WalletStorage.get(STORAGE_KEYS.backupTxId);

  if (!credentialId || !storedAddress || !backupTxId) {
    throw new Error('No complete wallet data found on this device.');
  }

  const res = await fetch(`https://arweave.net/${backupTxId}`);
  if (!res.ok) throw new Error('Failed to fetch encrypted wallet from Arweave');

  const encryptedBlob = JSON.parse(await res.text());
  if (!encryptedBlob.encrypted) throw new Error('Encrypted wallet missing expected field');

  const meta = encryptedBlob.meta || {};

  let keyMode = await WalletStorage.get(STORAGE_KEYS.keyMode);
  if (!keyMode && meta.keyMode) keyMode = meta.keyMode;
  if (!keyMode) throw new Error("Missing key mode information");

  let aesKey;
  let prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);
  if (!prfSaltHex && meta.prfSaltHex) prfSaltHex = meta.prfSaltHex;

  let aesKeyHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);

  if (keyMode === 'prf') {
    //----------------------------------------------------
    // üîê PRF MODE ‚Äî HKDF SAME AS createWallet
    //----------------------------------------------------
    if (!prfSaltHex) throw new Error("Missing PRF salt for PRF-protected wallet");

    const prfBytes = await WebAuthnHelper.evaluatePrf(
      credentialId,
      hexToBytes(prfSaltHex)
    );

    const hkdfKey = await crypto.subtle.importKey(
      "raw",
      prfBytes,
      "HKDF",
      false,
      ["deriveKey"]
    );

    aesKey = await crypto.subtle.deriveKey(
      {
        name: "HKDF",
        hash: "SHA-256",
        salt: hexToBytes(prfSaltHex),
        info: new Uint8Array([]),
      },
      hkdfKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );

  } else if (keyMode === 'wrapped') {
    //----------------------------------------------------
    // üîê WRAPPED MODE ‚Äî unchanged
    //----------------------------------------------------
    if (!aesKeyHex) {
      setStatus('unlock-status',
        'This wallet was imported on another device. Creating new AES encryption key...',
        'info'
      );

      await WebAuthnHelper.authenticate(credentialId);

      const rawKey = crypto.getRandomValues(new Uint8Array(32));
      aesKeyHex = bytesToHex(rawKey);
      await WalletStorage.set(STORAGE_KEYS.aesKeyHex, aesKeyHex);
    } else {
      await WebAuthnHelper.authenticate(credentialId);
    }

    aesKey = await crypto.subtle.importKey(
      "raw",
      hexToBytes(aesKeyHex),
      "AES-GCM",
      false,
      ["encrypt", "decrypt"]
    );

  } else {
    throw new Error(`Unsupported key mode: ${keyMode}`);
  }

  // Decrypt both keys
  const decrypted = await CryptoHelper.decrypt(encryptedBlob.encrypted, aesKey);

  // Handle both old format (just JWK) and new format (object with both keys)
  let jwk, ecdhPrivKey;
  if (decrypted.arweaveJwk) {
    // New format
    jwk = decrypted.arweaveJwk;
    ecdhPrivKey = decrypted.ecdhPrivateKey;
  } else {
    // Old format (backward compatibility)
    jwk = decrypted;
    ecdhPrivKey = null;
  }

  const address = await arweave.wallets.jwkToAddress(jwk);

  walletJwk = jwk;

  // Restore ECDH private key if present
  if (ecdhPrivKey) {
    await WalletStorage.set(STORAGE_KEYS.encPrivKeyJwk, JSON.stringify(ecdhPrivKey));
    // üîê Encrypted-at-rest copy for this device
    await storeEncryptedEcdhKey(ecdhPrivKey, aesKey);
  } else {
  // For very old backups with no ECDH, create a fresh ECDH keypair
  const pub = await generateUserEncryptionKey();
  const raw = await WalletStorage.get(STORAGE_KEYS.encPrivKeyJwk);
  if (raw) {
    await storeEncryptedEcdhKey(JSON.parse(raw), aesKey);
    }
  }


  await WalletStorage.set(STORAGE_KEYS.address, address);
  await WalletStorage.set(STORAGE_KEYS.backupTxId, backupTxId);
  await WalletStorage.set(STORAGE_KEYS.keyMode, keyMode);
  if (prfSaltHex) await WalletStorage.set(STORAGE_KEYS.prfSaltHex, prfSaltHex);

  return { address, backupTxId: backupTxId, keyMode };
}

async function importFromKeyfile(jwk) {
  if (!arweave) throw new Error('Arweave not initialized');

  const address = await arweave.wallets.jwkToAddress(jwk);
  const username = 'imported-' + address.substring(0, 6);

  // WebAuthn registration for this imported wallet
  const { credentialId, prfKeyHex, prfSaltHex } = await WebAuthnHelper.register(username);

  let aesKey;
  let keyMode;

  if (prfKeyHex) {
    //----------------------------------------------------
    // üîê PRF MODE ‚Äî use HKDF(prfBytes, prfSaltHex) -> AES-256-GCM
    //----------------------------------------------------
    keyMode = 'prf';

    const prfBytes = hexToBytes(prfKeyHex);

    const hkdfKey = await crypto.subtle.importKey(
      "raw",
      prfBytes,
      "HKDF",
      false,
      ["deriveKey"]
    );

    aesKey = await crypto.subtle.deriveKey(
      {
        name: "HKDF",
        hash: "SHA-256",
        salt: hexToBytes(prfSaltHex),
        info: new Uint8Array([]),
      },
      hkdfKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );

    // store salt, drop wrapped key if any
    await WalletStorage.set(STORAGE_KEYS.prfSaltHex, prfSaltHex);
    await WalletStorage.remove(STORAGE_KEYS.aesKeyHex);

  } else {
    //----------------------------------------------------
    // üîê WRAPPED MODE ‚Äî random AES key, stored locally
    //----------------------------------------------------
    keyMode = 'wrapped';

    const rawKey = crypto.getRandomValues(new Uint8Array(32));
    aesKey = await crypto.subtle.importKey(
      'raw',
      rawKey,
      'AES-GCM',
      false,
      ['encrypt', 'decrypt']
    );

    await WalletStorage.set(STORAGE_KEYS.aesKeyHex, bytesToHex(rawKey));
    await WalletStorage.remove(STORAGE_KEYS.prfSaltHex);
  }

  // Ensure per-user ECDH keypair exists (for recipient encryption)
  await ensureUserEncKey();
  const ecdhPrivKeyJwkRaw = await WalletStorage.get(STORAGE_KEYS.encPrivKeyJwk);
  const ecdhPrivKeyJwk = ecdhPrivKeyJwkRaw ? JSON.parse(ecdhPrivKeyJwkRaw) : null;

  if (ecdhPrivKeyJwk) {
    // üîê device-local encrypted copy
    await storeEncryptedEcdhKey(ecdhPrivKeyJwk, aesKey);
  }

  // Encrypt BOTH keys together
  const keysToBackup = {
    arweaveJwk: jwk,
    ecdhPrivateKey: ecdhPrivKeyJwk
  };
  const encrypted = await CryptoHelper.encrypt(keysToBackup, aesKey);


  // Persist core metadata
  await WalletStorage.set(STORAGE_KEYS.credentialId, credentialId);
  await WalletStorage.set(STORAGE_KEYS.address, address);
  await WalletStorage.set(STORAGE_KEYS.keyMode, keyMode);
  await WalletStorage.set(STORAGE_KEYS.username, username);

  walletJwk = jwk;

  // Immediately back it up to Arweave using the same key derivation
  const backupTxId = await uploadRecoveryBackupInternal();

  return { address, backupTxId, keyMode };
}

async function uploadRecoveryBackupInternal() {
  if (!walletJwk) throw new Error('No wallet loaded');
  if (!arweave) throw new Error('Arweave not initialized');

  const address = await arweave.wallets.jwkToAddress(walletJwk);

  let keyMode = await WalletStorage.get(STORAGE_KEYS.keyMode);
  if (!keyMode) {
    const prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);
    const aesKeyHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);
    if (prfSaltHex) keyMode = 'prf';
    else if (aesKeyHex) keyMode = 'wrapped';
    else throw new Error('Missing key mode and key material for backup');
  }

  let aesKey;

  if (keyMode === 'prf') {
    const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
    const prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);
    if (!credentialId || !prfSaltHex) {
      throw new Error('Missing PRF credentials for backup');
    }

    const prfBytes = await WebAuthnHelper.evaluatePrf(
      credentialId,
      hexToBytes(prfSaltHex)
    );

    const hkdfKey = await crypto.subtle.importKey(
      "raw",
      prfBytes,
      "HKDF",
      false,
      ["deriveKey"]
    );

    aesKey = await crypto.subtle.deriveKey(
      {
        name: "HKDF",
        hash: "SHA-256",
        salt: hexToBytes(prfSaltHex),
        info: new Uint8Array([]),
      },
      hkdfKey,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );

  } else if (keyMode === 'wrapped') {
    // unchanged wrapped-mode branch
    const aesKeyHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);
    if (!aesKeyHex) throw new Error('Missing local AES key.');
    aesKey = await crypto.subtle.importKey(
      'raw',
      hexToBytes(aesKeyHex),
      'AES-GCM',
      false,
      ['encrypt', 'decrypt']
    );
  } else {
    throw new Error(`Unsupported key mode: ${keyMode}`);
  }

  // Get ECDH private key
  const ecdhPrivKeyJwk = await WalletStorage.get(STORAGE_KEYS.encPrivKeyJwk);

  // Encrypt BOTH keys together
  const keysToBackup = {
    arweaveJwk: walletJwk,
    ecdhPrivateKey: ecdhPrivKeyJwk ? JSON.parse(ecdhPrivKeyJwk) : null
  };
  const encrypted = await CryptoHelper.encrypt(keysToBackup, aesKey);

  const username = (await WalletStorage.get(STORAGE_KEYS.username)) || '';
  const publicEncKey = await ensureUserEncKey();
  const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
  const prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);

  const meta = {
    version: '1',
    keyMode,
    credentialId,
    prfSaltHex: keyMode === 'prf' ? prfSaltHex : null,
    username,
    address,
    encPubKey: publicEncKey
  };

  const backupPayload = { meta, encrypted };

  const tagList = [
    { name: 'App-Name', value: WALLET_APP_NAME },
    { name: 'User-Address', value: address },
    { name: 'User-Name', value: username },
    { name: 'User-EncKey', value: publicEncKey },
    { name: 'Wallet-KeyMode', value: keyMode },
    { name: 'Timestamp', value: Date.now().toString() },
    { name: 'Version', value: '1' }
  ];

  const uploadResult = await uploadToCloudFunction(backupPayload, tagList);
  const txId = uploadResult.arweaveId;

  await WalletStorage.set(STORAGE_KEYS.backupTxId, txId);
  return txId;
}

  async function refreshBalance() {
    if (!walletJwk || !arweave) throw new Error('Wallet not loaded');
    const address = await arweave.wallets.jwkToAddress(walletJwk);
    const winston = await arweave.wallets.getBalance(address);
    const ar = arweave.ar.winstonToAr(winston);
    return `${parseFloat(ar).toFixed(4)} AR`;
  }

  async function sendArTransaction(toAddress, amountAr) {
    if (!walletJwk || !arweave) throw new Error('Wallet not loaded');

    const winstonAmount = arweave.ar.arToWinston(amountAr);

    const address = await arweave.wallets.jwkToAddress(walletJwk);
    const balanceWinston = await arweave.wallets.getBalance(address);
    const balanceAr = parseFloat(arweave.ar.winstonToAr(balanceWinston));

    const draftTx = await arweave.createTransaction({
      target: toAddress,
      quantity: winstonAmount
    }, walletJwk);

    const feeWinston = draftTx.reward;
    const feeAr = parseFloat(arweave.ar.winstonToAr(feeWinston));

    const totalRequiredAr = parseFloat(amountAr) + feeAr;

    if (balanceAr < totalRequiredAr) {
      throw new Error(
        `Insufficient balance. Needed ${totalRequiredAr.toFixed(6)} AR (amount + fee), ` +
        `but you have ${balanceAr.toFixed(6)} AR.`
      );
    }

    await arweave.transactions.sign(draftTx, walletJwk);

    const response = await arweave.transactions.post(draftTx);

    if (response.status === 200 || response.status === 202) {
      return draftTx.id;
    } else {
      throw new Error(`Transaction failed: ${response.status}`);
    }
  }

async function uploadDataItem(content, contentType, userTagKey, userTagValue) {
  if (!walletJwk || !arweave) throw new Error('Wallet not loaded');

  let base64Content;

  if (content instanceof ArrayBuffer) {
    // RAW binary ‚Üí base64
    base64Content = btoa(String.fromCharCode(...new Uint8Array(content)));
  } else if (content instanceof Uint8Array) {
    base64Content = btoa(String.fromCharCode(...content));
  } else {
    // text/JSON ‚Üí UTF-8 ‚Üí base64
    const utf8Bytes = new TextEncoder().encode(content);
    base64Content = btoa(String.fromCharCode(...utf8Bytes));
  }

  const address = await arweave.wallets.jwkToAddress(walletJwk);

  const tagObj = {
    'Content-Type': contentType || 'application/octet-stream',
    'App': WALLET_APP_NAME,
    'Wallet-Address': address,
    'Timestamp': Date.now().toString()
  };

  if (userTagKey && userTagValue) {
    tagObj[userTagKey] = userTagValue;
  }

  const response = await fetch(CLOUD_FUNCTION_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      content: base64Content,
      isBase64: true,
      encrypt: false,
      extraTags: tagObj
    })
  });

  const result = await response.json();
  if (!response.ok || !result.success) {
    throw new Error(result.message || 'Cloud function upload failed');
  }

  return result.arweaveId;
}

async function signMessage(message, options = {}) {
  if (!walletJwk || !arweave) throw new Error('Wallet not loaded');

  const address = await arweave.wallets.jwkToAddress(walletJwk);

  // Construct CAIP-122 compliant Sign-In with Arweave (SIWAr) message if options provided
  let messageToSign = message;
  let isCAIP122 = false;

  if (options.domain || options.uri || options.statement) {
    isCAIP122 = true;
    const {
      domain = window.location.host,
      statement,
      uri = window.location.href,
      version = '1',
      chainId = 'arweave:1', // Arweave mainnet
      nonce = crypto.randomUUID(),
      issuedAt = new Date().toISOString(),
      expirationTime,
      notBefore,
      requestId,
      resources = []
    } = options;

    // Build CAIP-122 message structure (EIP-4361 inspired format)
    let parts = [];
    parts.push(`${domain} wants you to sign in with your Arweave account:`);
    parts.push(address);
    parts.push('');
    if (statement) {
      parts.push(statement);
      parts.push('');
    }
    parts.push(`URI: ${uri}`);
    parts.push(`Version: ${version}`);
    parts.push(`Chain ID: ${chainId}`);
    parts.push(`Nonce: ${nonce}`);
    parts.push(`Issued At: ${issuedAt}`);
    
    if (expirationTime) parts.push(`Expiration Time: ${expirationTime}`);
    if (notBefore) parts.push(`Not Before: ${notBefore}`);
    if (requestId) parts.push(`Request ID: ${requestId}`);
    
    if (resources.length > 0) {
      parts.push('Resources:');
      resources.forEach(r => parts.push(`- ${r}`));
    }

    messageToSign = parts.join('\n');
  }

  // Sign the message with Arweave's RSA-PSS signature
  const messageBytes = new TextEncoder().encode(messageToSign);
  const signature = await arweave.crypto.sign(walletJwk, messageBytes);
  const signatureB64 = arweave.utils.bufferTob64Url(signature);

  return {
    message: messageToSign,
    signature: signatureB64,
    owner: walletJwk.n, // RSA public key modulus (n)
    publicKey: { kty: "RSA", e: "AQAB", n: walletJwk.n },
    address,
    timestamp: Date.now(),
    isCAIP122
  };
}


  return {
    createWallet,
    unlockWallet,
    importFromKeyfile,
    uploadRecoveryBackup: uploadRecoveryBackupInternal,
    refreshBalance,
    sendArTransaction,
    uploadDataItem,
    getCurrentWallet,
    getAddress,
    setWallet,
    confirmBiometricForPayment,
    signMessage
  };
})();

// ---------------------------------------------------------------------------
//  UI HELPERS
// ---------------------------------------------------------------------------
function showScreen(screenId) {
  ['landing-screen', 'create-screen', 'unlock-screen', 'wallet-screen'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  });
  const target = document.getElementById(screenId);
  if (target) target.classList.remove('hidden');
}

function showLanding() { showScreen('landing-screen'); }
function showCreateScreen() { showScreen('create-screen'); document.getElementById('create-status').innerHTML = ''; }
function showUnlockScreen() { showScreen('unlock-screen'); document.getElementById('unlock-status').innerHTML = ''; }

function showTab(tabName) {
  document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
  
  const allTabs = document.querySelectorAll('.tabs .tab');
  allTabs.forEach(btn => {
    if (btn.textContent.trim().toLowerCase().includes(tabName)) {
      btn.classList.add('active');
    }
  });

  ['send-tab', 'data-tab', 'sign-tab'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  });

  const target = document.getElementById(`${tabName}-tab`);
  if (target) target.classList.remove('hidden');
}

function setStatus(elementId, message, type = 'info') {
  const element = document.getElementById(elementId);
  if (!element) return;
  element.innerHTML = `<div class="status status-${type}">${message}</div>`;
}

function setButtonLoading(buttonId, loading) {
  const button = document.getElementById(buttonId);
  if (!button) return;
  button.disabled = loading;
}

document.getElementById("data-encryption-mode").addEventListener("change", e => {
  const mode = e.target.value;

  document.getElementById("password-field").classList.add("hidden");
  document.getElementById("recipient-field").classList.add("hidden");

  if (mode === "password") {
    document.getElementById("password-field").classList.remove("hidden");
  } else if (mode === "recipient") {
    document.getElementById("recipient-field").classList.remove("hidden");
  }
});
  
// ---------------------------------------------------------------------------
//  UI: CREATE WALLET
// ---------------------------------------------------------------------------
async function createWallet() {
  const username = document.getElementById('username').value.trim();

  if (!username) {
    setStatus('create-status', 'Please enter a username', 'error');
    return;
  }

  setButtonLoading('create-btn', true);
  setStatus('create-status', 'Creating wallet...', 'info');

  try {
    const { address, backupTxId } = await WalletCore.createWallet(username);
    // ‚úÖ LOG SUCCESS
    await logHistory('system', {
      action: 'wallet_created',
      details: `Wallet created with biometric authentication. Backup TX: ${backupTxId.substring(0, 20)}...`,
      address: address
    });

    document.getElementById('wallet-address').textContent = address;
    document.getElementById('bundlr-txid').textContent = backupTxId;
    showScreen('wallet-screen');
    setStatus('wallet-status', '‚úÖ Wallet created and secured on this device!', 'success');

    await refreshBalance();
    await applyPendingPaymentRequestIfAny();
  } catch (error) {
    console.error(error);
    // ‚ùå LOG ERROR
    await logHistory('error', {
      operation: 'create_wallet',
      error: error.message,
      details: `Username: ${username}`
    }, 'failed');
    
    setStatus('create-status', `‚ùå Error: ${error.message}`, 'error');
  } finally {
    setButtonLoading('create-btn', false);
  }
}

// ---------------------------------------------------------------------------
//  UI: UNLOCK WALLET
// ---------------------------------------------------------------------------
async function unlockWallet() {
  setButtonLoading('unlock-btn', true);
  setStatus('unlock-status', 'Retrieving encrypted wallet...', 'info');

  try {
    const { address, backupTxId } = await WalletCore.unlockWallet();
    // ‚úÖ LOG SUCCESS
    await logHistory('system', {
      action: 'wallet_unlocked',
      details: 'Biometric authentication successful',
      address: address
    });
    
    document.getElementById('wallet-address').textContent = address;
    document.getElementById('bundlr-txid').textContent = backupTxId;

    showScreen('wallet-screen');
    setStatus('wallet-status', '‚úÖ Wallet unlocked successfully!', 'success');

    await refreshBalance();
    await applyPendingPaymentRequestIfAny();
  } catch (error) {
    console.error(error);
    // ‚ùå LOG ERROR
    await logHistory('error', {
      operation: 'unlock_wallet',
      error: error.message,
      details: 'Failed to authenticate with biometrics'
    }, 'failed');
    
    setStatus('unlock-status', `‚ùå Error: ${error.message}`, 'error');
  } finally {
    setButtonLoading('unlock-btn', false);
  }
}

async function refreshBalance() {
  try {
    const balance = await WalletCore.refreshBalance();
    document.getElementById('balance-display').textContent = balance;
  } catch (error) {
    console.error(error);
    document.getElementById('balance-display').textContent = 'Error loading';
  }
}

 function openHistory() {
  window.open('history.html', '_blank');
}  
// ---------------------------------------------------------------------------
//  UI: SEND TX
// ---------------------------------------------------------------------------
async function sendTransaction() {
  const toAddress = document.getElementById('send-address').value.trim();
  const amount = document.getElementById('send-amount').value;

  if (!toAddress || !amount || parseFloat(amount) <= 0) {
    setStatus('wallet-status', '‚ùå Please enter valid recipient and amount', 'error');
    return;
  }

  setStatus('wallet-status', 'Confirm this payment on your device‚Ä¶', 'info');

  try {
    await WalletCore.confirmBiometricForPayment();

    setStatus('wallet-status', 'Creating transaction...', 'info');

    const txId = await WalletCore.sendArTransaction(toAddress, amount);
    // ‚úÖ LOG TRANSACTION (PENDING)
    await logHistory('transaction', {
      txid: txId,
      direction: 'sent',
      address: toAddress,
      amount: `${amount} AR`,
      sentViaWallet: true,
      arweaveLink: `https://arweave.net/${txId}`,
      viewscanLink: `https://viewblock.io/arweave/tx/${txId}`
    }, 'pending');
    
    setStatus('wallet-status', `‚úÖ Transaction sent! TX ID: ${txId.substring(0, 20)}...`, 'success');

    document.getElementById('send-address').value = '';
    document.getElementById('send-amount').value = '';

    setTimeout(refreshBalance, 2000);
  } catch (error) {
    console.error(error);
    // ‚ùå LOG ERROR
    await logHistory('error', {
      operation: 'send_transaction',
      error: error.message,
      details: `To: ${toAddress}, Amount: ${amount} AR`
    }, 'failed');
    
    setStatus('wallet-status', `‚ùå Error: ${error.message}`, 'error');
  }
}

// ---------------------------------------------------------------------------
//  UI: UPLOAD DATA
// ---------------------------------------------------------------------------
async function deriveKeyFromPassword(password) {
  const enc = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));

  const baseKey = await crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );

  const aesKey = await crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt,
      iterations: 100000,
      hash: "SHA-256"
    },
    baseKey,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );

  return { aesKey, salt: bytesToHex(salt) };
}

async function uploadData() {
  //
  // ---- SIZE LIMITS ----
  //
  const MAX_FILE_NONE      = 95 * 1024;  // raw upload
  const MAX_FILE_SELF      = 48 * 1024;  // one AES-GCM
  const MAX_FILE_PASSWORD  = 48 * 1024;  // same as self
  const MAX_FILE_RECIPIENT = 48 * 1024;  // recipient-only
  const MAX_FILE_DUAL      = 24 * 1024;  // self + recipient dual encryption

  let finalContent = null;
  let statusAppend = "";

  const textArea = document.getElementById("data-content");
  const fileInput = document.getElementById("file-input");

  let content = textArea.value.trim();
  let fileData = null;
  let fileMeta = null;

  // ------------------------------
  // FILE OR TEXT
  // ------------------------------
  if (fileInput.files && fileInput.files[0]) {
    const file = fileInput.files[0];

    fileData = await file.arrayBuffer();
    fileMeta = {
      name: file.name,
      type: file.type || "application/octet-stream"
    };

    // when file present ‚Üí content ignored
    content = null;
  }

  if (!content && !fileData) {
    setStatus('wallet-status', '‚ùå Please enter text or choose a file', 'error');
    return;
  }

  const encMode = document.getElementById("data-encryption-mode").value;
  let contentType;
  if (fileData) {
    // Use the file‚Äôs actual MIME type if valid
    contentType = fileMeta.type && fileMeta.type !== ""
      ? fileMeta.type
      : "application/octet-stream";
  } else {
    // Use text field for manual input
    contentType =
      document.getElementById("content-type").value.trim() || "text/plain";
  }
  const userTagKey = document.getElementById("tag-key-1").value.trim();
  const userTagValue = document.getElementById("tag-value-1").value.trim();

  //
  // ------------------------------
  // SIZE CHECK BASED ON MODE
  // ------------------------------
  //
  if (fileData) {
    const size = fileData.byteLength;

    if (encMode === "none") {
      if (size > MAX_FILE_NONE)
        return setStatus('wallet-status', `‚ùå File too large (max ${MAX_FILE_NONE/1024} KB)`, 'error');

    } else if (encMode === "self") {
      if (size > MAX_FILE_SELF)
        return setStatus('wallet-status', `‚ùå File too large for encryption (max ${MAX_FILE_SELF/1024} KB)`, 'error');

    } else if (encMode === "password") {
      if (size > MAX_FILE_PASSWORD)
        return setStatus('wallet-status', `‚ùå File too large for password encryption (max ${MAX_FILE_PASSWORD/1024} KB)`, 'error');

    } else if (encMode === "recipient") {
      // dual encryption ‚Üí strictest
      if (size > MAX_FILE_DUAL)
        return setStatus('wallet-status', `‚ùå File too large for dual encryption (max ${MAX_FILE_DUAL/1024} KB)`, 'error');
    }
  }

  setStatus('wallet-status', 'Preparing upload‚Ä¶', 'info');

  //
  // Helper to build payload (text OR file)
  //
  const buildPayload = () => {
    if (fileData) {
      return {
        file: arrayBufferToHex(fileData),
        mime: fileMeta.type,
        name: fileMeta.name
      };
    } else {
      return { text: content };
    }
  };

  try {
  // ----------------------
// NO ENCRYPTION (plaintext or file)
// ----------------------
if (encMode === "none") {

  if (fileData) {
    // Upload raw bytes directly
    finalContent = fileData;            // <-- IMPORTANT
  } else {
    // For text: upload raw text
    finalContent = new TextEncoder().encode(content);
  }
}



    // ------------------------------------
    // SELF ENCRYPTION
    // ------------------------------------
    else if (encMode === "self") {
      const credentialId = await WalletStorage.get("credentialId");
      const keyMode = await WalletStorage.get("keyMode");
      if (!credentialId || !keyMode)
        throw new Error("Wallet not unlocked on this device");

      let aesKey;

      if (keyMode === "prf") {
        const prfSaltHex = await WalletStorage.get("prfSaltHex");
        if (!prfSaltHex) throw new Error("Missing PRF salt");

        const prfBytes = await WebAuthnHelper.evaluatePrf(
          credentialId, hexToBytes(prfSaltHex)
        );

        const hkdfKey = await crypto.subtle.importKey(
          "raw", prfBytes, "HKDF", false, ["deriveKey"]
        );

        aesKey = await crypto.subtle.deriveKey(
          {
            name: "HKDF",
            hash: "SHA-256",
            salt: hexToBytes(prfSaltHex),
            info: new Uint8Array([])
          },
          hkdfKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt", "decrypt"]
        );

      } else {
        await WebAuthnHelper.authenticate(credentialId);
        const aesHex = await WalletStorage.get("aesKeyHex");
        if (!aesHex) throw new Error("Missing local AES key");
        aesKey = await crypto.subtle.importKey(
          "raw", hexToBytes(aesHex), "AES-GCM", false, ["encrypt", "decrypt"]
        );
      }

      const encryptedPayload = await CryptoHelper.encrypt(buildPayload(), aesKey);

      finalContent = JSON.stringify({
        enc: "self",
        data: encryptedPayload
      });
    }

    // ------------------------------------
    // PASSWORD ENCRYPTION
    // ------------------------------------
    else if (encMode === "password") {
      const password = document.getElementById("data-password").value.trim();
      if (!password) throw new Error("Password required.");

      const { aesKey, salt } = await deriveKeyFromPassword(password);
      const encrypted = await CryptoHelper.encrypt(buildPayload(), aesKey);

      finalContent = JSON.stringify({
        enc: "pw",
        salt,
        data: encrypted
      });

      statusAppend = "#" + password;
    }

    // ------------------------------------
    // RECIPIENT ENCRYPTION (dual)
    // ------------------------------------
    else if (encMode === "recipient") {

      //
      // Recipient encryption (ECDH)
      //
      const target = document.getElementById("recipient-address").value.trim();
      if (!target) throw new Error("Recipient address required.");

      // fetch their User-EncKey
      const encPubKey = await fetchRecipientPubKey(target);

      let rawRecipientPub = Uint8Array.from(atob(encPubKey), c => c.charCodeAt(0));

      const recipientPubKey = await crypto.subtle.importKey(
        "raw", rawRecipientPub,
        { name: "ECDH", namedCurve: "P-256" },
        false, []
      );

      // ephemeral keypair
      const ephemeral = await crypto.subtle.generateKey(
        { name: "ECDH", namedCurve: "P-256" },
        true,
        ["deriveBits"]
      );

      const ephemeralRaw = await crypto.subtle.exportKey("raw", ephemeral.publicKey);
      const fromPubB64 = btoa(String.fromCharCode(...new Uint8Array(ephemeralRaw)));

      const sharedBits = await crypto.subtle.deriveBits(
        { name: "ECDH", public: recipientPubKey },
        ephemeral.privateKey,
        256
      );

      const aesKeyRecipient = await crypto.subtle.importKey(
        "raw", sharedBits, "AES-GCM", false, ["encrypt"]
      );

      const payload = buildPayload();

      const encryptedRecipient = await CryptoHelper.encrypt(payload, aesKeyRecipient);

      //
      // Self copy (PRF or wrapped)
      //
      const credentialId = await WalletStorage.get("credentialId");
      const keyMode = await WalletStorage.get("keyMode");
      if (!credentialId || !keyMode)
        throw new Error("Wallet not unlocked on this device");

      let aesKeySelf;

      if (keyMode === "prf") {
        const prfSaltHex = await WalletStorage.get("prfSaltHex");
        const prfBytes = await WebAuthnHelper.evaluatePrf(
          credentialId, hexToBytes(prfSaltHex)
        );

        const hkdfKey = await crypto.subtle.importKey(
          "raw", prfBytes, "HKDF", false, ["deriveKey"]
        );

        aesKeySelf = await crypto.subtle.deriveKey(
          {
            name: "HKDF",
            hash: "SHA-256",
            salt: hexToBytes(prfSaltHex),
            info: new Uint8Array([])
          },
          hkdfKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt"]
        );

      } else {
        await WebAuthnHelper.authenticate(credentialId);
        const aesHex = await WalletStorage.get("aesKeyHex");
        aesKeySelf = await crypto.subtle.importKey(
          "raw", hexToBytes(aesHex), "AES-GCM", false, ["encrypt"]
        );
      }

      const encryptedSelf = await CryptoHelper.encrypt(payload, aesKeySelf);

      //
      // dual envelope
      //
      finalContent = JSON.stringify({
        enc: "recipient",
        to: target,
        fromPub: fromPubB64,
        data: {
          recipient: encryptedRecipient,
          self: encryptedSelf
        }
      });
    }

    //
    // UPLOAD
    //
    const txId = await WalletCore.uploadDataItem(
      finalContent,
      contentType,
      userTagKey || null,
      userTagValue || null
    );

    const origin = window.location.origin;
    let decryptLink = null;

    if (encMode === 'none') {
      decryptLink = `https://arweave.net/${txId}`;
    } else if (encMode === 'self') {
      decryptLink = `${origin}/dw2.html?link=${txId}`;
    } else if (encMode === 'password') {
      const password = document.getElementById('data-password').value.trim();
      decryptLink = `${origin}/dw2.html?link=${txId}#${password}`;
    } else if (encMode === 'recipient') {
      decryptLink = `${origin}/dw2.html?link=${txId}`;
    }

    // Get recipient address if applicable
    let recipientAddress = null;
    if (encMode === 'recipient') {
      recipientAddress = document.getElementById('recipient-address').value.trim();
    }

    // ‚úÖ LOG UPLOAD
    await logHistory('upload', {
      txid: txId,
      fileName: fileData ? fileMeta.name : 'text-content.txt',
      fileSize: fileData ? fileData.byteLength : new TextEncoder().encode(content).byteLength,
      contentType: contentType,
      encryptionMode: encMode,
      recipient: recipientAddress,
      decryptLink: decryptLink
    });

    let link = `https://arweave.net/${txId}`;
    if (statusAppend) link += statusAppend;

    setStatus(
      "wallet-status",
      `‚úÖ Uploaded! TX: ${txId}<br><a href="${link}" target="_blank">Open</a>`,
      "success"
    );

    //
    // RESET UI
    //
    textArea.value = "";
    fileInput.value = "";
    document.getElementById("tag-key-1").value = "";
    document.getElementById("tag-value-1").value = "";
    const pw = document.getElementById("data-password");
    if (pw) pw.value = "";
    const ra = document.getElementById("recipient-address");
    if (ra) ra.value = "";

  } catch (err) {
    console.error(err);
    // ‚ùå LOG ERROR
    await logHistory('error', {
      operation: 'upload_data',
      error: err.message,
      details: `Encryption: ${encMode}, Content-Type: ${contentType}`
    }, 'failed');
    setStatus("wallet-status", `‚ùå Upload error: ${err.message}`, "error");
  }
}



// ---------------------------------------------------------------------------
//  UI: SIGN MESSAGE
// ---------------------------------------------------------------------------

async function signMessage() {
  const message = document.getElementById('sign-message').value.trim();
  if (!message) {
    setStatus('wallet-status', '‚ùå Please enter a message to sign', 'error');
    return;
  }

  // Optional: Collect CAIP-122 options from additional inputs if added to HTML
   // Use pending options if available (from URL), otherwise empty
  const options = window.pendingSignOptions || {};
  const callbackUrl = window.pendingCallbackUrl; // Get callback
  window.pendingSignOptions = null; // Clear after use
  window.pendingCallbackUrl = null; // Clear callback

  setStatus('wallet-status', 'Confirm signing on your device‚Ä¶', 'info');
  try {
    await WalletCore.confirmBiometricForPayment();
    setStatus('wallet-status', 'Signing message...', 'info');
    const result = await WalletCore.signMessage(message, options);
    // ‚úÖ LOG SIGNATURE
    await logHistory('signature', {
      message: result.message,
      signature: result.signature,
      address: result.address,
      requestedBy: pendingSignRequest?.origin || 'Manual',
      callbackUrl: callbackUrl,
      isCAIP122: result.isCAIP122,
      options: options
    });
    document.getElementById('signed-message').textContent = result.message;
    document.getElementById('signature-value').textContent = result.signature;
    document.getElementById('public-key-value').textContent = JSON.stringify(result.publicKey, null, 2);
    document.getElementById('signature-timestamp').textContent = new Date(result.timestamp).toLocaleString();

    // Add Owner field
    let ownerDiv = document.getElementById('owner-field');
    if (!ownerDiv) {
      ownerDiv = document.createElement('div');
      ownerDiv.id = 'owner-field';
      ownerDiv.className = 'wallet-info-item';
      ownerDiv.innerHTML = `
        <div class="wallet-info-label">Owner (for verification)</div>
        <div class="wallet-info-value" id="owner-value"></div>
      `;
      document.querySelector('#signature-result .wallet-info').appendChild(ownerDiv);
    }
    document.getElementById('owner-value').textContent = result.owner;

    document.getElementById('signature-result').style.display = 'block';
    window.lastSignatureResult = result;
    if (callbackUrl) {
      setStatus('wallet-status', 
        `‚úÖ Signed! Redirecting back to app in 3 seconds...<br>
        <button class="btn btn-secondary" onclick="window.pendingRedirect = null; setStatus('wallet-status', 'Redirect cancelled', 'info');">Cancel</button>`, 
        'success'
      );
          setTimeout(() => {
        if (window.pendingRedirect !== null) { // Check if not cancelled
          try {
            const redirectUrl = new URL(callbackUrl);
            
            // Add signature data to callback URL
            redirectUrl.searchParams.set('signature', result.signature);
            redirectUrl.searchParams.set('message', encodeURIComponent(result.message));
            redirectUrl.searchParams.set('owner', result.owner);
            redirectUrl.searchParams.set('address', result.address);
            redirectUrl.searchParams.set('timestamp', result.timestamp.toString());
            
            // Redirect
            window.location.href = redirectUrl.toString();
          } catch (err) {
            console.error('Invalid callback URL:', err);
            setStatus('wallet-status', '‚ùå Invalid callback URL', 'error');
          }
        }
      }, 3000);
      
      window.pendingRedirect = true; // Flag for cancellation
    } else {
      setStatus('wallet-status', `‚úÖ Signed successfully!`, 'success');
    }
    
  } catch (error) {
    console.error(error);
    // ‚ùå LOG ERROR
    await logHistory('error', {
      operation: 'sign_message',
      error: error.message,
      details: `Message length: ${message.length} chars`
    }, 'failed');
    setStatus('wallet-status', `‚ùå Error: ${error.message}`, 'error');
  }
}
  
function copySignature() {
  if (!window.lastSignatureResult) {
    setStatus('wallet-status', '‚ùå No signature to copy', 'error');
    return;
  }

  const json = JSON.stringify(window.lastSignatureResult, null, 2);
  
  navigator.clipboard.writeText(json).then(() => {
    setStatus('wallet-status', '‚úÖ Signature JSON copied to clipboard!', 'success');
  }).catch(err => {
    console.error('Copy failed:', err);
    setStatus('wallet-status', '‚ùå Failed to copy to clipboard', 'error');
  });
}

async function verifySignature() {
  if (!window.lastSignatureResult) {
    setStatus('wallet-status', '‚ùå No signature to verify', 'error');
    return;
  }
  
  const { message, signature, owner } = window.lastSignatureResult;
  
  try {
    setStatus('wallet-status', 'Verifying signature...', 'info');
    
    // Use Arweave's native verification method
    const valid = await arweave.crypto.verify(
      owner,  // Public key (n value from JWK)
      new TextEncoder().encode(message),
      arweave.utils.b64UrlToBuffer(signature)
    );
    
    if (valid) {
      setStatus('wallet-status', '‚úÖ Signature is VALID! Verified using Arweave native crypto.', 'success');
    } else {
      setStatus('wallet-status', '‚ùå Signature verification FAILED!', 'error');
    }
    
    return valid;
  } catch (error) {
    console.error('Verification error:', error);
    setStatus('wallet-status', `‚ùå Verification error: ${error.message}`, 'error');
    return false;
  }
}  

  

// ---------------------------------------------------------------------------
//  UI: RECOVERY BY ADDRESS / USERNAME (SAME DEVICE + PASSKEY)
// ---------------------------------------------------------------------------
async function recoverWallet() {
  const input = document.getElementById('recovery-address').value.trim();

  if (!input) {
    setStatus('unlock-status', 'Please enter your wallet address or username', 'error');
    return;
  }

  setButtonLoading('recovery-btn', true);
  setStatus('unlock-status', 'Searching Arweave for wallet backups...', 'info');

  try {
    const isAddress = /^[a-z0-9-_]{43}$/i.test(input);

    const gqlQuery = isAddress
      ? `query {
          transactions(
            tags: [
              { name: "App-Name", values: ["${WALLET_APP_NAME}"]},
              { name: "User-Address", values: ["${input}"]}
            ],
            first: 10,
            sort: HEIGHT_DESC
          ) {
            edges { node { id } }
          }
        }`
      : `query {
          transactions(
            tags: [
              { name: "App-Name", values: ["${WALLET_APP_NAME}"]},
              { name: "User-Name", values: ["${input}"]}
            ],
            first: 10,
            sort: HEIGHT_DESC
          ) {
            edges {
              node {
                id
                tags { name value }
              }
            }
          }
        }`;

    const fetchRes = await fetch("https://arweave.net/graphql", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ query: gqlQuery })
    });

    const gqlResult = await fetchRes.json();
    const edges = gqlResult.data.transactions.edges;

    if (!edges.length) {
      throw new Error("No wallet backup found for this search");
    }

    if (!isAddress && edges.length > 1) {
      let html = "<strong>Multiple matches found:</strong><br><br>";

      edges.forEach((e) => {
        const txid = e.node.id;
        const tagMap = {};
        (e.node.tags || []).forEach(t => tagMap[t.name] = t.value);

        html += `
          <div style="margin-bottom:10px;">
            <button class="btn btn-secondary" onclick="finishRecovery('${txid}')">
              Recover wallet: ${tagMap["User-Address"] || "Unknown address"}<br>
              <small>${txid.substring(0,20)}‚Ä¶</small>
            </button>
          </div>
        `;
      });

      setStatus("unlock-status", html, "info");
      return;
    }

    const txId = edges[0].node.id;
    await finishRecovery(txId);

  } catch (error) {
    setStatus('unlock-status', `‚ùå Error: ${error.message}`, 'error');
    console.error(error);
  } finally {
    setButtonLoading('recovery-btn', false);
  }
}
  
async function finishRecovery(txId) {
  try {
    setStatus('unlock-status', 'Fetching encrypted wallet from Arweave‚Ä¶', 'info');

    const encryptedRes = await fetch(`https://arweave.net/${txId}`);
    if (!encryptedRes.ok) throw new Error("Failed to fetch encrypted backup");

    const encryptedBlob = JSON.parse(await encryptedRes.text());
    if (!encryptedBlob.encrypted) throw new Error("Encrypted blob missing required structure");

    const meta = encryptedBlob.meta || {};
    if (!meta.keyMode) throw new Error("Missing key mode information in backup");

    // Get all metadata from Arweave backup (no local storage dependency)
    const keyMode = meta.keyMode;
    const credentialId = meta.credentialId;
    const address = meta.address;
    const username = meta.username || '';
    const encPubKey = meta.encPubKey; // ‚úÖ Get public key from backup

    if (!credentialId) throw new Error("Missing credential ID in backup");
    if (!address) throw new Error("Missing address in backup");

    setStatus('unlock-status', 'Checking if WebAuthn credential exists on this device‚Ä¶', 'info');
    
    let aesKey;

    if (keyMode === 'prf') {
      // ‚úÖ PRF MODE: Full same-device recovery possible!
      const prfSaltHex = meta.prfSaltHex;
      if (!prfSaltHex) throw new Error("Missing PRF salt in backup for PRF-protected wallet");

      setStatus('unlock-status', 'üîê PRF mode detected. Please authenticate with your device‚Ä¶', 'info');

      try {
        const prfBytes = await WebAuthnHelper.evaluatePrf(credentialId, hexToBytes(prfSaltHex));

        // Use HKDF to derive AES key (matching encryption side)
        const hkdfKey = await crypto.subtle.importKey(
          "raw", prfBytes, "HKDF", false, ["deriveKey"]
        );

        aesKey = await crypto.subtle.deriveKey(
          {
            name: "HKDF",
            hash: "SHA-256",
            salt: hexToBytes(prfSaltHex),
            info: new Uint8Array([]),
          },
          hkdfKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt", "decrypt"]
        );

        setStatus('unlock-status', '‚úÖ Credential found! Decrypting wallet‚Ä¶', 'info');

      } catch (authError) {
        throw new Error(
          "WebAuthn credential not found on this device. " +
          "Please use 'Recover from Keyfile' option to import your wallet on this device."
        );
      }

      // Save PRF salt to local storage for future use
      await WalletStorage.set('prfSaltHex', prfSaltHex);

    } else if (keyMode === 'wrapped') {
      // ‚ö†Ô∏è WRAPPED MODE: Cannot recover if storage cleared
      const storedAesKeyHex = await WalletStorage.get('aesKeyHex');
      
      if (!storedAesKeyHex) {
        throw new Error(
          "‚ö†Ô∏è Wrapped-mode wallet detected, but local encryption key was cleared. " +
          "Same-device recovery is only possible with PRF mode. " +
          "Please use 'Recover from Keyfile' option to import your wallet."
        );
      }

      setStatus('unlock-status', 'Please authenticate with your device‚Ä¶', 'info');
      
      try {
        await WebAuthnHelper.authenticate(credentialId);
        aesKey = await crypto.subtle.importKey("raw", hexToBytes(storedAesKeyHex), "AES-GCM", false, ["encrypt", "decrypt"]);
      } catch (authError) {
        throw new Error(
          "WebAuthn credential not found on this device. " +
          "Please use 'Recover from Keyfile' option to import your wallet on this device."
        );
      }

    } else {
      throw new Error(`Unsupported key mode: ${keyMode}`);
    }

    // Decrypt both keys
    const decrypted = await CryptoHelper.decrypt(encryptedBlob.encrypted, aesKey);

    // Handle both old format (just JWK) and new format (object with both keys)
    let jwk, ecdhPrivKey;
    if (decrypted.arweaveJwk) {
      // New format
      jwk = decrypted.arweaveJwk;
      ecdhPrivKey = decrypted.ecdhPrivateKey;
    } else {
      // Old format (backward compatibility)
      jwk = decrypted;
      ecdhPrivKey = null;
    }

    const recoveredAddress = await arweave.wallets.jwkToAddress(jwk);

    if (recoveredAddress !== address) {
      throw new Error("Address mismatch after decryption. Backup may be corrupted.");
    }

    // Set wallet and restore all metadata from Arweave
    WalletCore.setWallet(jwk);
    
    // ‚úÖ Restore ECDH private key from backup
    if (ecdhPrivKey) {
      await WalletStorage.set(STORAGE_KEYS.encPrivKeyJwk, JSON.stringify(ecdhPrivKey));
      await storeEncryptedEcdhKey(ecdhPrivKey, aesKey); // this writes encPrivKeyEncrypted
      if (encPubKey) {
        await WalletStorage.set("encPubKey", encPubKey);
      }
      // üîê also store encrypted private key on this device
      await storeEncryptedEcdhKey(ecdhPrivKey, aesKey);
      } else {
      // Old backup without ECDH key - generate new one (won't decrypt old messages)
      if (encPubKey) {
        await WalletStorage.set("encPubKey", encPubKey);
      } else {
        const keyPair = await crypto.subtle.generateKey(
          { name: "ECDH", namedCurve: "P-256" },
          true,
          ["deriveBits"]
        );
        const jwkPriv = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
        await WalletStorage.set("encPrivKeyJwk", JSON.stringify(jwkPriv));
        const rawPub = await crypto.subtle.exportKey("raw", keyPair.publicKey);
        const pubB64 = btoa(String.fromCharCode(...new Uint8Array(rawPub)));
        await WalletStorage.set("encPubKey", pubB64);
      }
    }

    await WalletStorage.set('address', address);
    await WalletStorage.set('backupTxId', txId);
    await WalletStorage.set('keyMode', keyMode);
    await WalletStorage.set('credentialId', credentialId);
    await WalletStorage.set('username', username);
    // ‚úÖ LOG RECOVERY
    await logHistory('system', {
      action: 'wallet_recovered',
      details: `${keyMode === 'prf' ? 'PRF-protected' : 'Wrapped-mode'} wallet recovered from backup TX: ${txId.substring(0, 20)}...`,
      address: address
    });
    document.getElementById('wallet-address').textContent = address;
    document.getElementById('bundlr-txid').textContent = txId;

    showScreen('wallet-screen');
    
    const recoveryType = keyMode === 'prf' ? 'PRF-protected wallet' : 'wrapped-mode wallet';
    setStatus('wallet-status', `‚úÖ ${recoveryType} recovered successfully on this device!`, 'success');

    refreshBalance();

  } catch (err) {
    // ‚ùå LOG ERROR
    await logHistory('error', {
      operation: 'recover_wallet',
      error: err.message,
      details: `Backup TX: ${txId}`
    }, 'failed');
    setStatus('unlock-status', `‚ùå ${err.message}`, 'error');
    console.error(err);
  }
}
  
async function recoverByKeyfile() {
  const fileInput = document.getElementById("keyfile-upload");
  const file = fileInput.files[0];

  if (!file) {
    setStatus("unlock-status", "Please select a keyfile JSON", "error");
    return;
  }

  try {
    const text = await file.text();
    const jwk = JSON.parse(text);

    setStatus("unlock-status", "Importing wallet via WalletCore...", "info");
    
    const result = await WalletCore.importFromKeyfile(jwk);
    // ‚úÖ LOG RECOVERY
    await logHistory('system', {
      action: 'wallet_recovered',
      details: `Keyfile imported and secured. Backup TX: ${result.backupTxId.substring(0, 20)}...`,
      address: result.address
    });

    document.getElementById("wallet-address").textContent = result.address;
    document.getElementById("bundlr-txid").textContent = result.backupTxId;

    showScreen("wallet-screen");
    setStatus("wallet-status", "‚úÖ Keyfile imported & protected with your device!", "success");

    refreshBalance();

  } catch (err) {
    // ‚ùå LOG ERROR
    await logHistory('error', {
      operation: 'recover_by_keyfile',
      error: err.message,
      details: 'Failed to import keyfile'
    }, 'failed');
    setStatus("unlock-status", `‚ùå Error importing keyfile: ${err.message}`, "error");
    console.error(err);
  }
}

async function uploadRecoveryBackup() {
  try {
    setStatus("wallet-status", "Uploading backup via WalletCore...", "info");
    
    const txId = await WalletCore.uploadRecoveryBackup();
    // ‚úÖ LOG BACKUP
    await logHistory('system', {
      action: 'backup_uploaded',
      details: `Recovery backup uploaded to Arweave: ${txId.substring(0, 20)}...`,
      address: document.getElementById('wallet-address').textContent
    });
    document.getElementById("bundlr-txid").textContent = txId;
    setStatus("wallet-status", `‚úÖ Backup stored! TX: ${txId}`, "success");

  } catch (err) {
    // ‚ùå LOG ERROR
    await logHistory('error', {
      operation: 'upload_backup',
      error: err.message,
      details: 'Failed to upload recovery backup to Arweave'
    }, 'failed');
    setStatus("wallet-status", `‚ùå Backup upload failed: ${err.message}`, "error");
    console.error(err);
  }
}

function lockWallet() {
  showLanding();
}

function exportKey() {
  const jwk = WalletCore.getCurrentWallet();
  if (!jwk) return;

  const dataStr = JSON.stringify(jwk, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'arweave-keyfile.json';
  link.click();
  URL.revokeObjectURL(url);

  // ‚úÖ LOG EXPORT (async, no await needed since it's fire-and-forget)
  logHistory('system', {
    action: 'keyfile_exported',
    details: 'Private key exported as JSON file. Store this securely!',
    address: document.getElementById('wallet-address').textContent
  }).catch(err => console.error('Failed to log export:', err));

  setStatus('wallet-status', '‚úÖ Keyfile exported! Keep it extremely safe!', 'success');
}
  
function openScanner() {
  window.location.href = "scanqr.html";
}

window.addEventListener('DOMContentLoaded', () => {
  if (!window.PublicKeyCredential || !navigator.credentials) {
    alert('‚ùå WebAuthn not supported in this browser. Please use a modern browser with biometric authentication support.');
  }

  parsePaymentRequestFromUrl();

  if (pendingPaymentRequest && pendingPaymentRequest.chain === 'arweave') {
    showUnlockScreen();
    setStatus('unlock-status', 'Payment request detected. Please unlock your wallet to continue.', 'info');
  }

  if (pendingSignRequest) {
    showUnlockScreen();
    setStatus('unlock-status', 'Sign request detected. Please unlock your wallet to continue.', 'info');
  }
});

window.requestPayment = function (uri) {
  try {
    if (typeof uri !== "string") throw new Error("URI must be a string.");

    if (uri.toLowerCase().startsWith("ar://")) {
      const parsed = parseArPaymentUri(uri);
      if (!parsed) throw new Error("Invalid AR payment URI");
      pendingPaymentRequest = parsed;
    } else if (uri.toLowerCase().startsWith("ethereum:")) {
      pendingPaymentRequest = { unsupported: true, raw: uri };
    } else {
      throw new Error("Unsupported payment URI format");
    }

    const walletLoaded = WalletCore.getCurrentWallet() ? true : false;

    if (!walletLoaded) {
      showUnlockScreen();
      setStatus(
        "unlock-status",
        "Payment request detected. Please unlock your wallet.",
        "info"
      );
    } else {
      applyPendingPaymentRequestIfAny();
    }

    return true;
  } catch (err) {
    console.error("requestPayment error:", err);
    return false;
  }
};

window.requestSignature = function (message, origin = 'Unknown') {
  try {
    if (typeof message !== "string") throw new Error("Message must be a string.");

    pendingSignRequest = {
      message,
      origin
    };

    const walletLoaded = WalletCore.getCurrentWallet() ? true : false;

    if (!walletLoaded) {
      showUnlockScreen();
      setStatus(
        "unlock-status",
        "Sign request detected. Please unlock your wallet.",
        "info"
      );
    } else {
      applyPendingPaymentRequestIfAny();
    }

    return true;
  } catch (err) {
    console.error("requestSignature error:", err);
    return false;
  }
};
  
function openRequestQR() {
  const address = document.getElementById("wallet-address").textContent.trim();
  if (!address) {
    setStatus('wallet-status', '‚ùå No address loaded', 'error');
    return;
  }

  const url = `https://marko-app.netlify.app/pqr?chain=arweave&address=${address}&token=AR`;
  window.open(url, "_blank");
}

window.showCreateScreen = showCreateScreen;
window.showUnlockScreen = showUnlockScreen;
window.showLanding = showLanding;
window.createWallet = createWallet;
window.unlockWallet = unlockWallet;
window.recoverWallet = recoverWallet;
window.sendTransaction = sendTransaction;
window.parsePaymentRequestFromUrl = parsePaymentRequestFromUrl;
window.applyPendingPaymentRequestIfAny = applyPendingPaymentRequestIfAny;
window.uploadData = uploadData;
window.openHistory = openHistory;
window.exportKey = exportKey;
window.lockWallet = lockWallet;
window.showTab = showTab;
window.recoverByKeyfile = recoverByKeyfile;
window.uploadRecoveryBackup = uploadRecoveryBackup;
window.finishRecovery = finishRecovery;
window.refreshBalance = refreshBalance;
window.signMessage = signMessage;
window.verifySignature = verifySignature;  
window.copySignature = copySignature;
window.openScanner = openScanner;
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ArWallet - Messaging Enabled</title>

  <!-- Material Web Components -->
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
  
  <!-- Arweave + localforage -->
  <script src="https://unpkg.com/arweave@1.15.5/bundles/web.bundle.js"></script>
  <script src="https://unpkg.com/localforage/dist/localforage.min.js"></script>

  <style>
    /* ------------------------------------------
       MATERIAL YOU ‚Äî SYSTEM ADAPTIVE THEME
    ------------------------------------------- */

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* MD3 Light */
      --md-sys-color-primary: #6750A4;
      --md-sys-color-on-primary: #ffffff;
      --md-sys-color-primary-container: #EADDFF;
      --md-sys-color-on-primary-container: #21005D;

      --md-sys-color-secondary: #625B71;
      --md-sys-color-on-secondary: #ffffff;
      --md-sys-color-secondary-container: #E8DEF8;

      --md-sys-color-surface: #FFFBFE;
      --md-sys-color-on-surface: #1C1B1F;

      --md-sys-color-surface-variant: #E7E0EC;
      --md-sys-color-on-surface-variant: #49454F;

      --md-sys-color-outline: #79747E;
      --md-sys-color-error: #B3261E;

      --radius-lg: 28px;
      --radius-md: 18px;
      --radius-sm: 12px;

      --elev-1: 0 1px 2px rgba(0, 0, 0, 0.12);
      --elev-2: 0 3px 6px rgba(0, 0, 0, 0.16);
      --elev-3: 0 6px 10px rgba(0, 0, 0, 0.20);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --md-sys-color-primary: #D0BCFF;
        --md-sys-color-on-primary: #381E72;
        --md-sys-color-primary-container: #4F378B;
        --md-sys-color-on-primary-container: #EADDFF;

        --md-sys-color-secondary: #CCC2DC;
        --md-sys-color-on-secondary: #332D41;
        --md-sys-color-secondary-container: #4A4458;

        --md-sys-color-surface: #1C1B1F;
        --md-sys-color-on-surface: #E6E1E5;

        --md-sys-color-surface-variant: #49454F;
        --md-sys-color-on-surface-variant: #CAC4D0;

        --md-sys-color-outline: #938F99;
        --md-sys-color-error: #F2B8B5;
      }
    }

    body {
      background: var(--md-sys-color-surface);
      color: var(--md-sys-color-on-surface);
      font-family: "Roboto", system-ui, sans-serif;
      padding: 32px 16px 80px;
      display: flex;
      justify-content: center;
    }

    .container {
      width: 100%;
      max-width: 860px;
      background: var(--md-sys-color-surface);
      border-radius: var(--radius-lg);
      padding: 36px;
      box-shadow: var(--elev-2);
      margin-bottom: 80px;
    }

    /* -------------------------------------------------
       HEADER
    ------------------------------------------------- */
    .header h1 {
      text-align: center;
      font-size: 32px;
      margin-bottom: 16px;
    }

    .security-badge {
      background: var(--md-sys-color-surface-variant);
      color: var(--md-sys-color-on-surface-variant);
      padding: 18px;
      border-radius: var(--radius-md);
      font-size: 15px;
      margin-bottom: 36px;
      border: 1px solid var(--md-sys-color-outline);
    }

    /* -------------------------------------------------
       BUTTONS (UPGRADED TO MWC LOOK)
    ------------------------------------------------- */
    .btn {
      width: 100%;
      padding: 16px;
      border-radius: var(--radius-md);
      font-size: 16px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 12px 0;
      transition: background 0.2s, transform 0.1s;
      box-shadow: var(--elev-1);
    }

    .btn-primary {
      background: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
    }

    .btn-secondary {
      background: var(--md-sys-color-secondary-container);
      color: var(--md-sys-color-on-secondary-container);
    }

    .btn-danger {
      background: var(--md-sys-color-error);
      color: white;
    }

    .btn-success {
      background: #4CAF50;
      color: white;
    }

    .btn:hover:not(:disabled) {
      transform: scale(1.01);
      filter: brightness(1.05);
    }

    /* -------------------------------------------------
       INPUT GROUPS
    ------------------------------------------------- */
    .input-group {
      margin-bottom: 24px;
    }

    .input-group label {
      display: block;
      margin-bottom: 6px;
      font-size: 14px;
      font-weight: 500;
    }

    .input-group input,
    .input-group textarea,
    .input-group select {
      width: 100%;
      padding: 14px;
      border-radius: var(--radius-md);
      border: 1px solid var(--md-sys-color-outline);
      background: var(--md-sys-color-surface-variant);
      color: var(--md-sys-color-on-surface);
      font-size: 16px;
    }

    .input-group input:focus,
    .input-group textarea:focus,
    .input-group select:focus {
      outline: 2px solid var(--md-sys-color-primary);
      background: var(--md-sys-color-surface);
    }

    /* -------------------------------------------------
       STATUS BANNERS ‚Äî visible in both themes
    ------------------------------------------------- */
    .status {
      padding: 18px;
      border-radius: var(--radius-md);
      margin-top: 20px;
      font-size: 15px;
      line-height: 1.4;
      font-weight: 500;
    }

    .status-info {
      background: rgba(100, 150, 255, 0.18);
      color: var(--md-sys-color-on-surface);
    }

    .status-success {
      background: rgba(0, 200, 83, 0.18);
      color: #0d4d0d;
    }

    .status-error {
      background: rgba(255, 82, 82, 0.18);
      color: #7b0000;
    }

    /* -------------------------------------------------
       TABS (MD3-style underline navigation)
    ------------------------------------------------- */
    .tabs {
      display: flex;
      gap: 6px;
      border-bottom: 2px solid var(--md-sys-color-outline);
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .tab {
      padding: 12px 18px;
      border: none;
      background: none;
      cursor: pointer;
      font-size: 15px;
      color: var(--md-sys-color-on-surface);
      border-bottom: 3px solid transparent;
      transition: all 0.25s;
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .tab.active {
      color: var(--md-sys-color-primary);
      border-bottom-color: var(--md-sys-color-primary);
      font-weight: 600;
    }

    /* -------------------------------------------------
       CARDS
    ------------------------------------------------- */
    .wallet-info {
      background: var(--md-sys-color-surface-variant);
      padding: 20px;
      border-radius: var(--radius-md);
      margin-bottom: 20px;
      box-shadow: var(--elev-1);
    }

    .wallet-info-value {
      font-family: monospace;
      padding: 10px;
      background: var(--md-sys-color-surface);
      border-radius: var(--radius-sm);
      word-break: break-all;
    }

    .balance-card {
      background: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
      padding: 26px;
      border-radius: var(--radius-lg);
      text-align: center;
      margin-bottom: 28px;
      box-shadow: var(--elev-3);
    }

    .balance-amount {
      font-size: 44px;
      font-weight: 700;
      margin-top: 6px;
    }

    /* -------------------------------------------------
       FAB (Floating Action Button)
    ------------------------------------------------- */
    #fabScan {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 68px;
      height: 68px;
      border: none;
      border-radius: 50%;
      background: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
      font-size: 34px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: var(--elev-3);
      cursor: pointer;
    }

    .hidden {
      display: none !important;
    }
    
    .material-symbols-rounded {
      font-family: 'Material Symbols Rounded';
      font-weight: normal;
      font-style: normal;
      font-size: 24px;
      line-height: 1;
      letter-spacing: normal;
      text-transform: none;
      display: inline-block;
      white-space: nowrap;
      word-wrap: normal;
      direction: ltr;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
      font-feature-settings: 'liga';
      vertical-align: middle;
    }

    .btn .material-symbols-rounded {
      font-size: 24px;
      margin-right: 6px;
    }

    .tab .material-symbols-rounded {
      font-size: 22px;
      margin-right: 6px;
    }

    #fabScan .material-symbols-rounded {
      font-size: 36px;
    }

    .balance-card .btn .material-symbols-rounded {
      font-size: 20px;
    }

    #fiat-row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 6px;
      margin-top: 6px;
      font-size: 20px;
      opacity: 0.9;
    }

    #fiat-select-inline {
      appearance: none;
      padding: 6px 28px 6px 10px;
      border-radius: 12px;
      border: 1px solid var(--md-sys-color-outline);
      background: var(--md-sys-color-surface-variant);
      color: var(--md-sys-color-on-surface);
      font-size: 16px;
      position: relative;
    }

    /* ---------- Toast Notifications (Material You) ---------- */
    #toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      z-index: 99999;
      pointer-events: none;
    }

    .toast {
      padding: 14px 20px;
      border-radius: 18px;
      font-size: 16px;
      font-weight: 500;
      color: white;
      background: rgba(0,0,0,0.85);
      backdrop-filter: blur(6px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.25s ease, transform 0.25s ease;
      max-width: 90vw;
      min-width: 240px;
      pointer-events: auto;
      text-align: center;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0px);
    }

    .toast-success { background: #4CAF50; }
    .toast-error   { background: #E53935; }
    .toast-info    { background: #2196F3; }

    @media (max-width: 768px) {
      #toast-container {
        top: 20px;
        bottom: auto;
        left: 50%;
        transform: translateX(-50%);
      }

      .toast {
        transform: translateY(-10px);
      }

      .toast.show {
        transform: translateY(0px);
      }
    }

    /* -------------------------------------------------
       MESSAGING STYLES
    ------------------------------------------------- */
    .messages-container {
      display: flex;
      gap: 16px;
      height: 600px;
    }

    .conversations-list {
      flex: 0 0 280px;
      background: var(--md-sys-color-surface-variant);
      border-radius: var(--radius-md);
      padding: 12px;
      overflow-y: auto;
    }

    .conversation-item {
      padding: 14px;
      margin-bottom: 8px;
      background: var(--md-sys-color-surface);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
    }

    .conversation-item:hover {
      background: var(--md-sys-color-primary-container);
    }

    .conversation-item.active {
      border-color: var(--md-sys-color-primary);
      background: var(--md-sys-color-primary-container);
    }

    .conversation-item .contact-name {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 14px;
    }

    .conversation-item .last-message {
      font-size: 13px;
      opacity: 0.7;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .conversation-item .unread-indicator {
      width: 10px;
      height: 10px;
      background: #E53935;
      border-radius: 50%;
      display: inline-block;
      margin-left: 8px;
    }

    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--md-sys-color-surface);
      border-radius: var(--radius-md);
      overflow: hidden;
    }

    .chat-header {
      padding: 16px;
      background: var(--md-sys-color-surface-variant);
      border-bottom: 1px solid var(--md-sys-color-outline);
      font-weight: 600;
    }

    .messages-display {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .message-bubble {
      max-width: 70%;
      padding: 12px 16px;
      border-radius: var(--radius-md);
      word-wrap: break-word;
    }

    .message-bubble.sent {
      align-self: flex-end;
      background: var(--md-sys-color-primary);
      color: var(--md-sys-color-on-primary);
    }

    .message-bubble.received {
      align-self: flex-start;
      background: var(--md-sys-color-surface-variant);
      color: var(--md-sys-color-on-surface-variant);
    }

    .message-time {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 4px;
    }

    .message-status {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 4px;
      font-style: italic;
    }

    .message-input-area {
      padding: 16px;
      background: var(--md-sys-color-surface-variant);
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .message-input-area textarea {
      flex: 1;
      min-height: 44px;
      max-height: 120px;
      resize: none;
      padding: 12px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--md-sys-color-outline);
      background: var(--md-sys-color-surface);
      color: var(--md-sys-color-on-surface);
      font-family: inherit;
    }

    .message-input-area button {
      width: auto;
      padding: 12px 24px;
      margin: 0;
    }

    .new-conversation-form {
      padding: 20px;
      background: var(--md-sys-color-surface-variant);
      border-radius: var(--radius-md);
      margin-bottom: 16px;
    }

    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: var(--md-sys-color-on-surface-variant);
      opacity: 0.6;
    }

    .empty-state .material-symbols-rounded {
      font-size: 64px;
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .messages-container {
        flex-direction: column;
        height: auto;
      }

      .conversations-list {
        flex: none;
        max-height: 300px;
      }

      .chat-area {
        min-height: 400px;
      }
    }
    .group-item {
  padding: 14px;
  margin-bottom: 8px;
  background: var(--md-sys-color-surface);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid transparent;
  position: relative;
}

.group-item:hover {
  background: var(--md-sys-color-surface-variant);
}

.group-item.active {
  border-color: var(--md-sys-color-primary);
  background: var(--md-sys-color-primary-container);
}

.group-name {
  font-weight: 600;
  color: var(--md-sys-color-on-surface);
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.group-members-count {
  font-size: 12px;
  color: var(--md-sys-color-on-surface-variant);
  opacity: 0.7;
}

.group-last-message {
  font-size: 13px;
  color: var(--md-sys-color-on-surface-variant);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  margin-top: 4px;
}

.security-warning {
  animation: fadeIn 0.3s;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

.back-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 8px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--md-sys-color-on-surface);
  transition: background 0.2s;
}

.back-btn:hover {
  background: var(--md-sys-color-surface-variant);
}

.chat-header-container {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 16px;
  background: var(--md-sys-color-surface);
  border-bottom: 1px solid var(--md-sys-color-outline);
  margin-bottom: 16px;
}

.chat-header-container h3 {
  flex: 1;
  margin: 0;
}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üõ°Ô∏è ArWallet</h1>
    </div>

    <div class="security-badge">
      <strong>100% Non-Custodial</strong>
      Your private key is generated in your browser, encrypted with your passkey, and stored on Arweave.
    </div>

    <div id="landing-screen">
      <button class="btn btn-primary" onclick="showCreateScreen()">
        <span class="material-symbols-rounded">add_circle</span>
        Create New Wallet
      </button>
      <button class="btn btn-secondary" onclick="showUnlockScreen()">
        <span class="material-symbols-rounded">lock_open</span>
        Unlock Existing Wallet
      </button>
    </div>

    <div id="create-screen" class="hidden">
      <h2 style="margin-bottom: 20px;">Create Wallet</h2>
      <div class="input-group">
        <label for="username">Username</label>
        <input type="text" id="username" placeholder="Enter username">
      </div>
      <button class="btn btn-primary" onclick="createWallet()" id="create-btn">
        <span class="material-symbols-rounded">add_circle</span>
        Create Wallet
      </button>
      <button class="btn btn-secondary" onclick="showLanding()">
        <span class="material-symbols-rounded">arrow_back</span>
        Back
      </button>
      <div id="create-status"></div>
    </div>

    <div id="unlock-screen" class="hidden">
      <h2 style="margin-bottom: 20px;">Unlock Wallet</h2>
      <p style="color: #4a5568; margin-bottom: 20px;">Authenticate with your device to decrypt and access your wallet.</p>
      <button class="btn btn-primary" onclick="unlockWallet()" id="unlock-btn">
        <span class="material-symbols-rounded">lock_open</span>
        Unlock with Biometrics
      </button>
      <button class="btn btn-secondary" onclick="showLanding()">
        <span class="material-symbols-rounded">arrow_back</span>
        Back
      </button>

      <div class="recovery-section">
        <h3>Recovery Mode</h3>
        <div class="input-group" style="margin-top:20px;">
          <label for="keyfile-upload">Recover from Keyfile (for new devices)</label>
          <input type="file" id="keyfile-upload" accept="application/json">
        </div>
        <button class="btn btn-success" onclick="recoverByKeyfile()" id="keyfile-btn">
          <span class="material-symbols-rounded">upload_file</span>
          Import Keyfile
        </button>

        <div class="input-group">
          <label for="recovery-address">Wallet Address</label>
          <input type="text" id="recovery-address" placeholder="Enter your Arweave address">
        </div>
        <button class="btn btn-success" onclick="recoverWallet()" id="recovery-btn">
          <span class="material-symbols-rounded">search</span>
          Search for Wallet
        </button>
      </div>

      <button class="btn btn-primary" onclick="uploadRecoveryBackup()">
        <span class="material-symbols-rounded">backup</span>
        Re-upload Backup to Arweave
      </button>
      <div id="unlock-status"></div>
    </div>

    <div id="wallet-screen" class="hidden">
      <h2 style="margin-bottom: 20px;">Wallet Active</h2>

      <div class="balance-card">
        <div class="balance-label">Balance</div>
        <div class="balance-amount" id="balance-display">--</div>
        <div id="fiat-row">
          <span id="fiat-value">‚âà --</span>
          <select id="fiat-select-inline">
            <option value="usd">USD</option>
            <option value="eur">EUR</option>
            <option value="gbp">GBP</option>
            <option value="jpy">JPY</option>
            <option value="chf">CHF</option>
          </select>
        </div>
        <button class="btn" onclick="refreshBalance()" style="background: rgba(255,255,255,0.2); margin: 12px auto 0; width: auto; padding: 8px 20px;">
          <span class="material-symbols-rounded">refresh</span>
          Refresh
        </button>
      </div>

      <div class="wallet-info">
        <div class="wallet-info-item">
          <div class="wallet-info-label">Address</div>
          <div class="wallet-info-value" id="wallet-address"></div>
        </div>
        <div class="wallet-info-item">
          <div class="wallet-info-label">Backup TX ID</div>
          <div class="wallet-info-value" id="bundlr-txid"></div>
        </div>
      </div>

      <div class="tabs">
        <button class="tab active" onclick="showTab('send')">
          <span class="material-symbols-rounded">send</span>
          Send
        </button>
        <button class="tab" onclick="showTab('data')">
          <span class="material-symbols-rounded">upload_file</span>
          Upload Data
        </button>
        <button class="tab" onclick="showTab('sign')">
          <span class="material-symbols-rounded">edit_note</span>
          Sign Message
        </button>
        <button class="tab" onclick="showTab('messages')">
          <span class="material-symbols-rounded">mail</span>
          Messages
          <span id="unread-badge" class="hidden" style="background: #E53935; color: white; border-radius: 10px; padding: 2px 6px; font-size: 11px; margin-left: 4px;">0</span>
        </button>
       <div class="tab" data-tab="groups" onclick="showTab('groups')">
        <span class="material-symbols-rounded">groups</span>
        Groups
      </div>
      </div>
       
      <!-- Existing tabs: Send, Data, Sign (keeping original code) -->
      <div id="send-tab" class="tab-content">
        <div class="input-group">
          <label for="send-address">Recipient Address</label>
          <input type="text" id="send-address" placeholder="Arweave address">
        </div>
        <div class="input-group">
          <label for="send-amount">Amount (AR)</label>
          <input type="number" id="send-amount" placeholder="0.001" step="0.001" min="0">
        </div>
        <button class="btn btn-primary" onclick="sendTransaction()">
          <span class="material-symbols-rounded">send</span>
          Send AR
        </button>
      </div>

      <div id="data-tab" class="tab-content hidden">
        <div class="input-group">
          <label for="data-content">Data Content</label>
          <textarea id="data-content" placeholder="Enter data to upload to Arweave..."></textarea>
        </div>
        
        <div class="input-group">
          <label for="file-input">Optional File (max 95 KB)</label>
          <input id="file-input" type="file" />
        </div>

        <div class="input-group">
          <label for="data-encryption-mode">Encryption</label>
          <select id="data-encryption-mode">
            <option value="none">üîì No encryption</option>
            <option value="self">üîê Encrypt for me</option>
            <option value="password">üîë Encrypt with password</option>
            <option value="recipient">ü§ù Encrypt for another user</option>
          </select>
        </div>
        
        <div class="input-group hidden" id="password-field">
          <label for="data-password">Password (AES-GCM)</label>
          <input type="text" id="data-password" placeholder="Enter password">
        </div>

        <div class="input-group hidden" id="recipient-field">
          <label for="recipient-address">Recipient Arweave Address</label>
          <input type="text" id="recipient-address" placeholder="Recipient address">
        </div>

        <div class="input-group">
          <label for="content-type">Content Type</label>
          <input type="text" id="content-type" placeholder="text/plain" value="text/plain">
        </div>
        
        <div class="input-group">
          <label>Custom Tags (optional)</label>
          <input type="text" id="tag-key-1" placeholder="Tag name" style="margin-bottom: 8px;">
          <input type="text" id="tag-value-1" placeholder="Tag value">
        </div>
        
        <button class="btn btn-primary" onclick="uploadData()">
          <span class="material-symbols-rounded">upload_file</span>
          Upload to Arweave
        </button>
      </div>

      <div id="sign-tab" class="tab-content hidden">
        <div class="input-group">
          <label for="sign-message">Message to Sign</label>
          <textarea id="sign-message" placeholder="Enter message to sign with your wallet..."></textarea>
        </div>
        <button class="btn btn-primary" onclick="signMessage()">
          <span class="material-symbols-rounded">edit_note</span>
          Sign Message
        </button>
        
        <div id="signature-result" style="display: none; margin-top: 20px;">
          <div class="wallet-info">
            <div class="wallet-info-item">
              <div class="wallet-info-label">Signed Message</div>
              <div class="wallet-info-value" id="signed-message"></div>
            </div>
            <div class="wallet-info-item">
              <div class="wallet-info-label">Signature</div>
              <div class="wallet-info-value" id="signature-value"></div>
            </div>
            <div class="wallet-info-item">
              <div class="wallet-info-label">Public Key (Owner)</div>
              <div class="wallet-info-value" id="public-key-value"></div>
            </div>
            <div class="wallet-info-item">
              <div class="wallet-info-label">Timestamp</div>
              <div class="wallet-info-value" id="signature-timestamp"></div>
            </div>
          </div>
          <div class="button-group">
            <button class="btn btn-secondary" onclick="copySignature()">
              <span class="material-symbols-rounded">content_copy</span>
              Copy JSON
            </button>
            <button class="btn btn-success" onclick="verifySignature()">
              <span class="material-symbols-rounded">check_circle</span>
              Verify Signature
            </button>
          </div>
        </div>
      </div>

      <!-- NEW: Messages Tab -->
      <div id="messages-tab" class="tab-content hidden">
        <div class="new-conversation-form">
          <h3 style="margin-bottom: 12px;">New Message</h3>
          <div class="input-group" style="margin-bottom: 12px;">
            <label for="new-msg-address">Recipient Address</label>
            <input type="text" id="new-msg-address" placeholder="Enter Arweave address">
          </div>
          <button class="btn btn-primary" onclick="startNewConversation()" style="width: auto; padding: 10px 20px;">
            <span class="material-symbols-rounded">add</span>
            Start Conversation
          </button>
        </div>

        <div class="messages-container">
          <div class="conversations-list" id="conversations-list">
            <div class="empty-state">
              <span class="material-symbols-rounded">forum</span>
              <p>No conversations yet</p>
            </div>
          </div>

          <div class="chat-area" id="chat-area">
            <div class="chat-header" id="chat-header">
              Select a conversation
            </div>
            <div class="messages-display" id="messages-display">
              <div class="empty-state">
                <span class="material-symbols-rounded">chat</span>
                <p>Select a conversation to start messaging</p>
              </div>
            </div>
            <div class="message-input-area hidden" id="message-input-area">
              <textarea id="message-input" placeholder="Type your message..." rows="1"></textarea>
              <button class="btn btn-primary" onclick="sendMessage()">
                <span class="material-symbols-rounded">send</span>
              </button>
            </div>
          </div>
          <div id="groups-tab" class="tab-content">
  <h2>Groups</h2>
  
  <div class="security-warning" style="background: #fff3cd; border: 1px solid #ffc107; padding: 16px; border-radius: 8px; margin-bottom: 20px;">
    <div style="display: flex; gap: 12px; align-items: start;">
      <span class="material-symbols-rounded" style="color: #856404;">warning</span>
      <div>
        <strong style="color: #856404;">Security Notice</strong>
        <p style="margin: 8px 0 0 0; color: #856404; font-size: 14px;">
          Groups use shared encryption keys. Anyone with the group link can read messages. 
          For private conversations, use direct 1-to-1 messaging instead.
        </p>
      </div>
    </div>
  </div>

  <div class="button-group" style="margin-bottom: 20px;">
    <button class="btn btn-primary" onclick="showCreateGroupModal()">
      <span class="material-symbols-rounded">add</span>
      Create New Group
    </button>
    <button class="btn btn-secondary" onclick="showJoinGroupModal()">
      <span class="material-symbols-rounded">group_add</span>
      Join Group
    </button>
  </div>

  <div id="groups-list"></div>

  <div id="group-chat-container" class="hidden">
    <div class="chat-header-container">
      <button class="back-btn" onclick="closeGroupChat()">
        <span class="material-symbols-rounded">arrow_back</span>
      </button>
      <h3 id="group-chat-header">Group Name</h3>
      <button class="icon-btn" onclick="showGroupInfo()">
        <span class="material-symbols-rounded">info</span>
      </button>
    </div>

    <div id="group-messages-display" class="messages-display"></div>

    <div id="group-message-input-area" class="message-input-area">
      <textarea 
        id="group-message-input" 
        placeholder="Type a message..." 
        rows="1"
      ></textarea>
      <button class="icon-btn" onclick="sendGroupMessage()">
        <span class="material-symbols-rounded">send</span>
      </button>
    </div>
  </div>
</div>
        </div>


        <button class="btn btn-secondary" onclick="checkForNewMessages()" style="margin-top: 16px;">
          <span class="material-symbols-rounded">refresh</span>
          Check for New Messages
        </button>
      </div>

      <div class="button-group" style="margin-top: 20px;">
        <button class="btn btn-success" onclick="exportKey()">
          <span class="material-symbols-rounded">download</span>
          Export Key
        </button>
        <button class="btn btn-secondary" onclick="openHistory()">
          <span class="material-symbols-rounded">history</span>
          View History
        </button>
        <button class="btn btn-danger" onclick="lockWallet()">
          <span class="material-symbols-rounded">lock</span>
          Lock Wallet
        </button>
        <button class="btn btn-primary" onclick="copyContactLink()">
        <span class="material-symbols-rounded">share</span>
        Share Contact Link
      </button>
        <button class="btn btn-secondary" onclick="showContactQR()">
          <span class="material-symbols-rounded">qr_code_2</span>
            Show Share Contact QR
        </button>
        <button class="btn btn-secondary" onclick="openRequestQR()">
          <span class="material-symbols-rounded">qr_code</span>
          Request (QR)
        </button>
      </div>

      <div id="wallet-status"></div>
    </div>
  </div>
  
  <div id="toast-container"></div>

  <button id="fabScan" onclick="openScanner()">
    <span class="material-symbols-rounded">qr_code_scanner</span>
  </button>
<!-- Create Group Modal -->
<div id="create-group-modal" class="name-modal">
  <div class="name-modal-content">
    <h3>Create New Group</h3>
    <div class="input-group">
      <label for="group-name-input">Group Name</label>
      <input type="text" id="group-name-input" placeholder="e.g., Family, Friends, Team..." maxlength="50">
    </div>
    <div class="security-warning" style="margin: 16px 0; padding: 12px; background: #fff3cd; border-radius: 8px;">
      <p style="margin: 0; font-size: 13px; color: #856404;">
        ‚ö†Ô∏è Groups use shared encryption. Anyone with the link can read all messages.
      </p>
    </div>
    <div class="name-modal-buttons">
      <button class="btn btn-secondary" onclick="closeCreateGroupModal()">Cancel</button>
      <button class="btn btn-primary" onclick="createGroup()">Create Group</button>
    </div>
  </div>
</div>

<!-- Join Group Modal -->
<div id="join-group-modal" class="name-modal">
  <div class="name-modal-content">
    <h3>Join Group</h3>
    <div class="input-group">
      <label for="group-link-input">Group Link</label>
      <input type="text" id="group-link-input" placeholder="Paste group invitation link...">
    </div>
    <p style="font-size: 13px; color: var(--md-sys-color-on-surface-variant); margin-top: 8px;">
      The link should look like: https://wallet.com/?group=...#password=...
    </p>
    <div class="name-modal-buttons">
      <button class="btn btn-secondary" onclick="closeJoinGroupModal()">Cancel</button>
      <button class="btn btn-primary" onclick="joinGroup()">Join Group</button>
    </div>
  </div>
</div>

<!-- Group Info Modal -->
<div id="group-info-modal" class="name-modal">
  <div class="name-modal-content">
    <h3>Group Information</h3>
    <div id="group-info-content"></div>
    <div class="name-modal-buttons">
      <button class="btn btn-danger" onclick="leaveGroup()">Leave Group</button>
      <button class="btn btn-secondary" onclick="closeGroupInfoModal()">Close</button>
    </div>
  </div>
</div>
  <script>
// ORIGINAL WALLET CODE CONTINUES HERE - I'm including all the original functionality
// plus the new messaging features

console.log("SCRIPT LOADED");
window.TEST_FLAG = true;

// ---------------------------------------------------------------------------
//  CONFIG & ARWEAVE INIT
// ---------------------------------------------------------------------------
const CLOUD_FUNCTION_URL = 'https://marko-app.netlify.app/.netlify/functions/arload';
const WALLET_APP_NAME = 'ArweaveWallet-v1';
const MESSAGING_APP_NAME = 'ArweaveWallet-Messages-v1';

const FIAT_CACHE = {
  timestamp: 0,
  prices: {}
};
const FIAT_TTL = 1 * 60 * 1000;

let arweave = null;
  
try {
  if (window.Arweave) {
    arweave = Arweave.init({ host: 'arweave.net', port: 443, protocol: 'https' });
  }
} catch (e) {
  console.error('Failed to init Arweave:', e);
}

const STORAGE_KEYS = {
  credentialId: 'credentialId',
  address: 'address',
  backupTxId: 'backupTxId',
  keyMode: 'keyMode',
  aesKeyHex: 'aesKeyHex',
  prfSaltHex: 'prfSaltHex',
  username: 'username',
  encPubKey: 'encPubKey',
  encPrivKeyJwk: 'encPrivKeyJwk',
  encPrivKeyEncrypted: 'encPrivKeyEncrypted',
  lastMessageCheck: 'lastMessageCheck'
};

let pendingPaymentRequest = null;
let pendingSignRequest = null;
let currentConversation = null;
let messagePollingInterval = null;
let pendingContactRequest = null;

// ---------------------------------------------------------------------------
//  STORAGE ABSTRACTION
// ---------------------------------------------------------------------------
const WalletStorage = (function() {
  const prefix = 'biowallet:';
  const hasLocalforage = typeof window !== 'undefined' && window.localforage;

  async function get(key) {
    const full = prefix + key;
    return hasLocalforage ? await window.localforage.getItem(full) : localStorage.getItem(full);
  }

  async function set(key, value) {
    const full = prefix + key;
    hasLocalforage ? await window.localforage.setItem(full, value) : localStorage.setItem(full, value);
  }

  async function remove(key) {
    const full = prefix + key;
    hasLocalforage ? await window.localforage.removeItem(full) : localStorage.removeItem(full);
  }

  return { get, set, remove };
})();

// ---------------------------------------------------------------------------
//  MESSAGING STORAGE
// ---------------------------------------------------------------------------
const MessageStorage = {
  async getMessages(threadId) {
    const key = `messages:${threadId}`;
    const stored = await localforage.getItem(key);
    return stored ? JSON.parse(stored) : [];
  },

  async saveMessage(message) {
    const threadId = message.threadId;
    const messages = await this.getMessages(threadId);
    messages.push(message);
    messages.sort((a, b) => a.timestamp - b.timestamp);
    await localforage.setItem(`messages:${threadId}`, JSON.stringify(messages));
  },

  async getConversations() {
    const stored = await localforage.getItem('conversations');
    return stored ? JSON.parse(stored) : [];
  },

  async saveConversation(conversation) {
    const conversations = await this.getConversations();
    const index = conversations.findIndex(c => c.threadId === conversation.threadId);
    
    if (index >= 0) {
      conversations[index] = conversation;
    } else {
      conversations.push(conversation);
    }
    
    conversations.sort((a, b) => b.lastMessageTime - a.lastMessageTime);
    await localforage.setItem('conversations', JSON.stringify(conversations));
  },

  async markAsRead(threadId) {
    const conversations = await this.getConversations();
    const conv = conversations.find(c => c.threadId === threadId);
    if (conv) {
      conv.unread = 0;
      await localforage.setItem('conversations', JSON.stringify(conversations));
      await updateUnreadBadge();
    }
  },

  async getContactName(address) {
    const contacts = await localforage.getItem('contact-names');
    const parsed = contacts ? JSON.parse(contacts) : {};
    return parsed[address] || null;
  },

  async setContactName(address, name) {
    const contacts = await localforage.getItem('contact-names');
    const parsed = contacts ? JSON.parse(contacts) : {};
    parsed[address] = name.trim();
    await localforage.setItem('contact-names', JSON.stringify(parsed));
  },

  async deleteContactName(address) {
    const contacts = await localforage.getItem('contact-names');
    const parsed = contacts ? JSON.parse(contacts) : {};
    delete parsed[address];
    await localforage.setItem('contact-names', JSON.stringify(parsed));
  }
};
    
// =============================================================================
// GROUPS FEATURE - Multi-party encrypted chat with symmetric keys
// WARNING: Groups are less secure than 1-to-1 messaging!
// =============================================================================

const GroupStorage = {
  async getGroups() {
    const groups = await localforage.getItem('groups');
    return groups ? JSON.parse(groups) : [];
  },

  async saveGroup(group) {
    const groups = await this.getGroups();
    const existing = groups.findIndex(g => g.id === group.id);
    
    if (existing >= 0) {
      groups[existing] = group;
    } else {
      groups.push(group);
    }
    
    await localforage.setItem('groups', JSON.stringify(groups));
  },

  async deleteGroup(groupId) {
    const groups = await this.getGroups();
    const filtered = groups.filter(g => g.id !== groupId);
    await localforage.setItem('groups', JSON.stringify(filtered));
    await localforage.removeItem(`group-messages:${groupId}`);
  },

  async getGroupMessages(groupId) {
    const messages = await localforage.getItem(`group-messages:${groupId}`);
    return messages ? JSON.parse(messages) : [];
  },

  async saveGroupMessage(groupId, message) {
    const messages = await this.getGroupMessages(groupId);
    messages.push(message);
    await localforage.setItem(`group-messages:${groupId}`, JSON.stringify(messages));
  },

  async getGroup(groupId) {
    const groups = await this.getGroups();
    return groups.find(g => g.id === groupId);
  }
};    
// ---------------------------------------------------------------------------
//  UTILS (keeping all original utils)
// ---------------------------------------------------------------------------
function bytesToHex(bytes) {
  return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

function hexToBytes(hex) {
  if (!hex || hex.length % 2 !== 0) throw new Error('Invalid hex string');
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
  }
  return bytes;
}

function parseArPaymentUri(uri) {
  const m = uri.match(/^ar:\/\/([^?]+)(\?(.*))?$/i);
  if (!m) return null;

  const address = m[1];
  const qs = m[3] || '';
  const params = new URLSearchParams(qs);

  const amount = params.get('amount') || '';
  const message = params.get('message') || '';
  const token = params.get('token') || '';

  if (token && token.toUpperCase() !== 'AR') {
    return {
      chain: 'arweave',
      address,
      amount,
      message,
      unsupportedToken: token
    };
  }

  return {
    chain: 'arweave',
    address,
    amount,
    message
  };
}

function parsePaymentRequestFromUrl() {
  const url = new URL(window.location.href);
  const params = url.searchParams;

  const signMessage = params.get('signMessage') || params.get('sign');
  if (signMessage) {
    const options = {};
    
    const domain = params.get('domain');
    const statement = params.get('statement');
    const uri = params.get('uri');
    const nonce = params.get('nonce');
    const chainId = params.get('chainId');
    const issuedAt = params.get('issuedAt');
    const expirationTime = params.get('expirationTime');
    const requestId = params.get('requestId');
    
    if (domain) options.domain = domain;
    if (statement) options.statement = statement;
    if (uri) options.uri = uri;
    if (nonce) options.nonce = nonce;
    if (chainId) options.chainId = chainId;
    if (issuedAt) options.issuedAt = issuedAt;
    if (expirationTime) options.expirationTime = expirationTime;
    if (requestId) options.requestId = requestId;
    
    const resources = [];
    let i = 0;
    while (params.has(`resource${i}`)) {
      resources.push(params.get(`resource${i}`));
      i++;
    }
    if (resources.length > 0) options.resources = resources;
    
    pendingSignRequest = {
      message: decodeURIComponent(signMessage),
      origin: params.get('origin') || params.get('app') || 'Unknown',
      callbackUrl: params.get('callback') || params.get('redirect'),
      options
    };
  }

  const link = params.get('link');

  if (link) {
    if (link.toLowerCase().startsWith('ar://')) {
      const parsed = parseArPaymentUri(link);
      if (parsed) {
        pendingPaymentRequest = parsed;
      }
    } else if (link.toLowerCase().startsWith('ethereum:')) {
      pendingPaymentRequest = { chain: 'evm', raw: link, unsupported: true };
      console.warn('EVM payments not yet supported in this wallet. Link:', link);
    }
  } else {
    const chain = (params.get('chain') || '').toLowerCase();
    const address = params.get('address');
    const amount = params.get('amount') || '';
    const message = params.get('message') || '';

    if (chain === 'arweave' && address) {
      pendingPaymentRequest = {
        chain: 'arweave',
        address,
        amount,
        message
      };
    }
  }

  if (pendingPaymentRequest && pendingPaymentRequest.unsupported) {
    const msg = 'Received EVM payment request, but this wallet currently only supports Arweave payments.';
    console.warn(msg);
    const unlockStatus = document.getElementById('unlock-status');
    if (unlockStatus) {
      unlockStatus.innerHTML = `<div class="status status-info">${msg}</div>`;
    }
  }
}

function parseContactRequestFromUrl() {
  const url = new URL(window.location.href);
  const params = url.searchParams;
  const contactAddress = params.get('contact');
  const contactName = params.get('name');

  if (contactAddress && /^[a-zA-Z0-9_-]{43}$/.test(contactAddress)) {
    pendingContactRequest = {
      address: contactAddress,
      name: contactName ? decodeURIComponent(contactName) : null
    };
  }
}
    
async function uploadToCloudFunction(data, tagsInput) {
  let extraTags = {};
  if (Array.isArray(tagsInput)) {
    tagsInput.forEach(t => {
      if (t && t.name && t.value != null) extraTags[t.name] = String(t.value);
    });
  } else if (tagsInput && typeof tagsInput === 'object') {
    extraTags = { ...tagsInput };
  }

  const response = await fetch(CLOUD_FUNCTION_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content: JSON.stringify(data), isBase64: false, encrypt: false, extraTags })
  });

  const result = await response.json();
  if (!response.ok || !result.success) {
    throw new Error(result.message || `Cloud function error: ${response.status}`);
  }
  return result;
}

async function applyPendingPaymentRequestIfAny() {
  if (pendingSignRequest) {
    const { message, origin, options = {}, callbackUrl } = pendingSignRequest;
    pendingSignRequest = null;

    showScreen('wallet-screen');
    showTab('sign');

    const messageInput = document.getElementById('sign-message');
    if (messageInput) {
      messageInput.value = message;
    }

    window.pendingSignOptions = options;
    window.pendingCallbackUrl = callbackUrl;

    let statusMsg = `<strong>üîó External Sign Request</strong><br>`;
    statusMsg += `From: <strong>${origin}</strong><br>`;
    if (callbackUrl) {
      statusMsg += `Will redirect to: ${new URL(callbackUrl).origin}<br>`;
    }
    statusMsg += `Please review and sign.`;
    notify(statusMsg, "info");

    return;
  }

  if (!pendingPaymentRequest) return;

  if (pendingPaymentRequest.chain !== 'arweave') {
    pendingPaymentRequest = null;
    return;
  }

  const { address, amount, message, unsupportedToken } = pendingPaymentRequest;
  pendingPaymentRequest = null;

  showScreen('wallet-screen');
  showTab('send');

  if (address) {
    const addrInput = document.getElementById('send-address');
    if (addrInput) addrInput.value = address;
  }

  if (amount) {
    const amtInput = document.getElementById('send-amount');
    if (amtInput) amtInput.value = amount;
  }

  let statusMsg = 'Payment request loaded. Please review and confirm.';

  if (message) {
    statusMsg += `<br>Message: ${message}`;
  }

  if (unsupportedToken) {
    statusMsg += `<br><strong>Warning:</strong> Token "${unsupportedToken}" is not supported; treating this as AR.`;
  }

  notify(statusMsg, "info");
}

async function applyPendingContactRequestIfAny() {
  if (!pendingContactRequest) return;

  const { address, name } = pendingContactRequest;
  pendingContactRequest = null;

  showScreen('wallet-screen');
  showTab('messages');

  if (name) {
    await MessageStorage.setContactName(address, name);
  }

  const myAddress = await WalletCore.getAddress();
  const threadId = generateThreadId(myAddress, address);
  
  const conversations = await MessageStorage.getConversations();
  let conv = conversations.find(c => c.threadId === threadId);

  if (!conv) {
    conv = {
      threadId,
      otherAddress: address,
      lastMessage: '',
      lastMessageTime: Date.now(),
      unread: 0
    };
    await MessageStorage.saveConversation(conv);
  }

  await loadConversations();
  await loadConversation(threadId);

  const displayName = await getDisplayName(address);
  notify(`Ready to message ${displayName}`, 'info');
}


const WebAuthnHelper = {
  async register(username) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    const prfSalt = crypto.getRandomValues(new Uint8Array(32));

    const credential = await navigator.credentials.create({
      publicKey: {
        challenge,
        rp: {
          name: 'ARW',
          id: window.location.hostname,
          icon: 'https://marko-app.netlify.app/android-chrome-192x192.png'
        },
        user: {
          id: crypto.getRandomValues(new Uint8Array(16)),
          name: username,
          displayName: username
        },
        pubKeyCredParams: [{ alg: -7, type: 'public-key' }],
        authenticatorSelection: { authenticatorAttachment: 'platform', userVerification: 'required' },
        timeout: 60000,
        extensions: { prf: { eval: { first: prfSalt } } }
      }
    });

    const credentialIdHex = bytesToHex(new Uint8Array(credential.rawId));
    let prfKeyHex = null;

    if (typeof credential.getClientExtensionResults === 'function') {
      const ext = credential.getClientExtensionResults();
      if (ext?.prf?.results?.first) {
        prfKeyHex = bytesToHex(new Uint8Array(ext.prf.results.first));
      }
    }

    return { credentialId: credentialIdHex, prfKeyHex, prfSaltHex: bytesToHex(prfSalt) };
  },

  async authenticate(credentialIdHex) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    await navigator.credentials.get({
      publicKey: {
        challenge,
        allowCredentials: [{ id: hexToBytes(credentialIdHex), type: 'public-key' }],
        userVerification: 'required',
        timeout: 60000
      }
    });
    return true;
  },

  async evaluatePrf(credentialIdHex, saltBytes) {
    const challenge = crypto.getRandomValues(new Uint8Array(32));
    const assertion = await navigator.credentials.get({
      publicKey: {
        challenge,
        allowCredentials: [{ id: hexToBytes(credentialIdHex), type: 'public-key' }],
        userVerification: 'required',
        timeout: 60000,
        extensions: { prf: { eval: { first: saltBytes } } }
      }
    });

    const ext = assertion.getClientExtensionResults?.();
    if (!ext?.prf?.results?.first) {
      throw new Error('Authenticator PRF extension not available');
    }
    return new Uint8Array(ext.prf.results.first);
  }
};

const CryptoHelper = {
  async encrypt(data, key) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      new TextEncoder().encode(JSON.stringify(data))
    );

    return {
      ciphertext: bytesToHex(new Uint8Array(encrypted)),
      iv: bytesToHex(iv)
    };
  },

  async decrypt(encryptedData, key) {
    const ciphertext = hexToBytes(encryptedData.ciphertext);
    const iv = hexToBytes(encryptedData.iv);

    const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext);
    return JSON.parse(new TextDecoder().decode(decrypted));
  }
};

function arrayBufferToHex(buffer) {
  const bytes = new Uint8Array(buffer);
  return Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join('');
}

function notify(messageHtml, type = "info") {
  const container = document.getElementById("toast-container");

  const t = document.createElement("div");
  t.className = `toast toast-${type}`;
  t.innerHTML = messageHtml;

  container.appendChild(t);

  requestAnimationFrame(() => t.classList.add("show"));

  setTimeout(() => {
    t.classList.remove("show");
    t.addEventListener("transitionend", () => t.remove());
  }, 2800);
}

async function logHistory(type, data, status = 'success') {
  const event = {
    id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    timestamp: Date.now(),
    type,
    status,
    data: { ...data }
  };

  const storageKey = `wallet-history:${type}`;
  
  try {
    const stored = await localforage.getItem(storageKey);
    const events = stored ? JSON.parse(stored) : [];
    
    events.unshift(event);
    
    if (events.length > 1000) {
      events.splice(1000);
    }
    
    await localforage.setItem(storageKey, JSON.stringify(events));
    return event.id;
  } catch (e) {
    console.error('Failed to log event:', e);
    return null;
  }
}

async function storeEncryptedEcdhKey(ecdhPrivKeyJwk, aesKey) {
  if (!ecdhPrivKeyJwk || !aesKey) return;

  const blob = await CryptoHelper.encrypt({ ecdh: ecdhPrivKeyJwk }, aesKey);
  await WalletStorage.set(STORAGE_KEYS.encPrivKeyEncrypted, JSON.stringify(blob));
}

async function fetchRecipientPubKey(address) {
  const query = {
    query: `{
      transactions(
        tags:[
          { name:"User-Address", values:["${address}"] },
          { name:"App-Name", values:["${WALLET_APP_NAME}"] }
        ],
        first: 1,
        sort: HEIGHT_DESC
      ){
        edges{
          node{
            tags { name value }
          }
        }
      }
    }`
  };

  const res = await fetch("https://arweave.net/graphql", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(query)
  });

  const parsed = await res.json();
  const edges = parsed?.data?.transactions?.edges || [];

  if (!edges.length)
    throw new Error("Recipient wallet not found or does not have User-EncKey");

  const tags = edges[0].node.tags;
  let pubKeyB64 = tags.find(t => t.name === "User-EncKey")?.value;

  if (!pubKeyB64)
    throw new Error("Recipient does not support encryption (User-EncKey missing)");

  pubKeyB64 = pubKeyB64.replace(/ /g, "+").trim();

  return pubKeyB64;
}

async function generateUserEncryptionKey() {
  const keyPair = await crypto.subtle.generateKey(
    { name: "ECDH", namedCurve: "P-256" },
    true,
    ["deriveBits"]
  );

  const jwkPriv = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
  await WalletStorage.set(STORAGE_KEYS.encPrivKeyJwk, JSON.stringify(jwkPriv));

  const rawPub = await crypto.subtle.exportKey("raw", keyPair.publicKey);
  const pubB64 = btoa(String.fromCharCode(...new Uint8Array(rawPub)));

  await WalletStorage.set("encPubKey", pubB64);
  return pubB64;
}

// ---------------------------------------------------------------------------
//  WALLET CORE (keeping all original functions)
// ---------------------------------------------------------------------------
const WalletCore = (function() {
  let walletJwk = null;

  function setWallet(jwk) {
    walletJwk = jwk;
  }

  function getCurrentWallet() {
    return walletJwk;
  }

  async function getAddress() {
    if (!walletJwk || !arweave) return null;
    return await arweave.wallets.jwkToAddress(walletJwk);
  }

  async function ensureUserEncKey() {
    let pub = await WalletStorage.get(STORAGE_KEYS.encPubKey);
    if (!pub) pub = await generateUserEncryptionKey();
    return pub;
  }

  async function confirmBiometricForPayment() {
    const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
    if (!credentialId) {
      throw new Error('No WebAuthn credential found. Wallet not initialized properly.');
    }
    await WebAuthnHelper.authenticate(credentialId);
  }

  async function createWallet(username) {
    if (!arweave) throw new Error('Arweave library not loaded');

    const credential = await WebAuthnHelper.register(username);
    const { credentialId, prfKeyHex, prfSaltHex } = credential;

    const jwk = await arweave.wallets.generate();
    const address = await arweave.wallets.jwkToAddress(jwk);

    let aesKey;
    let keyMode;

    if (prfKeyHex) {
      keyMode = 'prf';

      const prfBytes = hexToBytes(prfKeyHex);

      const hkdfKey = await crypto.subtle.importKey(
        "raw",
        prfBytes,
        "HKDF",
        false,
        ["deriveKey"]
      );

      aesKey = await crypto.subtle.deriveKey(
        {
          name: "HKDF",
          hash: "SHA-256",
          salt: hexToBytes(prfSaltHex),
          info: new Uint8Array([]),
        },
        hkdfKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );

    } else {
      keyMode = 'wrapped';
      const rawKey = crypto.getRandomValues(new Uint8Array(32));
      aesKey = await crypto.subtle.importKey(
        'raw',
        rawKey,
        'AES-GCM',
        false,
        ['encrypt', 'decrypt']
      );
      await WalletStorage.set(STORAGE_KEYS.aesKeyHex, bytesToHex(rawKey));
    }

    const publicEncKey = await ensureUserEncKey();
    const ecdhPrivKeyJwkRaw = await WalletStorage.get(STORAGE_KEYS.encPrivKeyJwk);
    const ecdhPrivKeyJwk = ecdhPrivKeyJwkRaw ? JSON.parse(ecdhPrivKeyJwkRaw) : null;

    if (ecdhPrivKeyJwk) {
      await storeEncryptedEcdhKey(ecdhPrivKeyJwk, aesKey);
    }

    const keysToBackup = {
      arweaveJwk: jwk,
      ecdhPrivateKey: ecdhPrivKeyJwk
    };
    const encrypted = await CryptoHelper.encrypt(keysToBackup, aesKey);

    const meta = {
      version: '1',
      keyMode,
      credentialId,
      prfSaltHex: keyMode === 'prf' ? prfSaltHex : null,
      username: username || '',
      address,
      encPubKey: publicEncKey
    };

    const backupPayload = { meta, encrypted };

    const tagList = [
      { name: 'App-Name', value: WALLET_APP_NAME },
      { name: 'User-Address', value: address },
      { name: 'User-Name', value: username || '' },
      { name: 'User-EncKey', value: publicEncKey },
      { name: 'Wallet-KeyMode', value: keyMode },
      { name: 'Timestamp', value: Date.now().toString() },
      { name: 'Version', value: '1' }
    ];

    const uploadResult = await uploadToCloudFunction(backupPayload, tagList);
    const txId = uploadResult.arweaveId;

    await WalletStorage.set(STORAGE_KEYS.credentialId, credentialId);
    await WalletStorage.set(STORAGE_KEYS.address, address);
    await WalletStorage.set(STORAGE_KEYS.backupTxId, txId);
    await WalletStorage.set(STORAGE_KEYS.keyMode, keyMode);
    await WalletStorage.set(STORAGE_KEYS.username, username || '');

    if (keyMode === 'prf' && prfSaltHex) {
      await WalletStorage.set(STORAGE_KEYS.prfSaltHex, prfSaltHex);
      await WalletStorage.remove(STORAGE_KEYS.aesKeyHex);
    }

    walletJwk = jwk;
    return { address, backupTxId: txId, keyMode };
  }

  async function unlockWallet() {
    const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
    const storedAddress = await WalletStorage.get(STORAGE_KEYS.address);
    const backupTxId = await WalletStorage.get(STORAGE_KEYS.backupTxId);

    if (!credentialId || !storedAddress || !backupTxId) {
      throw new Error('No complete wallet data found on this device.');
    }

    const res = await fetch(`https://arweave.net/${backupTxId}`);
    if (!res.ok) throw new Error('Failed to fetch encrypted wallet from Arweave');

    const encryptedBlob = JSON.parse(await res.text());
    if (!encryptedBlob.encrypted) throw new Error('Encrypted wallet missing expected field');

    const meta = encryptedBlob.meta || {};

    let keyMode = await WalletStorage.get(STORAGE_KEYS.keyMode);
    if (!keyMode && meta.keyMode) keyMode = meta.keyMode;
    if (!keyMode) throw new Error("Missing key mode information");

    let aesKey;
    let prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);
    if (!prfSaltHex && meta.prfSaltHex) prfSaltHex = meta.prfSaltHex;

    let aesKeyHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);

    if (keyMode === 'prf') {
      if (!prfSaltHex) throw new Error("Missing PRF salt for PRF-protected wallet");

      const prfBytes = await WebAuthnHelper.evaluatePrf(
        credentialId,
        hexToBytes(prfSaltHex)
      );

      const hkdfKey = await crypto.subtle.importKey(
        "raw",
        prfBytes,
        "HKDF",
        false,
        ["deriveKey"]
      );

      aesKey = await crypto.subtle.deriveKey(
        {
          name: "HKDF",
          hash: "SHA-256",
          salt: hexToBytes(prfSaltHex),
          info: new Uint8Array([]),
        },
        hkdfKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );

    } else if (keyMode === 'wrapped') {
      if (!aesKeyHex) {
        setStatus('unlock-status',
          'This wallet was imported on another device. Creating new AES encryption key...',
          'info'
        );

        await WebAuthnHelper.authenticate(credentialId);

        const rawKey = crypto.getRandomValues(new Uint8Array(32));
        aesKeyHex = bytesToHex(rawKey);
        await WalletStorage.set(STORAGE_KEYS.aesKeyHex, aesKeyHex);
      } else {
        await WebAuthnHelper.authenticate(credentialId);
      }

      aesKey = await crypto.subtle.importKey(
        "raw",
        hexToBytes(aesKeyHex),
        "AES-GCM",
        false,
        ["encrypt", "decrypt"]
      );

    } else {
      throw new Error(`Unsupported key mode: ${keyMode}`);
    }

    const decrypted = await CryptoHelper.decrypt(encryptedBlob.encrypted, aesKey);

    let jwk, ecdhPrivKey;
    if (decrypted.arweaveJwk) {
      jwk = decrypted.arweaveJwk;
      ecdhPrivKey = decrypted.ecdhPrivateKey;
    } else {
      jwk = decrypted;
      ecdhPrivKey = null;
    }

    const address = await arweave.wallets.jwkToAddress(jwk);

    walletJwk = jwk;

    if (ecdhPrivKey) {
      await WalletStorage.set(STORAGE_KEYS.encPrivKeyJwk, JSON.stringify(ecdhPrivKey));
      await storeEncryptedEcdhKey(ecdhPrivKey, aesKey);
    } else {
      const pub = await generateUserEncryptionKey();
      const raw = await WalletStorage.get(STORAGE_KEYS.encPrivKeyJwk);
      if (raw) {
        await storeEncryptedEcdhKey(JSON.parse(raw), aesKey);
      }
    }

    await WalletStorage.set(STORAGE_KEYS.address, address);
    await WalletStorage.set(STORAGE_KEYS.backupTxId, backupTxId);
    await WalletStorage.set(STORAGE_KEYS.keyMode, keyMode);
    if (prfSaltHex) await WalletStorage.set(STORAGE_KEYS.prfSaltHex, prfSaltHex);

    return { address, backupTxId: backupTxId, keyMode };
  }

  async function importFromKeyfile(jwk) {
    if (!arweave) throw new Error('Arweave not initialized');

    const address = await arweave.wallets.jwkToAddress(jwk);
    const username = 'imported-' + address.substring(0, 6);

    const { credentialId, prfKeyHex, prfSaltHex } = await WebAuthnHelper.register(username);

    let aesKey;
    let keyMode;

    if (prfKeyHex) {
      keyMode = 'prf';

      const prfBytes = hexToBytes(prfKeyHex);

      const hkdfKey = await crypto.subtle.importKey(
        "raw",
        prfBytes,
        "HKDF",
        false,
        ["deriveKey"]
      );

      aesKey = await crypto.subtle.deriveKey(
        {
          name: "HKDF",
          hash: "SHA-256",
          salt: hexToBytes(prfSaltHex),
          info: new Uint8Array([]),
        },
        hkdfKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );

      await WalletStorage.set(STORAGE_KEYS.prfSaltHex, prfSaltHex);
      await WalletStorage.remove(STORAGE_KEYS.aesKeyHex);

    } else {
      keyMode = 'wrapped';

      const rawKey = crypto.getRandomValues(new Uint8Array(32));
      aesKey = await crypto.subtle.importKey(
        'raw',
        rawKey,
        'AES-GCM',
        false,
        ['encrypt', 'decrypt']
      );

      await WalletStorage.set(STORAGE_KEYS.aesKeyHex, bytesToHex(rawKey));
      await WalletStorage.remove(STORAGE_KEYS.prfSaltHex);
    }

    await ensureUserEncKey();
    const ecdhPrivKeyJwkRaw = await WalletStorage.get(STORAGE_KEYS.encPrivKeyJwk);
    const ecdhPrivKeyJwk = ecdhPrivKeyJwkRaw ? JSON.parse(ecdhPrivKeyJwkRaw) : null;

    if (ecdhPrivKeyJwk) {
      await storeEncryptedEcdhKey(ecdhPrivKeyJwk, aesKey);
    }

    const keysToBackup = {
      arweaveJwk: jwk,
      ecdhPrivateKey: ecdhPrivKeyJwk
    };
    const encrypted = await CryptoHelper.encrypt(keysToBackup, aesKey);

    await WalletStorage.set(STORAGE_KEYS.credentialId, credentialId);
    await WalletStorage.set(STORAGE_KEYS.address, address);
    await WalletStorage.set(STORAGE_KEYS.keyMode, keyMode);
    await WalletStorage.set(STORAGE_KEYS.username, username);

    walletJwk = jwk;

    const backupTxId = await uploadRecoveryBackupInternal();

    return { address, backupTxId, keyMode };
  }

  async function uploadRecoveryBackupInternal() {
    if (!walletJwk) throw new Error('No wallet loaded');
    if (!arweave) throw new Error('Arweave not initialized');

    const address = await arweave.wallets.jwkToAddress(walletJwk);

    let keyMode = await WalletStorage.get(STORAGE_KEYS.keyMode);
    if (!keyMode) {
      const prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);
      const aesKeyHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);
      if (prfSaltHex) keyMode = 'prf';
      else if (aesKeyHex) keyMode = 'wrapped';
      else throw new Error('Missing key mode and key material for backup');
    }

    let aesKey;

    if (keyMode === 'prf') {
      const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
      const prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);
      if (!credentialId || !prfSaltHex) {
        throw new Error('Missing PRF credentials for backup');
      }

      const prfBytes = await WebAuthnHelper.evaluatePrf(
        credentialId,
        hexToBytes(prfSaltHex)
      );

      const hkdfKey = await crypto.subtle.importKey(
        "raw",
        prfBytes,
        "HKDF",
        false,
        ["deriveKey"]
      );

      aesKey = await crypto.subtle.deriveKey(
        {
          name: "HKDF",
          hash: "SHA-256",
          salt: hexToBytes(prfSaltHex),
          info: new Uint8Array([]),
        },
        hkdfKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );

    } else if (keyMode === 'wrapped') {
      const aesKeyHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);
      if (!aesKeyHex) throw new Error('Missing local AES key.');
      aesKey = await crypto.subtle.importKey(
        'raw',
        hexToBytes(aesKeyHex),
        'AES-GCM',
        false,
        ['encrypt', 'decrypt']
      );
    } else {
      throw new Error(`Unsupported key mode: ${keyMode}`);
    }

    const ecdhPrivKeyJwk = await WalletStorage.get(STORAGE_KEYS.encPrivKeyJwk);

    const keysToBackup = {
      arweaveJwk: walletJwk,
      ecdhPrivateKey: ecdhPrivKeyJwk ? JSON.parse(ecdhPrivKeyJwk) : null
    };
    const encrypted = await CryptoHelper.encrypt(keysToBackup, aesKey);

    const username = (await WalletStorage.get(STORAGE_KEYS.username)) || '';
    const publicEncKey = await ensureUserEncKey();
    const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
    const prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);

    const meta = {
      version: '1',
      keyMode,
      credentialId,
      prfSaltHex: keyMode === 'prf' ? prfSaltHex : null,
      username,
      address,
      encPubKey: publicEncKey
    };

    const backupPayload = { meta, encrypted };

    const tagList = [
      { name: 'App-Name', value: WALLET_APP_NAME },
      { name: 'User-Address', value: address },
      { name: 'User-Name', value: username },
      { name: 'User-EncKey', value: publicEncKey },
      { name: 'Wallet-KeyMode', value: keyMode },
      { name: 'Timestamp', value: Date.now().toString() },
      { name: 'Version', value: '1' }
    ];

    const uploadResult = await uploadToCloudFunction(backupPayload, tagList);
    const txId = uploadResult.arweaveId;

    await WalletStorage.set(STORAGE_KEYS.backupTxId, txId);
    return txId;
  }

  async function refreshBalance() {
    if (!walletJwk || !arweave) throw new Error('Wallet not loaded');
    const address = await arweave.wallets.jwkToAddress(walletJwk);
    const winston = await arweave.wallets.getBalance(address);
    const ar = arweave.ar.winstonToAr(winston);
    return `${parseFloat(ar).toFixed(4)} AR`;
  }

  async function sendArTransaction(toAddress, amountAr) {
    if (!walletJwk || !arweave) throw new Error('Wallet not loaded');

    const winstonAmount = arweave.ar.arToWinston(amountAr);

    const address = await arweave.wallets.jwkToAddress(walletJwk);
    const balanceWinston = await arweave.wallets.getBalance(address);
    const balanceAr = parseFloat(arweave.ar.winstonToAr(balanceWinston));

    const draftTx = await arweave.createTransaction({
      target: toAddress,
      quantity: winstonAmount
    }, walletJwk);

    const feeWinston = draftTx.reward;
    const feeAr = parseFloat(arweave.ar.winstonToAr(feeWinston));

    const totalRequiredAr = parseFloat(amountAr) + feeAr;

    if (balanceAr < totalRequiredAr) {
      throw new Error(
        `Insufficient balance. Needed ${totalRequiredAr.toFixed(6)} AR (amount + fee), ` +
        `but you have ${balanceAr.toFixed(6)} AR.`
      );
    }

    await arweave.transactions.sign(draftTx, walletJwk);

    const response = await arweave.transactions.post(draftTx);

    if (response.status === 200 || response.status === 202) {
      return draftTx.id;
    } else {
      throw new Error(`Transaction failed: ${response.status}`);
    }
  }

  async function uploadDataItem(content, contentType, userTagKey, userTagValue) {
    if (!walletJwk || !arweave) throw new Error('Wallet not loaded');

    let base64Content;

    if (content instanceof ArrayBuffer) {
      base64Content = btoa(String.fromCharCode(...new Uint8Array(content)));
    } else if (content instanceof Uint8Array) {
      base64Content = btoa(String.fromCharCode(...content));
    } else {
      const utf8Bytes = new TextEncoder().encode(content);
      base64Content = btoa(String.fromCharCode(...utf8Bytes));
    }

    const address = await arweave.wallets.jwkToAddress(walletJwk);

    const tagObj = {
      'Content-Type': contentType || 'application/octet-stream',
      'App': WALLET_APP_NAME,
      'Wallet-Address': address,
      'Timestamp': Date.now().toString()
    };

    if (userTagKey && userTagValue) {
      tagObj[userTagKey] = userTagValue;
    }

    const response = await fetch(CLOUD_FUNCTION_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        content: base64Content,
        isBase64: true,
        encrypt: false,
        extraTags: tagObj
      })
    });

    const result = await response.json();
    if (!response.ok || !result.success) {
      throw new Error(result.message || 'Cloud function upload failed');
    }

    return result.arweaveId;
  }

  async function signMessage(message, options = {}) {
    if (!walletJwk || !arweave) throw new Error('Wallet not loaded');

    const address = await arweave.wallets.jwkToAddress(walletJwk);

    let messageToSign = message;
    let isCAIP122 = false;

    if (options.domain || options.uri || options.statement) {
      isCAIP122 = true;
      const {
        domain = window.location.host,
        statement,
        uri = window.location.href,
        version = '1',
        chainId = 'arweave:1',
        nonce = crypto.randomUUID(),
        issuedAt = new Date().toISOString(),
        expirationTime,
        notBefore,
        requestId,
        resources = []
      } = options;

      let parts = [];
      parts.push(`${domain} wants you to sign in with your Arweave account:`);
      parts.push(address);
      parts.push('');
      if (statement) {
        parts.push(statement);
        parts.push('');
      }
      parts.push(`URI: ${uri}`);
      parts.push(`Version: ${version}`);
      parts.push(`Chain ID: ${chainId}`);
      parts.push(`Nonce: ${nonce}`);
      parts.push(`Issued At: ${issuedAt}`);
      
      if (expirationTime) parts.push(`Expiration Time: ${expirationTime}`);
      if (notBefore) parts.push(`Not Before: ${notBefore}`);
      if (requestId) parts.push(`Request ID: ${requestId}`);
      
      if (resources.length > 0) {
        parts.push('Resources:');
        resources.forEach(r => parts.push(`- ${r}`));
      }

      messageToSign = parts.join('\n');
    }

    const messageBytes = new TextEncoder().encode(messageToSign);
    const signature = await arweave.crypto.sign(walletJwk, messageBytes);
    const signatureB64 = arweave.utils.bufferTob64Url(signature);

    return {
      message: messageToSign,
      signature: signatureB64,
      owner: walletJwk.n,
      publicKey: { kty: "RSA", e: "AQAB", n: walletJwk.n },
      address,
      timestamp: Date.now(),
      isCAIP122
    };
  }

  return {
    createWallet,
    unlockWallet,
    importFromKeyfile,
    uploadRecoveryBackup: uploadRecoveryBackupInternal,
    refreshBalance,
    sendArTransaction,
    uploadDataItem,
    getCurrentWallet,
    getAddress,
    setWallet,
    confirmBiometricForPayment,
    signMessage
  };
})();

// ---------------------------------------------------------------------------
//  MESSAGING CORE FUNCTIONS
// ---------------------------------------------------------------------------
const MessagingCore = {
  async sendMessage(toAddress, content) {
    if (!WalletCore.getCurrentWallet()) throw new Error('Wallet not loaded');

    const myAddress = await WalletCore.getAddress();
    
    // Generate thread ID (deterministic based on addresses)
    const threadId = generateThreadId(myAddress, toAddress);

    // Encrypt message for recipient using ECDH
    const encPubKey = await fetchRecipientPubKey(toAddress);
    let rawRecipientPub = Uint8Array.from(atob(encPubKey), c => c.charCodeAt(0));

    const recipientPubKey = await crypto.subtle.importKey(
      "raw", rawRecipientPub,
      { name: "ECDH", namedCurve: "P-256" },
      false, []
    );

    const ephemeral = await crypto.subtle.generateKey(
      { name: "ECDH", namedCurve: "P-256" },
      true,
      ["deriveBits"]
    );

    const ephemeralRaw = await crypto.subtle.exportKey("raw", ephemeral.publicKey);
    const fromPubB64 = btoa(String.fromCharCode(...new Uint8Array(ephemeralRaw)));

    const sharedBits = await crypto.subtle.deriveBits(
      { name: "ECDH", public: recipientPubKey },
      ephemeral.privateKey,
      256
    );

    const aesKeyRecipient = await crypto.subtle.importKey(
      "raw", sharedBits, "AES-GCM", false, ["encrypt"]
    );

    const payload = { text: content };
    const encryptedRecipient = await CryptoHelper.encrypt(payload, aesKeyRecipient);

    // Also encrypt for self
    const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
    const keyMode = await WalletStorage.get(STORAGE_KEYS.keyMode);

    let aesKeySelf;

    if (keyMode === "prf") {
      const prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);
      const prfBytes = await WebAuthnHelper.evaluatePrf(
        credentialId, hexToBytes(prfSaltHex)
      );

      const hkdfKey = await crypto.subtle.importKey(
        "raw", prfBytes, "HKDF", false, ["deriveKey"]
      );

      aesKeySelf = await crypto.subtle.deriveKey(
        {
          name: "HKDF",
          hash: "SHA-256",
          salt: hexToBytes(prfSaltHex),
          info: new Uint8Array([])
        },
        hkdfKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt"]
      );

    } else {
      await WebAuthnHelper.authenticate(credentialId);
      const aesHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);
      aesKeySelf = await crypto.subtle.importKey(
        "raw", hexToBytes(aesHex), "AES-GCM", false, ["encrypt"]
      );
    }

    const encryptedSelf = await CryptoHelper.encrypt(payload, aesKeySelf);

    // Create message envelope
    const messageEnvelope = JSON.stringify({
      enc: "message",
      to: toAddress,
      from: myAddress,
      fromPub: fromPubB64,
      threadId,
      data: {
        recipient: encryptedRecipient,
        self: encryptedSelf
      }
    });

    // Upload to Arweave with messaging tags
    const tagObj = {
      'App-Name': MESSAGING_APP_NAME,
      'Message-Type': 'chat',
      'To-Address': toAddress,
      'From-Address': myAddress,
      'Thread-ID': threadId,
      'Timestamp': Date.now().toString()
    };

    const response = await fetch(CLOUD_FUNCTION_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        content: messageEnvelope,
        isBase64: false,
        encrypt: false,
        extraTags: tagObj
      })
    });

    const result = await response.json();
    if (!response.ok || !result.success) {
      throw new Error(result.message || 'Message upload failed');
    }

    // Store locally
    const message = {
      id: result.arweaveId,
      threadId,
      from: myAddress,
      to: toAddress,
      content,
      timestamp: Date.now(),
      direction: 'sent',
      status: 'confirmed'
    };

    await MessageStorage.saveMessage(message);

    // Update conversation
    const conversations = await MessageStorage.getConversations();
    let conv = conversations.find(c => c.threadId === threadId);
    
    if (!conv) {
      conv = {
        threadId,
        otherAddress: toAddress,
        lastMessage: content.substring(0, 50),
        lastMessageTime: Date.now(),
        unread: 0
      };
    } else {
      conv.lastMessage = content.substring(0, 50);
      conv.lastMessageTime = Date.now();
    }

    await MessageStorage.saveConversation(conv);

    return result.arweaveId;
  },

  async pollMessages() {
    const myAddress = await WalletCore.getAddress();
    if (!myAddress) return;

    // Query for messages addressed to me
    const query = {
      query: `{
        transactions(
          tags:[
            { name:"App-Name", values:["${MESSAGING_APP_NAME}"] },
            { name:"To-Address", values:["${myAddress}"] }
          ],
          first: 50,
          sort: HEIGHT_DESC
        ){
          edges{
            node{
              id
              tags { name value }
            }
          }
        }
      }`
    };

    const res = await fetch("https://arweave.net/graphql", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(query)
    });

    const parsed = await res.json();
    const edges = parsed?.data?.transactions?.edges || [];

    let newMessages = 0;

    for (const edge of edges) {
      const txId = edge.node.id;
      const tags = edge.node.tags;
      
      const tagMap = {};
      tags.forEach(t => tagMap[t.name] = t.value);

      // FIX 1: Extract threadId BEFORE using it
      const threadId = tagMap['Thread-ID'];
      
      // FIX 2: Check if already in local storage instead of timestamp comparison
      const existingMessages = await MessageStorage.getMessages(threadId);
      const alreadyExists = existingMessages.some(m => m.id === txId);
      
      if (alreadyExists) {
        continue; // Already processed this message
      }

      // Fetch and decrypt message
      try {
        const messageData = await this.fetchAndDecryptMessage(txId, tagMap);
        if (messageData) {
          await MessageStorage.saveMessage(messageData);
          
          // Update conversation
          const conversations = await MessageStorage.getConversations();
          let conv = conversations.find(c => c.threadId === threadId);
          
          if (!conv) {
            conv = {
              threadId,
              otherAddress: messageData.from,
              lastMessage: messageData.content.substring(0, 50),
              lastMessageTime: messageData.timestamp,
              unread: 1
            };
          } else {
            conv.lastMessage = messageData.content.substring(0, 50);
            conv.lastMessageTime = messageData.timestamp;
            conv.unread = (conv.unread || 0) + 1;
          }

          await MessageStorage.saveConversation(conv);
          newMessages++;
        }
      } catch (err) {
        console.error('Failed to fetch/decrypt message:', txId, err);
      }
    }

    // Update last check time (for reference, not filtering)
    await WalletStorage.set(STORAGE_KEYS.lastMessageCheck, Date.now().toString());

    if (newMessages > 0) {
      await updateUnreadBadge();
      if (currentConversation) {
        await loadConversation(currentConversation);
      }
      await loadConversations();
    }

    return newMessages;
  },

  // =============================================================================
// FIXED: fetchAndDecryptMessage() 
// Location: Inside MessagingCore object, around line 2350
// Bug: Was trying to decrypt data.self (sender's copy) instead of data.recipient
// =============================================================================

async fetchAndDecryptMessage(txId, tagMap) {
  const myAddress = await WalletCore.getAddress();
  
  // Fetch message content
  const res = await fetch(`https://arweave.net/${txId}`);
  if (!res.ok) throw new Error('Failed to fetch message');

  const envelope = JSON.parse(await res.text());
  
  if (envelope.enc !== 'message') {
    throw new Error('Not a message envelope');
  }

  // Determine if this is a sent or received message
  const isSentByMe = envelope.from === myAddress;
  
  let decrypted;

  if (isSentByMe) {
    // ===================================================================
    // SENT MESSAGE: Decrypt the self-encrypted copy with our AES key
    // ===================================================================
    const credentialId = await WalletStorage.get(STORAGE_KEYS.credentialId);
    const keyMode = await WalletStorage.get(STORAGE_KEYS.keyMode);

    let aesKey;

    if (keyMode === 'prf') {
      const prfSaltHex = await WalletStorage.get(STORAGE_KEYS.prfSaltHex);
      const prfBytes = await WebAuthnHelper.evaluatePrf(
        credentialId, hexToBytes(prfSaltHex)
      );

      const hkdfKey = await crypto.subtle.importKey(
        "raw", prfBytes, "HKDF", false, ["deriveKey"]
      );

      aesKey = await crypto.subtle.deriveKey(
        {
          name: "HKDF",
          hash: "SHA-256",
          salt: hexToBytes(prfSaltHex),
          info: new Uint8Array([])
        },
        hkdfKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["decrypt"]
      );

    } else {
      const aesHex = await WalletStorage.get(STORAGE_KEYS.aesKeyHex);
      aesKey = await crypto.subtle.importKey(
        "raw", hexToBytes(aesHex), "AES-GCM", false, ["decrypt"]
      );
    }

    // Decrypt the self-encrypted copy
    decrypted = await CryptoHelper.decrypt(envelope.data.self, aesKey);

  } else {
    // ===================================================================
    // RECEIVED MESSAGE: Decrypt with ECDH shared secret
    // ===================================================================
    
    // Get our ECDH private key
    const encPrivKeyJwkRaw = await WalletStorage.get(STORAGE_KEYS.encPrivKeyJwk);
    if (!encPrivKeyJwkRaw) {
      throw new Error('Missing ECDH private key. Cannot decrypt received messages.');
    }

    const myPrivKeyJwk = JSON.parse(encPrivKeyJwkRaw);
    const myPrivKey = await crypto.subtle.importKey(
      "jwk",
      myPrivKeyJwk,
      { name: "ECDH", namedCurve: "P-256" },
      false,
      ["deriveBits"]
    );

    // Import sender's ephemeral public key
    const senderEphemeralPubB64 = envelope.fromPub;
    const senderEphemeralPubRaw = Uint8Array.from(atob(senderEphemeralPubB64), c => c.charCodeAt(0));
    
    const senderEphemeralPubKey = await crypto.subtle.importKey(
      "raw",
      senderEphemeralPubRaw,
      { name: "ECDH", namedCurve: "P-256" },
      false,
      []
    );

    // Derive shared secret
    const sharedBits = await crypto.subtle.deriveBits(
      { name: "ECDH", public: senderEphemeralPubKey },
      myPrivKey,
      256
    );

    // Create AES key from shared secret
    const aesKeyRecipient = await crypto.subtle.importKey(
      "raw",
      sharedBits,
      "AES-GCM",
      false,
      ["decrypt"]
    );

    // Decrypt the recipient-encrypted copy
    decrypted = await CryptoHelper.decrypt(envelope.data.recipient, aesKeyRecipient);
  }

  return {
    id: txId,
    threadId: envelope.threadId,
    from: envelope.from,
    to: envelope.to,
    content: decrypted.text,
    timestamp: parseInt(tagMap['Timestamp'] || Date.now()),
    direction: isSentByMe ? 'sent' : 'received',
    status: 'confirmed'
  };
}
};

function generateThreadId(address1, address2) {
  const sorted = [address1, address2].sort();
  return `thread-${sorted[0].substring(0, 8)}-${sorted[1].substring(0, 8)}`;
}

async function updateUnreadBadge() {
  const conversations = await MessageStorage.getConversations();
  const totalUnread = conversations.reduce((sum, c) => sum + (c.unread || 0), 0);
  
  const badge = document.getElementById('unread-badge');
  if (badge) {
    if (totalUnread > 0) {
      badge.textContent = totalUnread;
      badge.classList.remove('hidden');
    } else {
      badge.classList.add('hidden');
    }
  }
}


const GroupCore = {
  // Generate random group ID
  generateGroupId() {
    const bytes = new Uint8Array(16);
    crypto.getRandomValues(bytes);
    return 'group-' + Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
  },

  // Generate random symmetric key for group
  async generateGroupKey() {
    const key = await crypto.subtle.generateKey(
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
    
    // Export to raw bytes
    const keyBytes = await crypto.subtle.exportKey("raw", key);
    
    // Return as base64
    return btoa(String.fromCharCode(...new Uint8Array(keyBytes)));
  },

  // Import group key from base64
  async importGroupKey(keyBase64) {
    const keyBytes = Uint8Array.from(atob(keyBase64), c => c.charCodeAt(0));
    
    return await crypto.subtle.importKey(
      "raw",
      keyBytes,
      { name: "AES-GCM", length: 256 },
      true,
      ["encrypt", "decrypt"]
    );
  },

  // Create new group
  async createGroup(name) {
    const groupId = this.generateGroupId();
    const keyBase64 = await this.generateGroupKey();
    
    const group = {
      id: groupId,
      name,
      key: keyBase64,
      created: Date.now(),
      messageCount: 0
    };
    
    await GroupStorage.saveGroup(group);
    
    return group;
  },

  // Send message to group
  async sendGroupMessage(groupId, content) {
    const group = await GroupStorage.getGroup(groupId);
    if (!group) throw new Error('Group not found');

    const myAddress = await WalletCore.getAddress();
    
    // Import group key
    const groupKey = await this.importGroupKey(group.key);
    
    // Encrypt message with group key
    const encrypted = await CryptoHelper.encrypt({ text: content }, groupKey);
    
    // Create envelope
    const envelope = {
      enc: 'group-message',
      groupId,
      from: myAddress,
      timestamp: Date.now(),
      data: encrypted
    };
    
    // Upload to Arweave
    const result = await uploadToCloudFunction(JSON.stringify(envelope), [
      { name: 'App-Name', value: 'ArweaveWallet-Groups-v1' },
      { name: 'Group-ID', value: groupId },
      { name: 'From-Address', value: myAddress },
      { name: 'Message-Type', value: 'group-chat' },
      { name: 'Timestamp', value: Date.now().toString() }
    ]);

    // Save locally
    const message = {
      id: result.arweaveId,
      groupId,
      from: myAddress,
      content,
      timestamp: Date.now(),
      status: 'confirmed'
    };

    await GroupStorage.saveGroupMessage(groupId, message);

    // Update group message count
    group.messageCount++;
    group.lastMessage = content.substring(0, 50);
    group.lastMessageTime = Date.now();
    await GroupStorage.saveGroup(group);

    await logHistory('group-message', {
      txid: result.arweaveId,
      groupId,
      groupName: group.name,
      content: content.substring(0, 100)
    });

    return result.arweaveId;
  },

  // Poll for new group messages
  async pollGroupMessages(groupId) {
    const group = await GroupStorage.getGroup(groupId);
    if (!group) return;

    const query = {
      query: `{
        transactions(
          tags:[
            { name:"App-Name", values:["ArweaveWallet-Groups-v1"] },
            { name:"Group-ID", values:["${groupId}"] }
          ],
          first: 50,
          sort: HEIGHT_DESC
        ){
          edges{
            node{
              id
              tags { name value }
            }
          }
        }
      }`
    };

    const res = await fetch("https://arweave.net/graphql", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(query)
    });

    const parsed = await res.json();
    const edges = parsed?.data?.transactions?.edges || [];

    let newMessages = 0;

    for (const edge of edges) {
      const txId = edge.node.id;

      // Check if already have this message
      const existingMessages = await GroupStorage.getGroupMessages(groupId);
      if (existingMessages.some(m => m.id === txId)) continue;

      // Fetch and decrypt
      try {
        const messageData = await this.fetchAndDecryptGroupMessage(txId, group.key);
        if (messageData) {
          await GroupStorage.saveGroupMessage(groupId, messageData);
          newMessages++;
        }
      } catch (err) {
        console.error('Failed to decrypt group message:', txId, err);
      }
    }

    if (newMessages > 0) {
      // Update group
      const messages = await GroupStorage.getGroupMessages(groupId);
      group.messageCount = messages.length;
      if (messages.length > 0) {
        const last = messages[messages.length - 1];
        group.lastMessage = last.content.substring(0, 50);
        group.lastMessageTime = last.timestamp;
      }
      await GroupStorage.saveGroup(group);
    }

    return newMessages;
  },

  // Fetch and decrypt a single group message
  async fetchAndDecryptGroupMessage(txId, groupKeyBase64) {
    const res = await fetch(`https://arweave.net/${txId}`);
    if (!res.ok) throw new Error('Failed to fetch message');

    const envelope = JSON.parse(await res.text());
    
    if (envelope.enc !== 'group-message') {
      throw new Error('Not a group message envelope');
    }

    // Import group key
    const groupKey = await this.importGroupKey(groupKeyBase64);
    
    // Decrypt message
    const decrypted = await CryptoHelper.decrypt(envelope.data, groupKey);

    return {
      id: txId,
      groupId: envelope.groupId,
      from: envelope.from,
      content: decrypted.text,
      timestamp: envelope.timestamp,
      status: 'confirmed'
    };
  }
};
    
// ---------------------------------------------------------------------------
//  MESSAGING UI FUNCTIONS
// ---------------------------------------------------------------------------
async function startNewConversation() {
  const address = document.getElementById('new-msg-address').value.trim();
  
  if (!address || address.length !== 43) {
    notify('Please enter a valid Arweave address', 'error');
    return;
  }

  const myAddress = await WalletCore.getAddress();
  if (address === myAddress) {
    notify('Cannot message yourself', 'error');
    return;
  }

  // Verify recipient has encryption key
  try {
    await fetchRecipientPubKey(address);
  } catch (err) {
    notify('Recipient does not support encrypted messaging', 'error');
    return;
  }

  const threadId = generateThreadId(myAddress, address);

  // Create new conversation
  const conv = {
    threadId,
    otherAddress: address,
    lastMessage: '',
    lastMessageTime: Date.now(),
    unread: 0
  };

  await MessageStorage.saveConversation(conv);
  await loadConversations();
  await loadConversation(threadId);

  document.getElementById('new-msg-address').value = '';
}

async function getDisplayName(address) {
  const name = await MessageStorage.getContactName(address);
  return name || (address.substring(0, 8) + '...' + address.substring(35));
}
    
async function loadConversations() {
  const conversations = await MessageStorage.getConversations();
  const list = document.getElementById('conversations-list');

  if (conversations.length === 0) {
    list.innerHTML = `
      <div class="empty-state">
        <span class="material-symbols-rounded">forum</span>
        <p>No conversations yet</p>
      </div>
    `;
    return;
  }

  list.innerHTML = '';

for (const conv of conversations) {
  const item = document.createElement('div');
  item.className = 'conversation-item';
  if (currentConversation === conv.threadId) {
    item.classList.add('active');
  }

  item.dataset.threadId = conv.threadId;
  const displayName = await getDisplayName(conv.otherAddress);
  
  item.innerHTML = `
    <div class="contact-name">
      ${displayName}
      ${conv.unread > 0 ? '<span class="unread-indicator"></span>' : ''}
    </div>
    <div class="last-message">${conv.lastMessage || 'No messages yet'}</div>
  `;

  item.onclick = () => loadConversation(conv.threadId);
  item.ondblclick = () => showRenameModal(conv.otherAddress);

  list.appendChild(item);
}
}

async function loadConversation(threadId) {
  currentConversation = threadId;

  const conversations = await MessageStorage.getConversations();
  const conv = conversations.find(c => c.threadId === threadId);

  if (!conv) return;

  // Mark as read
  await MessageStorage.markAsRead(threadId);

  // Update header
  const displayName = await getDisplayName(conv.otherAddress);
  document.getElementById('chat-header').textContent = displayName;

  // Load messages
  const messages = await MessageStorage.getMessages(threadId);
  const display = document.getElementById('messages-display');

  if (messages.length === 0) {
    display.innerHTML = `
      <div class="empty-state">
        <span class="material-symbols-rounded">chat</span>
        <p>No messages yet. Start the conversation!</p>
      </div>
    `;
  } else {
    display.innerHTML = '';
    messages.forEach(msg => {
      const bubble = document.createElement('div');
      bubble.className = `message-bubble ${msg.direction}`;
      
      const time = new Date(msg.timestamp).toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      });

      bubble.innerHTML = `
        <div>${msg.content}</div>
        <div class="message-time">${time}</div>
        ${msg.status === 'pending' ? '<div class="message-status">Sending...</div>' : ''}
      `;

      display.appendChild(bubble);
    });

    // Scroll to bottom
    display.scrollTop = display.scrollHeight;
  }

  // Show input area
  document.getElementById('message-input-area').classList.remove('hidden');

  // Update active state in list
  document.querySelectorAll('.conversation-item').forEach(item => {
    item.classList.remove('active');
  });
  
  document.querySelectorAll('.conversation-item').forEach(item => {
    item.classList.remove('active');
    if (item.dataset.threadId === threadId) {
      item.classList.add('active');
    }
  });

  await loadConversations(); // Refresh to update unread counts
}

async function sendMessage() {
  const input = document.getElementById('message-input');
  const content = input.value.trim();

  if (!content) return;

  if (!currentConversation) {
    notify('Please select a conversation first', 'error');
    return;
  }

  try {
    const conversations = await MessageStorage.getConversations();
    const conv = conversations.find(c => c.threadId === currentConversation);

    if (!conv) {
      notify('Conversation not found', 'error');
      return;
    }

    input.value = '';
    input.disabled = true;

    const txId = await MessagingCore.sendMessage(conv.otherAddress, content);

    await logHistory('message', {
      txid: txId,
      to: conv.otherAddress,
      content: content.substring(0, 100),
      threadId: currentConversation
    });

    await loadConversation(currentConversation);
    await loadConversations();

    notify('Message sent!', 'success');
  } catch (err) {
    console.error('Send message error:', err);
    notify(`Failed to send: ${err.message}`, 'error');
  } finally {
    input.disabled = false;
    input.focus();
  }
}

async function checkForNewMessages() {
  try {
    notify('Checking for new messages...', 'info');
    const newCount = await MessagingCore.pollMessages();
    
    if (newCount > 0) {
      notify(`Received ${newCount} new message${newCount > 1 ? 's' : ''}!`, 'success');
    } else {
      notify('No new messages', 'info');
    }
  } catch (err) {
    console.error('Poll error:', err);
    notify('Failed to check messages', 'error');
  }
}

async function copyContactLink() {
  const myAddress = await WalletCore.getAddress();
  if (!myAddress) {
    notify('Please unlock wallet first', 'error');
    return;
  }
  
  const username = await WalletStorage.get('username') || 'User';
  const baseUrl = window.location.origin + window.location.pathname;
  const link = `${baseUrl}?contact=${myAddress}&name=${encodeURIComponent(username)}`;
  
  // iOS: Use native share sheet
  if (navigator.share) {
    try {
      await navigator.share({
        title: 'Message me on Arweave',
        text: 'Send me an encrypted message',
        url: link
      });
      notify('Shared!', 'success');
      return;
    } catch (err) {
      if (err.name === 'AbortError') return;
    }
  }
  
  // Desktop: Try clipboard
  if (navigator.clipboard) {
    try {
      await navigator.clipboard.writeText(link);
      notify('Copied!', 'success');
      return;
    } catch (err) {}
  }
  
  // Fallback: Old iOS method
  const input = document.createElement('input');
  input.style.position = 'fixed';
  input.style.opacity = '0';
  input.value = link;
  document.body.appendChild(input);
  input.select();
  document.execCommand('copy');
  document.body.removeChild(input);
  notify('Copied!', 'success');
}

async function showContactQR() {
  const myAddress = await WalletCore.getAddress();
  const username = await WalletStorage.get('username') || 'User';
  const link = `${window.location.origin}${window.location.pathname}?contact=${myAddress}&name=${encodeURIComponent(username)}`;
  
  const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(link)}`;
  window.open(qrUrl, '_blank');
  // Fallback: Old iOS method
  const input = document.createElement('input');
  input.style.position = 'fixed';
  input.style.opacity = '0';
  input.value = link;
  document.body.appendChild(input);
  input.select();
  document.execCommand('copy');
  document.body.removeChild(input);
  notify('Copied!', 'success');
}
// Auto-poll when messages tab is active
function startMessagePolling() {
  if (messagePollingInterval) {
    clearInterval(messagePollingInterval);
}

  messagePollingInterval = setInterval(async () => {
    const activeTab = document.querySelector('.tab.active');
    if (activeTab && activeTab.textContent.includes('Messages')) {
      await MessagingCore.pollMessages();
    }
  }, 30000); // Poll every 30 seconds
}

function stopMessagePolling() {
  if (messagePollingInterval) {
    clearInterval(messagePollingInterval);
    messagePollingInterval = null;
  }
}

// ---------------------------------------------------------------------------
//  UI HELPERS (keeping all original functions)
// ---------------------------------------------------------------------------
function showScreen(screenId) {
  ['landing-screen', 'create-screen', 'unlock-screen', 'wallet-screen'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  });
  const target = document.getElementById(screenId);
  if (target) target.classList.remove('hidden');

  if (screenId === 'wallet-screen') {
    startMessagePolling();
  } else {
    stopMessagePolling();
  }
}

function showLanding() { showScreen('landing-screen'); }
function showCreateScreen() { showScreen('create-screen'); document.getElementById('create-status').innerHTML = ''; }
function showUnlockScreen() { showScreen('unlock-screen'); document.getElementById('unlock-status').innerHTML = ''; }

function showTab(tabName) {
  document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
  
  const allTabs = document.querySelectorAll('.tabs .tab');
  allTabs.forEach(btn => {
    if (btn.textContent.trim().toLowerCase().includes(tabName)) {
      btn.classList.add('active');
    }
  });

  ['send-tab', 'data-tab', 'sign-tab', 'messages-tab'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  });

  const target = document.getElementById(`${tabName}-tab`);
  if (target) target.classList.remove('hidden');

  // Load conversations when switching to messages tab
  if (tabName === 'messages') {
    loadConversations();
    updateUnreadBadge();
    MessagingCore.pollMessages(); // Check for new messages immediately
  }
}

let contextMenuTarget = null;

function showRenameModal(address) {
  contextMenuTarget = address;
  const name = prompt('Enter friendly name for this contact:', '');
  if (name && name.trim()) {
    MessageStorage.setContactName(address, name.trim()).then(() => {
      notify(`Contact renamed to "${name.trim()}"`, 'success');
      loadConversations();
      if (currentConversation) {
        const conv = MessageStorage.getConversations().then(convs => {
          const c = convs.find(x => x.otherAddress === address);
          if (c && c.threadId === currentConversation) {
            getDisplayName(address).then(dn => {
              document.getElementById('chat-header').textContent = dn;
            });
          }
        });
      }
    });
  }
}    
    
function setStatus(elementId, message, type = 'info') {
  const element = document.getElementById(elementId);
  if (!element) return;
  element.innerHTML = `<div class="status status-${type}">${message}</div>`;
}

function setButtonLoading(buttonId, loading) {
  const button = document.getElementById(buttonId);
  if (!button) return;
  button.disabled = loading;
}

document.getElementById("data-encryption-mode").addEventListener("change", e => {
  const mode = e.target.value;

  document.getElementById("password-field").classList.add("hidden");
  document.getElementById("recipient-field").classList.add("hidden");

  if (mode === "password") {
    document.getElementById("password-field").classList.remove("hidden");
  } else if (mode === "recipient") {
    document.getElementById("recipient-field").classList.remove("hidden");
  }
});

// Enable Enter to send messages
document.getElementById('message-input')?.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});

// ---------------------------------------------------------------------------
//  UI: CREATE WALLET
// ---------------------------------------------------------------------------
async function createWallet() {
  const username = document.getElementById('username').value.trim();

  if (!username) {
    setStatus('create-status', 'Please enter a username', 'error');
    return;
  }

  setButtonLoading('create-btn', true);
  setStatus('create-status', 'Creating wallet...', 'info');

  try {
    const { address, backupTxId } = await WalletCore.createWallet(username);
    await logHistory('system', {
      action: 'wallet_created',
      details: `Wallet created with biometric authentication. Backup TX: ${backupTxId.substring(0, 20)}...`,
      address: address
    });

    document.getElementById('wallet-address').textContent = address;
    document.getElementById('bundlr-txid').textContent = backupTxId;
    showScreen('wallet-screen');
    setStatus('wallet-status', '‚úÖ Wallet created and secured on this device!', 'success');

    await refreshBalance();
    await applyPendingPaymentRequestIfAny();
    await applyPendingContactRequestIfAny();
    await applyPendingGroupRequestIfAny();
  } catch (error) {
    console.error(error);
    await logHistory('error', {
      operation: 'create_wallet',
      error: error.message,
      details: `Username: ${username}`
    }, 'failed');
    
    setStatus('create-status', `‚ùå Error: ${error.message}`, 'error');
  } finally {
    setButtonLoading('create-btn', false);
  }
}

// ---------------------------------------------------------------------------
//  UI: UNLOCK WALLET
// ---------------------------------------------------------------------------
async function unlockWallet() {
  setButtonLoading('unlock-btn', true);
  notify('üîÑ Retrieving encrypted wallet...', 'info');

  try {
    const { address, backupTxId } = await WalletCore.unlockWallet();
    await logHistory('system', {
      action: 'wallet_unlocked',
      details: 'Biometric authentication successful',
      address: address
    });
    
    document.getElementById('wallet-address').textContent = address;
    document.getElementById('bundlr-txid').textContent = backupTxId;

    showScreen('wallet-screen');
    setStatus('wallet-status', '‚úÖ Wallet unlocked successfully!', 'success');

    await refreshBalance();
    await applyPendingPaymentRequestIfAny();
    await applyPendingContactRequestIfAny();
    await applyPendingGroupRequestIfAny();
    // Check for messages on unlock
    await MessagingCore.pollMessages();
    await updateUnreadBadge();
  } catch (error) {
    console.error(error);
    await logHistory('error', {
      operation: 'unlock_wallet',
      error: error.message,
      details: 'Failed to authenticate with biometrics'
    }, 'failed');
    
    setStatus('unlock-status', `‚ùå Error: ${error.message}`, 'error');
  } finally {
    setButtonLoading('unlock-btn', false);
  }
}

async function refreshBalance() {
  try {
    const balanceStr = await WalletCore.refreshBalance();
    document.getElementById('balance-display').textContent = balanceStr;

    const fiat = document.getElementById('fiat-select-inline').value;
    await updateBalanceFiat(balanceStr, fiat);

    return balanceStr;
  } catch (err) {
    console.error(err);
    document.getElementById('balance-display').textContent = "Error loading";
  }
}

async function updateBalanceFiat(balanceStr, fiat) {
  try {
    const arAmount = parseFloat(balanceStr);

    const now = Date.now();
    const fresh = FIAT_CACHE.timestamp && (now - FIAT_CACHE.timestamp < FIAT_TTL);

    if (!fresh) {
      const vs = "usd,eur,gbp,jpy,chf";
      const res = await fetch(
        `https://api.coingecko.com/api/v3/simple/price?ids=arweave&vs_currencies=${vs}`
      );
      const data = await res.json();

      FIAT_CACHE.timestamp = now;
      FIAT_CACHE.prices = data.arweave || {};
    }

    const price = FIAT_CACHE.prices[fiat];
    if (!price) throw new Error("Missing fiat price");

    const value = (arAmount * price).toFixed(2);

    document.getElementById("fiat-value").textContent = `‚âà ${value}`;

  } catch (err) {
    console.warn("Fiat price unavailable:", err);
    document.getElementById("fiat-value").textContent = "‚âà --";
  }
}

function openHistory() {
  window.open('hw2.html', '_blank');
}

// ---------------------------------------------------------------------------
//  UI: SEND TX
// ---------------------------------------------------------------------------
async function sendTransaction() {
  const toAddress = document.getElementById('send-address').value.trim();
  const amount = document.getElementById('send-amount').value;

  if (!toAddress || !amount || parseFloat(amount) <= 0) {
    setStatus('wallet-status', '‚ùå Please enter valid recipient and amount', 'error');
    return;
  }

  setStatus('wallet-status', 'Confirm this payment on your device‚Ä¶', 'info');

  try {
    await WalletCore.confirmBiometricForPayment();

    setStatus('wallet-status', 'Creating transaction...', 'info');

    const txId = await WalletCore.sendArTransaction(toAddress, amount);
    await logHistory('transaction', {
      txid: txId,
      direction: 'sent',
      address: toAddress,
      amount: `${amount} AR`,
      sentViaWallet: true,
      arweaveLink: `https://arweave.net/${txId}`,
      viewscanLink: `https://viewblock.io/arweave/tx/${txId}`
    }, 'pending');
    
    setStatus('wallet-status', `‚úÖ Transaction sent! TX ID: ${txId.substring(0, 20)}...`, 'success');

    document.getElementById('send-address').value = '';
    document.getElementById('send-amount').value = '';

    setTimeout(refreshBalance, 2000);
  } catch (error) {
    console.error(error);
    await logHistory('error', {
      operation: 'send_transaction',
      error: error.message,
      details: `To: ${toAddress}, Amount: ${amount} AR`
    }, 'failed');
    
    setStatus('wallet-status', `‚ùå Error: ${error.message}`, 'error');
  }
}

// ---------------------------------------------------------------------------
//  UI: UPLOAD DATA (keeping original implementation)
// ---------------------------------------------------------------------------
async function deriveKeyFromPassword(password) {
  const enc = new TextEncoder();
  const salt = crypto.getRandomValues(new Uint8Array(16));

  const baseKey = await crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );

  const aesKey = await crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt,
      iterations: 100000,
      hash: "SHA-256"
    },
    baseKey,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );

  return { aesKey, salt: bytesToHex(salt) };
}

async function uploadData() {
  const MAX_FILE_NONE      = 95 * 1024;
  const MAX_FILE_SELF      = 48 * 1024;
  const MAX_FILE_PASSWORD  = 48 * 1024;
  const MAX_FILE_RECIPIENT = 48 * 1024;
  const MAX_FILE_DUAL      = 24 * 1024;

  let finalContent = null;
  let statusAppend = "";

  const textArea = document.getElementById("data-content");
  const fileInput = document.getElementById("file-input");

  let content = textArea.value.trim();
  let fileData = null;
  let fileMeta = null;

  if (fileInput.files && fileInput.files[0]) {
    const file = fileInput.files[0];

    fileData = await file.arrayBuffer();
    fileMeta = {
      name: file.name,
      type: file.type || "application/octet-stream"
    };

    content = null;
  }

  if (!content && !fileData) {
    setStatus('wallet-status', '‚ùå Please enter text or choose a file', 'error');
    return;
  }

  const encMode = document.getElementById("data-encryption-mode").value;
  let contentType;
  if (fileData) {
    contentType = fileMeta.type && fileMeta.type !== ""
      ? fileMeta.type
      : "application/octet-stream";
  } else {
    contentType =
      document.getElementById("content-type").value.trim() || "text/plain";
  }
  const userTagKey = document.getElementById("tag-key-1").value.trim();
  const userTagValue = document.getElementById("tag-value-1").value.trim();

  if (fileData) {
    const size = fileData.byteLength;

    if (encMode === "none") {
      if (size > MAX_FILE_NONE)
        return setStatus('wallet-status', `‚ùå File too large (max ${MAX_FILE_NONE/1024} KB)`, 'error');

    } else if (encMode === "self") {
      if (size > MAX_FILE_SELF)
        return setStatus('wallet-status', `‚ùå File too large for encryption (max ${MAX_FILE_SELF/1024} KB)`, 'error');

    } else if (encMode === "password") {
      if (size > MAX_FILE_PASSWORD)
        return setStatus('wallet-status', `‚ùå File too large for password encryption (max ${MAX_FILE_PASSWORD/1024} KB)`, 'error');

    } else if (encMode === "recipient") {
      if (size > MAX_FILE_DUAL)
        return setStatus('wallet-status', `‚ùå File too large for dual encryption (max ${MAX_FILE_DUAL/1024} KB)`, 'error');
    }
  }

  setStatus('wallet-status', 'Preparing upload‚Ä¶', 'info');

  const buildPayload = () => {
    if (fileData) {
      return {
        file: arrayBufferToHex(fileData),
        mime: fileMeta.type,
        name: fileMeta.name
      };
    } else {
      return { text: content };
    }
  };

  try {
    if (encMode === "none") {
      if (fileData) {
        finalContent = fileData;
      } else {
        finalContent = new TextEncoder().encode(content);
      }
    }

    else if (encMode === "self") {
      const credentialId = await WalletStorage.get("credentialId");
      const keyMode = await WalletStorage.get("keyMode");
      if (!credentialId || !keyMode)
        throw new Error("Wallet not unlocked on this device");

      let aesKey;

      if (keyMode === "prf") {
        const prfSaltHex = await WalletStorage.get("prfSaltHex");
        if (!prfSaltHex) throw new Error("Missing PRF salt");

        const prfBytes = await WebAuthnHelper.evaluatePrf(
          credentialId, hexToBytes(prfSaltHex)
        );

        const hkdfKey = await crypto.subtle.importKey(
          "raw", prfBytes, "HKDF", false, ["deriveKey"]
        );

        aesKey = await crypto.subtle.deriveKey(
          {
            name: "HKDF",
            hash: "SHA-256",
            salt: hexToBytes(prfSaltHex),
            info: new Uint8Array([])
          },
          hkdfKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt", "decrypt"]
        );

      } else {
        await WebAuthnHelper.authenticate(credentialId);
        const aesHex = await WalletStorage.get("aesKeyHex");
        if (!aesHex) throw new Error("Missing local AES key");
        aesKey = await crypto.subtle.importKey(
          "raw", hexToBytes(aesHex), "AES-GCM", false, ["encrypt", "decrypt"]
        );
      }

      const encryptedPayload = await CryptoHelper.encrypt(buildPayload(), aesKey);

      finalContent = JSON.stringify({
        enc: "self",
        data: encryptedPayload
      });
    }

    else if (encMode === "password") {
      const password = document.getElementById("data-password").value.trim();
      if (!password) throw new Error("Password required.");

      const { aesKey, salt } = await deriveKeyFromPassword(password);
      const encrypted = await CryptoHelper.encrypt(buildPayload(), aesKey);

      finalContent = JSON.stringify({
        enc: "pw",
        salt,
        data: encrypted
      });

      statusAppend = "#" + password;
    }

    else if (encMode === "recipient") {
      const target = document.getElementById("recipient-address").value.trim();
      if (!target) throw new Error("Recipient address required.");

      const encPubKey = await fetchRecipientPubKey(target);

      let rawRecipientPub = Uint8Array.from(atob(encPubKey), c => c.charCodeAt(0));

      const recipientPubKey = await crypto.subtle.importKey(
        "raw", rawRecipientPub,
        { name: "ECDH", namedCurve: "P-256" },
        false, []
      );

      const ephemeral = await crypto.subtle.generateKey(
        { name: "ECDH", namedCurve: "P-256" },
        true,
        ["deriveBits"]
      );

      const ephemeralRaw = await crypto.subtle.exportKey("raw", ephemeral.publicKey);
      const fromPubB64 = btoa(String.fromCharCode(...new Uint8Array(ephemeralRaw)));

      const sharedBits = await crypto.subtle.deriveBits(
        { name: "ECDH", public: recipientPubKey },
        ephemeral.privateKey,
        256
      );

      const aesKeyRecipient = await crypto.subtle.importKey(
        "raw", sharedBits, "AES-GCM", false, ["encrypt"]
      );

      const payload = buildPayload();

      const encryptedRecipient = await CryptoHelper.encrypt(payload, aesKeyRecipient);

      const credentialId = await WalletStorage.get("credentialId");
      const keyMode = await WalletStorage.get("keyMode");
      if (!credentialId || !keyMode)
        throw new Error("Wallet not unlocked on this device");

      let aesKeySelf;

      if (keyMode === "prf") {
        const prfSaltHex = await WalletStorage.get("prfSaltHex");
        const prfBytes = await WebAuthnHelper.evaluatePrf(
          credentialId, hexToBytes(prfSaltHex)
        );

        const hkdfKey = await crypto.subtle.importKey(
          "raw", prfBytes, "HKDF", false, ["deriveKey"]
        );

        aesKeySelf = await crypto.subtle.deriveKey(
          {
            name: "HKDF",
            hash: "SHA-256",
            salt: hexToBytes(prfSaltHex),
            info: new Uint8Array([])
          },
          hkdfKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt"]
        );

      } else {
        await WebAuthnHelper.authenticate(credentialId);
        const aesHex = await WalletStorage.get("aesKeyHex");
        aesKeySelf = await crypto.subtle.importKey(
          "raw", hexToBytes(aesHex), "AES-GCM", false, ["encrypt"]
        );
      }

      const encryptedSelf = await CryptoHelper.encrypt(payload, aesKeySelf);

      finalContent = JSON.stringify({
        enc: "recipient",
        to: target,
        fromPub: fromPubB64,
        data: {
          recipient: encryptedRecipient,
          self: encryptedSelf
        }
      });
    }

    const txId = await WalletCore.uploadDataItem(
      finalContent,
      contentType,
      userTagKey || null,
      userTagValue || null
    );

    const origin = window.location.origin;
    let decryptLink = null;

    if (encMode === 'none') {
      decryptLink = `https://arweave.net/${txId}`;
    } else if (encMode === 'self') {
      decryptLink = `${origin}/dw2.html?link=${txId}`;
    } else if (encMode === 'password') {
      const password = document.getElementById('data-password').value.trim();
      decryptLink = `${origin}/dw2.html?link=${txId}#${password}`;
    } else if (encMode === 'recipient') {
      decryptLink = `${origin}/dw2.html?link=${txId}`;
    }

    let recipientAddress = null;
    if (encMode === 'recipient') {
      recipientAddress = document.getElementById('recipient-address').value.trim();
    }

    await logHistory('upload', {
      txid: txId,
      fileName: fileData ? fileMeta.name : 'text-content.txt',
      fileSize: fileData ? fileData.byteLength : new TextEncoder().encode(content).byteLength,
      contentType: contentType,
      encryptionMode: encMode,
      recipient: recipientAddress,
      decryptLink: decryptLink
    });

    let link = `https://marko-app.netlify.app/dw2/?link=https://arweave.net/${txId}`;
    if (statusAppend) link += statusAppend;

    setStatus(
      "wallet-status",
      `‚úÖ Uploaded! TX: ${txId}<br><a href="${link}" target="_blank">Open</a>`,
      "success"
    );

    textArea.value = "";
    fileInput.value = "";
    document.getElementById("tag-key-1").value = "";
    document.getElementById("tag-value-1").value = "";
    const pw = document.getElementById("data-password");
    if (pw) pw.value = "";
    const ra = document.getElementById("recipient-address");
    if (ra) ra.value = "";

  } catch (err) {
    console.error(err);
    await logHistory('error', {
      operation: 'upload_data',
      error: err.message,
      details: `Encryption: ${encMode}, Content-Type: ${contentType}`
    }, 'failed');
    setStatus("wallet-status", `‚ùå Upload error: ${err.message}`, "error");
  }
}

// ---------------------------------------------------------------------------
//  UI: SIGN MESSAGE (keeping original implementation)
// ---------------------------------------------------------------------------
async function signMessage() {
  const message = document.getElementById('sign-message').value.trim();
  if (!message) {
    setStatus('wallet-status', '‚ùå Please enter a message to sign', 'error');
    return;
  }

  const options = window.pendingSignOptions || {};
  const callbackUrl = window.pendingCallbackUrl;
  window.pendingSignOptions = null;
  window.pendingCallbackUrl = null;

  setStatus('wallet-status', 'Confirm signing on your device‚Ä¶', 'info');
  try {
    await WalletCore.confirmBiometricForPayment();
    setStatus('wallet-status', 'Signing message...', 'info');
    const result = await WalletCore.signMessage(message, options);
    
    await logHistory('signature', {
      message: result.message,
      signature: result.signature,
      address: result.address,
      requestedBy: pendingSignRequest?.origin || 'Manual',
      callbackUrl: callbackUrl,
      isCAIP122: result.isCAIP122,
      options: options
    });
    
    document.getElementById('signed-message').textContent = result.message;
    document.getElementById('signature-value').textContent = result.signature;
    document.getElementById('public-key-value').textContent = JSON.stringify(result.publicKey, null, 2);
    document.getElementById('signature-timestamp').textContent = new Date(result.timestamp).toLocaleString();

    let ownerDiv = document.getElementById('owner-field');
    if (!ownerDiv) {
      ownerDiv = document.createElement('div');
      ownerDiv.id = 'owner-field';
      ownerDiv.className = 'wallet-info-item';
      ownerDiv.innerHTML = `
        <div class="wallet-info-label">Owner (for verification)</div>
        <div class="wallet-info-value" id="owner-value"></div>
      `;
      document.querySelector('#signature-result .wallet-info').appendChild(ownerDiv);
    }
    document.getElementById('owner-value').textContent = result.owner;

    document.getElementById('signature-result').style.display = 'block';
    window.lastSignatureResult = result;
    
    if (callbackUrl) {
      setStatus('wallet-status', 
        `‚úÖ Signed! Redirecting back to app in 3 seconds...<br>
        <button class="btn btn-secondary" onclick="window.pendingRedirect = null; setStatus('wallet-status', 'Redirect cancelled', 'info');">Cancel</button>`, 
        'success'
      );
      
      setTimeout(() => {
        if (window.pendingRedirect !== null) {
          try {
            const redirectUrl = new URL(callbackUrl);
            
            redirectUrl.searchParams.set('signature', result.signature);
            redirectUrl.searchParams.set('message', encodeURIComponent(result.message));
            redirectUrl.searchParams.set('owner', result.owner);
            redirectUrl.searchParams.set('address', result.address);
            redirectUrl.searchParams.set('timestamp', result.timestamp.toString());
            
            window.location.href = redirectUrl.toString();
          } catch (err) {
            console.error('Invalid callback URL:', err);
            setStatus('wallet-status', '‚ùå Invalid callback URL', 'error');
          }
        }
      }, 3000);
      
      window.pendingRedirect = true;
    } else {
      setStatus('wallet-status', `‚úÖ Signed successfully!`, 'success');
    }
    
  } catch (error) {
    console.error(error);
    await logHistory('error', {
      operation: 'sign_message',
      error: error.message,
      details: `Message length: ${message.length} chars`
    }, 'failed');
    setStatus('wallet-status', `‚ùå Error: ${error.message}`, 'error');
  }
}
  
function copySignature() {
  if (!window.lastSignatureResult) {
    setStatus('wallet-status', '‚ùå No signature to copy', 'error');
    return;
  }

  const json = JSON.stringify(window.lastSignatureResult, null, 2);
  
  navigator.clipboard.writeText(json).then(() => {
    setStatus('wallet-status', '‚úÖ Signature JSON copied to clipboard!', 'success');
  }).catch(err => {
    console.error('Copy failed:', err);
    setStatus('wallet-status', '‚ùå Failed to copy to clipboard', 'error');
  });
}

async function verifySignature() {
  if (!window.lastSignatureResult) {
    setStatus('wallet-status', '‚ùå No signature to verify', 'error');
    return;
  }
  
  const { message, signature, owner } = window.lastSignatureResult;
  
  try {
    setStatus('wallet-status', 'Verifying signature...', 'info');
    
    const valid = await arweave.crypto.verify(
      owner,
      new TextEncoder().encode(message),
      arweave.utils.b64UrlToBuffer(signature)
    );
    
    if (valid) {
      setStatus('wallet-status', '‚úÖ Signature is VALID! Verified using Arweave native crypto.', 'success');
    } else {
      setStatus('wallet-status', '‚ùå Signature verification FAILED!', 'error');
    }
    
    return valid;
  } catch (error) {
    console.error('Verification error:', error);
    setStatus('wallet-status', `‚ùå Verification error: ${error.message}`, 'error');
    return false;
  }
}

// ---------------------------------------------------------------------------
//  UI: RECOVERY (keeping original implementation)
// ---------------------------------------------------------------------------
async function recoverWallet() {
  const input = document.getElementById('recovery-address').value.trim();

  if (!input) {
    setStatus('unlock-status', 'Please enter your wallet address or username', 'error');
    return;
  }

  setButtonLoading('recovery-btn', true);
  setStatus('unlock-status', 'Searching Arweave for wallet backups...', 'info');

  try {
    const isAddress = /^[a-z0-9-_]{43}$/i.test(input);

    const gqlQuery = isAddress
      ? `query {
          transactions(
            tags: [
              { name: "App-Name", values: ["${WALLET_APP_NAME}"]},
              { name: "User-Address", values: ["${input}"]}
            ],
            first: 10,
            sort: HEIGHT_DESC
          ) {
            edges { node { id } }
          }
        }`
      : `query {
          transactions(
            tags: [
              { name: "App-Name", values: ["${WALLET_APP_NAME}"]},
              { name: "User-Name", values: ["${input}"]}
            ],
            first: 10,
            sort: HEIGHT_DESC
          ) {
            edges {
              node {
                id
                tags { name value }
              }
            }
          }
        }`;

    const fetchRes = await fetch("https://arweave.net/graphql", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ query: gqlQuery })
    });

    const gqlResult = await fetchRes.json();
    const edges = gqlResult.data.transactions.edges;

    if (!edges.length) {
      throw new Error("No wallet backup found for this search");
    }

    if (!isAddress && edges.length > 1) {
      let html = "<strong>Multiple matches found:</strong><br><br>";

      edges.forEach((e) => {
        const txid = e.node.id;
        const tagMap = {};
        (e.node.tags || []).forEach(t => tagMap[t.name] = t.value);

        html += `
          <div style="margin-bottom:10px;">
            <button class="btn btn-secondary" onclick="finishRecovery('${txid}')">
              Recover wallet: ${tagMap["User-Address"] || "Unknown address"}<br>
              <small>${txid.substring(0,20)}‚Ä¶</small>
            </button>
          </div>
        `;
      });

      setStatus("unlock-status", html, "info");
      return;
    }

    const txId = edges[0].node.id;
    await finishRecovery(txId);

  } catch (error) {
    setStatus('unlock-status', `‚ùå Error: ${error.message}`, 'error');
    console.error(error);
  } finally {
    setButtonLoading('recovery-btn', false);
  }
}
  
async function finishRecovery(txId) {
  try {
    setStatus('unlock-status', 'Fetching encrypted wallet from Arweave‚Ä¶', 'info');

    const encryptedRes = await fetch(`https://arweave.net/${txId}`);
    if (!encryptedRes.ok) throw new Error("Failed to fetch encrypted backup");

    const encryptedBlob = JSON.parse(await encryptedRes.text());
    if (!encryptedBlob.encrypted) throw new Error("Encrypted blob missing required structure");

    const meta = encryptedBlob.meta || {};
    if (!meta.keyMode) throw new Error("Missing key mode information in backup");

    const keyMode = meta.keyMode;
    const credentialId = meta.credentialId;
    const address = meta.address;
    const username = meta.username || '';
    const encPubKey = meta.encPubKey;

    if (!credentialId) throw new Error("Missing credential ID in backup");
    if (!address) throw new Error("Missing address in backup");

    setStatus('unlock-status', 'Checking if WebAuthn credential exists on this device‚Ä¶', 'info');
    
    let aesKey;

    if (keyMode === 'prf') {
      const prfSaltHex = meta.prfSaltHex;
      if (!prfSaltHex) throw new Error("Missing PRF salt in backup for PRF-protected wallet");

      setStatus('unlock-status', 'üîê PRF mode detected. Please authenticate with your device‚Ä¶', 'info');

      try {
        const prfBytes = await WebAuthnHelper.evaluatePrf(credentialId, hexToBytes(prfSaltHex));

        const hkdfKey = await crypto.subtle.importKey(
          "raw", prfBytes, "HKDF", false, ["deriveKey"]
        );

        aesKey = await crypto.subtle.deriveKey(
          {
            name: "HKDF",
            hash: "SHA-256",
            salt: hexToBytes(prfSaltHex),
            info: new Uint8Array([]),
          },
          hkdfKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt", "decrypt"]
        );

        setStatus('unlock-status', '‚úÖ Credential found! Decrypting wallet‚Ä¶', 'info');

      } catch (authError) {
        throw new Error(
          "WebAuthn credential not found on this device. " +
          "Please use 'Recover from Keyfile' option to import your wallet on this device."
        );
      }

      await WalletStorage.set('prfSaltHex', prfSaltHex);

    } else if (keyMode === 'wrapped') {
      const storedAesKeyHex = await WalletStorage.get('aesKeyHex');
      
      if (!storedAesKeyHex) {
        throw new Error(
          "‚ö†Ô∏è Wrapped-mode wallet detected, but local encryption key was cleared. " +
          "Same-device recovery is only possible with PRF mode. " +
          "Please use 'Recover from Keyfile' option to import your wallet."
        );
      }

      setStatus('unlock-status', 'Please authenticate with your device‚Ä¶', 'info');
      
      try {
        await WebAuthnHelper.authenticate(credentialId);
        aesKey = await crypto.subtle.importKey("raw", hexToBytes(storedAesKeyHex), "AES-GCM", false, ["encrypt", "decrypt"]);
      } catch (authError) {
        throw new Error(
          "WebAuthn credential not found on this device. " +
          "Please use 'Recover from Keyfile' option to import your wallet on this device."
        );
      }

    } else {
      throw new Error(`Unsupported key mode: ${keyMode}`);
    }

    const decrypted = await CryptoHelper.decrypt(encryptedBlob.encrypted, aesKey);

    let jwk, ecdhPrivKey;
    if (decrypted.arweaveJwk) {
      jwk = decrypted.arweaveJwk;
      ecdhPrivKey = decrypted.ecdhPrivateKey;
    } else {
      jwk = decrypted;
      ecdhPrivKey = null;
    }

    const recoveredAddress = await arweave.wallets.jwkToAddress(jwk);

    if (recoveredAddress !== address) {
      throw new Error("Address mismatch after decryption. Backup may be corrupted.");
    }

    WalletCore.setWallet(jwk);
    
    if (ecdhPrivKey) {
      await WalletStorage.set(STORAGE_KEYS.encPrivKeyJwk, JSON.stringify(ecdhPrivKey));
      await storeEncryptedEcdhKey(ecdhPrivKey, aesKey);
      if (encPubKey) {
        await WalletStorage.set("encPubKey", encPubKey);
      }
      await storeEncryptedEcdhKey(ecdhPrivKey, aesKey);
    } else {
      if (encPubKey) {
        await WalletStorage.set("encPubKey", encPubKey);
      } else {
        const keyPair = await crypto.subtle.generateKey(
          { name: "ECDH", namedCurve: "P-256" },
          true,
          ["deriveBits"]
        );
        const jwkPriv = await crypto.subtle.exportKey("jwk", keyPair.privateKey);
        await WalletStorage.set("encPrivKeyJwk", JSON.stringify(jwkPriv));
        const rawPub = await crypto.subtle.exportKey("raw", keyPair.publicKey);
        const pubB64 = btoa(String.fromCharCode(...new Uint8Array(rawPub)));
        await WalletStorage.set("encPubKey", pubB64);
      }
    }

    await WalletStorage.set('address', address);
    await WalletStorage.set('backupTxId', txId);
    await WalletStorage.set('keyMode', keyMode);
    await WalletStorage.set('credentialId', credentialId);
    await WalletStorage.set('username', username);
    
    await logHistory('system', {
      action: 'wallet_recovered',
      details: `${keyMode === 'prf' ? 'PRF-protected' : 'Wrapped-mode'} wallet recovered from backup TX: ${txId.substring(0, 20)}...`,
      address: address
    });
    
    document.getElementById('wallet-address').textContent = address;
    document.getElementById('bundlr-txid').textContent = txId;

    showScreen('wallet-screen');
    
    const recoveryType = keyMode === 'prf' ? 'PRF-protected wallet' : 'wrapped-mode wallet';
    setStatus('wallet-status', `‚úÖ ${recoveryType} recovered successfully on this device!`, 'success');

    refreshBalance();

  } catch (err) {
    await logHistory('error', {
      operation: 'recover_wallet',
      error: err.message,
      details: `Backup TX: ${txId}`
    }, 'failed');
    setStatus('unlock-status', `‚ùå ${err.message}`, 'error');
    console.error(err);
  }
}
  
async function recoverByKeyfile() {
  const fileInput = document.getElementById("keyfile-upload");
  const file = fileInput.files[0];

  if (!file) {
    setStatus("unlock-status", "Please select a keyfile JSON", "error");
    return;
  }

  try {
    const text = await file.text();
    const jwk = JSON.parse(text);

    setStatus("unlock-status", "Importing wallet via WalletCore...", "info");
    
    const result = await WalletCore.importFromKeyfile(jwk);
    await logHistory('system', {
      action: 'wallet_recovered',
      details: `Keyfile imported and secured. Backup TX: ${result.backupTxId.substring(0, 20)}...`,
      address: result.address
    });

    document.getElementById("wallet-address").textContent = result.address;
    document.getElementById("bundlr-txid").textContent = result.backupTxId;

    showScreen("wallet-screen");
    setStatus("wallet-status", "‚úÖ Keyfile imported & protected with your device!", "success");

    refreshBalance();

  } catch (err) {
    await logHistory('error', {
      operation: 'recover_by_keyfile',
      error: err.message,
      details: 'Failed to import keyfile'
    }, 'failed');
    setStatus("unlock-status", `‚ùå Error importing keyfile: ${err.message}`, "error");
    console.error(err);
  }
}

async function uploadRecoveryBackup() {
  try {
    setStatus("wallet-status", "Uploading backup via WalletCore...", "info");
    
    const txId = await WalletCore.uploadRecoveryBackup();
    await logHistory('system', {
      action: 'backup_uploaded',
      details: `Recovery backup uploaded to Arweave: ${txId.substring(0, 20)}...`,
      address: document.getElementById('wallet-address').textContent
    });
    document.getElementById("bundlr-txid").textContent = txId;
    setStatus("wallet-status", `‚úÖ Backup stored! TX: ${txId}`, "success");

  } catch (err) {
    await logHistory('error', {
      operation: 'upload_backup',
      error: err.message,
      details: 'Failed to upload recovery backup to Arweave'
    }, 'failed');
    setStatus("wallet-status", `‚ùå Backup upload failed: ${err.message}`, "error");
    console.error(err);
  }
}

function lockWallet() {
  stopMessagePolling();
  showLanding();
}

function exportKey() {
  const jwk = WalletCore.getCurrentWallet();
  if (!jwk) return;

  const dataStr = JSON.stringify(jwk, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'arweave-keyfile.json';
  link.click();
  URL.revokeObjectURL(url);

  logHistory('system', {
    action: 'keyfile_exported',
    details: 'Private key exported as JSON file. Store this securely!',
    address: document.getElementById('wallet-address').textContent
  }).catch(err => console.error('Failed to log export:', err));

  setStatus('wallet-status', '‚úÖ Keyfile exported! Keep it extremely safe!', 'success');
}
  
function openScanner() {
  window.location.href = "scanqr.html";
}

window.addEventListener('DOMContentLoaded', () => {
  if (!window.PublicKeyCredential || !navigator.credentials) {
    alert('‚ùå WebAuthn not supported in this browser. Please use a modern browser with biometric authentication support.');
  }

  parsePaymentRequestFromUrl();

  if (pendingPaymentRequest && pendingPaymentRequest.chain === 'arweave') {
    showUnlockScreen();
    setStatus('unlock-status', 'Payment request detected. Please unlock your wallet to continue.', 'info');
  }

  if (pendingSignRequest) {
    showUnlockScreen();
    setStatus('unlock-status', 'Sign request detected. Please unlock your wallet to continue.', 'info');
  }

  parseContactRequestFromUrl();
  if (pendingContactRequest) {
    showUnlockScreen();
    const msg = pendingContactRequest.name 
      ? `Contact request from "${pendingContactRequest.name}"`
      : 'Contact request detected';
    setStatus('unlock-status', msg + '. Please unlock to start conversation.', 'info');
  }

  parseGroupRequestFromUrl();
  
  if (pendingGroupRequest) {
    showUnlockScreen();
    setStatus('unlock-status', `Group invitation to "${pendingGroupRequest.name}". Please unlock to join.`, 'info');
  }
  
});
  
(function initFiatSelector() {
  const sel = document.getElementById("fiat-select-inline");

  const saved = localStorage.getItem("fiatChoice");
  if (saved && sel.querySelector(`option[value="${saved}"]`)) {
    sel.value = saved;
  }

  sel.addEventListener("change", async () => {
    const fiat = sel.value;
    localStorage.setItem("fiatChoice", fiat);

    const balanceStr = document.getElementById('balance-display').textContent;
    if (balanceStr.includes(" AR")) {
      await updateBalanceFiat(balanceStr, fiat);
    }
  });
})();

window.requestPayment = function (uri) {
  try {
    if (typeof uri !== "string") throw new Error("URI must be a string.");

    if (uri.toLowerCase().startsWith("ar://")) {
      const parsed = parseArPaymentUri(uri);
      if (!parsed) throw new Error("Invalid AR payment URI");
      pendingPaymentRequest = parsed;
    } else if (uri.toLowerCase().startsWith("ethereum:")) {
      pendingPaymentRequest = { unsupported: true, raw: uri };
    } else {
      throw new Error("Unsupported payment URI format");
    }

    const walletLoaded = WalletCore.getCurrentWallet() ? true : false;

    if (!walletLoaded) {
      showUnlockScreen();
      setStatus(
        "unlock-status",
        "Payment request detected. Please unlock your wallet.",
        "info"
      );
    } else {
      applyPendingPaymentRequestIfAny();
    }

    return true;
  } catch (err) {
    console.error("requestPayment error:", err);
    return false;
  }
};

window.requestSignature = function (message, origin = 'Unknown') {
  try {
    if (typeof message !== "string") throw new Error("Message must be a string.");

    pendingSignRequest = {
      message,
      origin
    };

    const walletLoaded = WalletCore.getCurrentWallet() ? true : false;

    if (!walletLoaded) {
      showUnlockScreen();
      setStatus(
        "unlock-status",
        "Sign request detected. Please unlock your wallet.",
        "info"
      );
    } else {
      applyPendingPaymentRequestIfAny();
    }

    return true;
  } catch (err) {
    console.error("requestSignature error:", err);
    return false;
  }
};
  
function openRequestQR() {
  const address = document.getElementById("wallet-address").textContent.trim();
  if (!address) {
    setStatus('wallet-status', '‚ùå No address loaded', 'error');
    return;
  }

  const url = `https://marko-app.netlify.app/pqr?chain=arweave&address=${address}&token=AR`;
  window.open(url, "_blank");
}

let currentGroup = null;
let pendingGroupRequest = null;

// Parse group from URL with password in fragment
function parseGroupRequestFromUrl() {
  const url = new URL(window.location.href);
  const params = url.searchParams;
  const fragment = url.hash.substring(1); // Remove #
  
  const groupId = params.get('group');
  const groupName = params.get('groupName');
  
  // Parse password from fragment
  const fragmentParams = new URLSearchParams(fragment);
  const password = fragmentParams.get('password');
  
  if (groupId && password) {
    pendingGroupRequest = {
      id: groupId,
      name: groupName ? decodeURIComponent(groupName) : 'Unnamed Group',
      key: password
    };
    console.log('üì¨ Group invitation detected');
  }
}

async function applyPendingGroupRequestIfAny() {
  if (!pendingGroupRequest) return;

  const { id, name, key } = pendingGroupRequest;
  pendingGroupRequest = null;

  showScreen('wallet-screen');
  showTab('groups');

  // Check if already in this group
  const existing = await GroupStorage.getGroup(id);
  if (existing) {
    notify(`Already in group: ${name}`, 'info');
    await loadGroups();
    await openGroupChat(id);
    return;
  }

  // Join the group
  const group = {
    id,
    name,
    key,
    created: Date.now(),
    messageCount: 0,
    joined: Date.now()
  };

  await GroupStorage.saveGroup(group);
  notify(`‚úÖ Joined group: ${name}`, 'success');

  // Poll for messages
  await GroupCore.pollGroupMessages(id);

  await loadGroups();
  await openGroupChat(id);
}

function showCreateGroupModal() {
  const modal = document.getElementById('create-group-modal');
  const input = document.getElementById('group-name-input');
  input.value = '';
  modal.classList.add('show');
  input.focus();
}

function closeCreateGroupModal() {
  document.getElementById('create-group-modal').classList.remove('show');
}

async function createGroup() {
  const input = document.getElementById('group-name-input');
  const name = input.value.trim();

  if (!name) {
    notify('Please enter a group name', 'error');
    return;
  }

  try {
    const group = await GroupCore.createGroup(name);
    
    closeCreateGroupModal();
    notify(`‚úÖ Group "${name}" created!`, 'success');
    
    await loadGroups();
    
    // Show share link
    const link = getGroupInviteLink(group);
    showGroupInviteLink(link, name);
    
  } catch (err) {
    console.error('Create group error:', err);
    notify(`Failed: ${err.message}`, 'error');
  }
}

function showJoinGroupModal() {
  const modal = document.getElementById('join-group-modal');
  const input = document.getElementById('group-link-input');
  input.value = '';
  modal.classList.add('show');
  input.focus();
}

function closeJoinGroupModal() {
  document.getElementById('join-group-modal').classList.remove('show');
}

async function joinGroup() {
  const input = document.getElementById('group-link-input');
  const link = input.value.trim();

  if (!link) {
    notify('Please paste a group link', 'error');
    return;
  }

  try {
    // Parse the link
    const url = new URL(link);
    const groupId = url.searchParams.get('group');
    const groupName = url.searchParams.get('groupName');
    const fragment = url.hash.substring(1);
    const fragmentParams = new URLSearchParams(fragment);
    const password = fragmentParams.get('password');

    if (!groupId || !password) {
      notify('Invalid group link', 'error');
      return;
    }

    // Check if already in group
    const existing = await GroupStorage.getGroup(groupId);
    if (existing) {
      notify('Already in this group', 'info');
      closeJoinGroupModal();
      await loadGroups();
      await openGroupChat(groupId);
      return;
    }

    // Join the group
    const group = {
      id: groupId,
      name: groupName ? decodeURIComponent(groupName) : 'Unnamed Group',
      key: password,
      created: Date.now(),
      messageCount: 0,
      joined: Date.now()
    };

    await GroupStorage.saveGroup(group);
    
    closeJoinGroupModal();
    notify(`‚úÖ Joined group: ${group.name}`, 'success');

    // Poll for messages
    await GroupCore.pollGroupMessages(groupId);

    await loadGroups();
    await openGroupChat(groupId);

  } catch (err) {
    console.error('Join group error:', err);
    notify('Invalid group link', 'error');
  }
}

async function loadGroups() {
  const groups = await GroupStorage.getGroups();
  const list = document.getElementById('groups-list');

  if (groups.length === 0) {
    list.innerHTML = `
      <div class="empty-state">
        <span class="material-symbols-rounded">groups</span>
        <p>No groups yet</p>
        <p style="font-size: 14px; opacity: 0.7;">Create a new group or join an existing one</p>
      </div>
    `;
    return;
  }

  list.innerHTML = '';

  for (const group of groups) {
    const item = document.createElement('div');
    item.className = 'group-item';
    if (currentGroup === group.id) {
      item.classList.add('active');
    }

    item.innerHTML = `
      <div class="group-name">
        <span class="material-symbols-rounded">group</span>
        ${group.name}
      </div>
      <div class="group-last-message">${group.lastMessage || 'No messages yet'}</div>
      <div class="group-members-count">${group.messageCount || 0} messages</div>
    `;

    item.onclick = () => openGroupChat(group.id);

    list.appendChild(item);
  }
}

async function openGroupChat(groupId) {
  currentGroup = groupId;

  const group = await GroupStorage.getGroup(groupId);
  if (!group) return;

  // Hide groups list, show chat
  document.getElementById('groups-list').style.display = 'none';
  document.querySelector('#groups-tab .button-group').style.display = 'none';
  document.querySelector('#groups-tab .security-warning').style.display = 'none';
  document.getElementById('group-chat-container').classList.remove('hidden');

  document.getElementById('group-chat-header').textContent = group.name;

  // Load messages
  const messages = await GroupStorage.getGroupMessages(groupId);
  const display = document.getElementById('group-messages-display');

  if (messages.length === 0) {
    display.innerHTML = `
      <div class="empty-state">
        <span class="material-symbols-rounded">chat</span>
        <p>No messages yet. Start the conversation!</p>
      </div>
    `;
  } else {
    display.innerHTML = '';
    
    const myAddress = await WalletCore.getAddress();
    
    messages.forEach(msg => {
      const bubble = document.createElement('div');
      const isMe = msg.from === myAddress;
      bubble.className = `message-bubble ${isMe ? 'sent' : 'received'}`;
      
      const time = new Date(msg.timestamp).toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      });
      
      const shortAddr = msg.from.substring(0, 8) + '...' + msg.from.substring(35);

      bubble.innerHTML = `
        ${!isMe ? `<div class="message-sender">${shortAddr}</div>` : ''}
        <div>${msg.content}</div>
        <div class="message-time">${time}</div>
      `;

      display.appendChild(bubble);
    });

    display.scrollTop = display.scrollHeight;
  }

  document.getElementById('group-message-input').value = '';
  
  // Poll for new messages
  await GroupCore.pollGroupMessages(groupId);
  
  await loadGroups();
}

function closeGroupChat() {
  currentGroup = null;
  document.getElementById('group-chat-container').classList.add('hidden');
  document.getElementById('groups-list').style.display = '';
  document.querySelector('#groups-tab .button-group').style.display = '';
  document.querySelector('#groups-tab .security-warning').style.display = '';
}

async function sendGroupMessage() {
  if (!currentGroup) return;

  const input = document.getElementById('group-message-input');
  const content = input.value.trim();

  if (!content) return;

  try {
    input.value = '';
    input.disabled = true;

    await GroupCore.sendGroupMessage(currentGroup, content);

    await openGroupChat(currentGroup);
    await loadGroups();

    notify('Message sent!', 'success');
  } catch (err) {
    console.error('Send group message error:', err);
    notify(`Failed: ${err.message}`, 'error');
  } finally {
    input.disabled = false;
    input.focus();
  }
}

// Add Enter key support
document.addEventListener('DOMContentLoaded', () => {
  const input = document.getElementById('group-message-input');
  if (input) {
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendGroupMessage();
      }
    });
  }
});

function getGroupInviteLink(group) {
  const baseUrl = window.location.origin + window.location.pathname;
  return `${baseUrl}?group=${group.id}&groupName=${encodeURIComponent(group.name)}#password=${group.key}`;
}

function showGroupInviteLink(link, groupName) {
  const modal = document.createElement('div');
  modal.className = 'name-modal show';
  
  const content = document.createElement('div');
  content.className = 'name-modal-content';
  
  content.innerHTML = `
    <h3>Invite Link Created</h3>
    <p style="color: var(--md-sys-color-on-surface-variant); font-size: 14px;">
      Share this link to invite people to "${groupName}":
    </p>
    <div style="
      background: var(--md-sys-color-surface-variant);
      padding: 12px;
      border-radius: 8px;
      word-break: break-all;
      font-size: 12px;
      margin: 16px 0;
      user-select: all;
    ">${link}</div>
    <div class="security-warning" style="margin: 16px 0; padding: 12px; background: #fff3cd; border-radius: 8px;">
      <p style="margin: 0; font-size: 13px; color: #856404;">
        ‚ö†Ô∏è Anyone with this link can read all group messages!
      </p>
    </div>
    <div class="name-modal-buttons">
      <button class="btn btn-secondary" onclick="this.closest('.name-modal').remove()">Close</button>
      <button class="btn btn-primary" onclick="copyGroupLink('${link}')">Copy Link</button>
    </div>
  `;
  
  modal.appendChild(content);
  document.body.appendChild(modal);
}

async function copyGroupLink(link) {
  if (navigator.share) {
    try {
      await navigator.share({
        title: 'Join my group',
        text: 'Join this encrypted group chat',
        url: link
      });
      return;
    } catch (err) {}
  }

  try {
    await navigator.clipboard.writeText(link);
    notify('üìã Link copied!', 'success');
  } catch (err) {
    prompt('Copy this link:', link);
  }
}

function showGroupInfo() {
  if (!currentGroup) return;
  
  GroupStorage.getGroup(currentGroup).then(group => {
    const modal = document.getElementById('group-info-modal');
    const content = document.getElementById('group-info-content');
    
    const link = getGroupInviteLink(group);
    
    content.innerHTML = `
      <div style="margin-bottom: 20px;">
        <label style="display: block; font-weight: 600; margin-bottom: 8px;">Group Name</label>
        <div>${group.name}</div>
      </div>
      <div style="margin-bottom: 20px;">
        <label style="display: block; font-weight: 600; margin-bottom: 8px;">Messages</label>
        <div>${group.messageCount || 0} messages</div>
      </div>
      <div style="margin-bottom: 20px;">
        <label style="display: block; font-weight: 600; margin-bottom: 8px;">Invite Link</label>
        <button class="btn btn-secondary" onclick="copyGroupLink('${link}')" style="width: 100%; margin: 0;">
          <span class="material-symbols-rounded">share</span>
          Share Invite Link
        </button>
      </div>
    `;
    
    modal.classList.add('show');
  });
}

function closeGroupInfoModal() {
  document.getElementById('group-info-modal').classList.remove('show');
}

async function leaveGroup() {
  if (!currentGroup) return;
  
  const group = await GroupStorage.getGroup(currentGroup);
  
  if (confirm(`Leave "${group.name}"? You'll need a new invite link to rejoin.`)) {
    await GroupStorage.deleteGroup(currentGroup);
    closeGroupInfoModal();
    closeGroupChat();
    await loadGroups();
    notify('Left group', 'info');
  }
}
    
// Export functions to window
window.showCreateScreen = showCreateScreen;
window.showUnlockScreen = showUnlockScreen;
window.showLanding = showLanding;
window.createWallet = createWallet;
window.unlockWallet = unlockWallet;
window.recoverWallet = recoverWallet;
window.sendTransaction = sendTransaction;
window.parsePaymentRequestFromUrl = parsePaymentRequestFromUrl;
window.applyPendingPaymentRequestIfAny = applyPendingPaymentRequestIfAny;
window.uploadData = uploadData;
window.openHistory = openHistory;
window.exportKey = exportKey;
window.lockWallet = lockWallet;
window.showTab = showTab;
window.recoverByKeyfile = recoverByKeyfile;
window.uploadRecoveryBackup = uploadRecoveryBackup;
window.finishRecovery = finishRecovery;
window.refreshBalance = refreshBalance;
window.signMessage = signMessage;
window.verifySignature = verifySignature;  
window.copySignature = copySignature;
window.openScanner = openScanner;

// Messaging exports
window.startNewConversation = startNewConversation;
window.sendMessage = sendMessage;
window.checkForNewMessages = checkForNewMessages;
window.loadConversation = loadConversation;
window.loadConversations = loadConversations;
window.getDisplayName = getDisplayName;
window.parseContactRequestFromUrl = parseContactRequestFromUrl;
window.applyPendingContactRequestIfAny = applyPendingContactRequestIfAny;
window.copyContactLink = copyContactLink;
window.showContactQR = showContactQR;
window.showRenameModal = showRenameModal;

window.GroupStorage = GroupStorage;
window.GroupCore = GroupCore;
window.parseGroupRequestFromUrl = parseGroupRequestFromUrl;
window.applyPendingGroupRequestIfAny = applyPendingGroupRequestIfAny;
window.showCreateGroupModal = showCreateGroupModal;
window.closeCreateGroupModal = closeCreateGroupModal;
window.createGroup = createGroup;
window.showJoinGroupModal = showJoinGroupModal;
window.closeJoinGroupModal = closeJoinGroupModal;
window.joinGroup = joinGroup;
window.loadGroups = loadGroups;
window.openGroupChat = openGroupChat;
window.closeGroupChat = closeGroupChat;
window.sendGroupMessage = sendGroupMessage;
window.getGroupInviteLink = getGroupInviteLink;
window.copyGroupLink = copyGroupLink;
window.showGroupInfo = showGroupInfo;
window.closeGroupInfoModal = closeGroupInfoModal;
window.leaveGroup = leaveGroup;    
    
  </script>

</body>
</html>

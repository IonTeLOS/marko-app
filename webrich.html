<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebPusher - Send Rich Notification</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 800px; margin: 0 auto; }
    .card {
      background: white;
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 20px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    h1 { color: #333; margin-bottom: 10px; font-size: 28px; }
    h2 { color: #333; margin-bottom: 15px; font-size: 20px; margin-top: 20px; }
    .subtitle { color: #666; margin-bottom: 30px; line-height: 1.6; }
    .role-badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      margin-left: 10px;
    }
    .role-badge.admin {
      background: #e3f2fd;
      color: #1976d2;
    }
    .role-badge.guest {
      background: #f3e5f5;
      color: #7b1fa2;
    }
    .form-group { margin-bottom: 15px; }
    label {
      display: block;
      margin-bottom: 5px;
      color: #333;
      font-weight: 500;
      font-size: 14px;
    }
    .hint { font-size: 12px; color: #999; margin-top: 3px; }
    input, textarea, select {
      width: 100%;
      padding: 10px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
    }
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: #667eea;
    }
    textarea { min-height: 80px; resize: vertical; }
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 5px;
    }
    .checkbox-group input[type="checkbox"] {
      width: auto;
    }
    button {
      padding: 12px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 10px;
      margin-right: 10px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
    }
    button.secondary {
      background: #6c757d;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    .status {
      padding: 15px;
      border-radius: 6px;
      margin-top: 15px;
      display: none;
    }
    .status.info { background: #e3f2fd; color: #1976d2; }
    .status.success { background: #e8f5e9; color: #388e3c; }
    .status.error { background: #ffebee; color: #d32f2f; }
    .status.show { display: block; }
    .actions-list {
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 10px;
      margin-top: 5px;
    }
    .action-item {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    .action-item input { flex: 1; }
    .action-item button {
      padding: 6px 12px;
      margin: 0;
      background: #dc3545;
    }
    .tags-input {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      padding: 8px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      min-height: 40px;
    }
    .tag-pill {
      background: #667eea;
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .tag-pill button {
      background: none;
      border: none;
      color: white;
      padding: 0;
      margin: 0;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
    }
    #tagInput {
      border: none;
      flex: 1;
      min-width: 120px;
      padding: 4px;
    }
    #tagInput:focus { outline: none; border: none; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>üì® Send Rich Notification<span id="roleBadge" class="role-badge"></span></h1>
      <p class="subtitle">Create and send rich notifications with all supported features.</p>

      <!-- Config -->
      <div class="form-group">
        <label for="workerUrl">Worker URL</label>
        <input type="url" id="workerUrl" placeholder="https://your-worker.workers.dev">
  <button type="button" class="secondary" onclick="manualSync()" style="margin-top: 5px;">
    üîÑ Sync Connections
  </button>
  <div class="hint" id="syncStatus"></div>
</div>
      <!-- Recipient Selection (Admin only) -->
      <div id="recipientSection" class="form-group hidden">
        <label for="recipient">Send To</label>
        <select id="recipient">
          <option value="">Loading guests...</option>
        </select>
        <div class="hint">Select which guest to send the notification to</div>
      </div>

      <!-- Token/Secret (depending on role) -->
<!-- Replace the recipientSection and credential divs with this: -->
<div class="form-group">
  <label for="recipientUserId">Recipient User ID *</label>
  <input type="text" id="recipientUserId" placeholder="admin or user-abc-123..." required>
  <div class="hint">Enter the user ID to send the notification to (e.g., "admin" or "user-7a7353c4-...")</div>
</div>

      <!-- Required Fields -->
      <h2>üìù Required</h2>
      
      <div class="form-group">
        <label for="message">Message *</label>
        <textarea id="message" placeholder="Enter your message" required></textarea>
        <div class="hint">The main notification body text</div>
      </div>

      <!-- Optional Fields -->
      <h2>üé® Optional</h2>

      <div class="form-group">
        <label for="title">Title</label>
        <input type="text" id="title" placeholder="WebPusher">
        <div class="hint">Defaults to "WebPusher" if not set</div>
      </div>

      <div class="form-group">
        <label for="icon">Icon URL</label>
        <input type="url" id="icon" placeholder="https://example.com/icon.png">
        <div class="hint">Large icon shown in notification</div>
      </div>

      <div class="form-group">
        <label for="badge">Badge URL</label>
        <input type="url" id="badge" placeholder="https://example.com/badge.png">
        <div class="hint">Small icon in notification tray (monochrome recommended)</div>
      </div>

      <div class="form-group">
        <label for="image">Image URL</label>
        <input type="url" id="image" placeholder="https://example.com/photo.jpg">
        <div class="hint">Large banner photo in notification</div>
      </div>

      <div class="form-group">
        <label for="click">Click URL</label>
        <input type="url" id="click" placeholder="https://example.com/page">
        <div class="hint">URL to open when notification is clicked</div>
      </div>

      <!-- Grouping & Tags -->
      <h2>üè∑Ô∏è Grouping & Tags</h2>

      <div class="form-group">
        <label for="tag">Tag (Replacement Behavior)</label>
        <input type="text" id="tag" placeholder="chat-messages">
        <div class="hint">Notifications with same tag replace each other. Leave empty for unique notifications.</div>
      </div>

      <div class="form-group">
        <label>Tags (Metadata)</label>
        <div class="tags-input" id="tagsContainer">
          <input type="text" id="tagInput" placeholder="Type and press Enter">
        </div>
        <div class="hint">Add tags like "urgent", "Order:12345", or "isMarkdown:true". Press Enter to add.</div>
      </div>

      <!-- Actions -->
      <h2>üîò Actions (Buttons)</h2>
      
      <div class="form-group">
        <label>Action Buttons</label>
        <div id="actionsList" class="actions-list">
          <div class="hint" style="margin-bottom: 10px;">Add interactive buttons to your notification</div>
        </div>
        <button type="button" class="secondary" onclick="addAction()">+ Add Action</button>
      </div>

      <!-- Behavior -->
      <h2>‚öôÔ∏è Behavior</h2>

      <div class="checkbox-group">
        <input type="checkbox" id="requireInteraction">
        <label for="requireInteraction" style="margin: 0;">Require Interaction (Sticky)</label>
      </div>
      <div class="hint" style="margin-left: 28px;">Notification stays until user dismisses it</div>

      <div class="checkbox-group" style="margin-top: 10px;">
        <input type="checkbox" id="silent">
        <label for="silent" style="margin: 0;">Silent (No Sound/Vibration)</label>
      </div>

      <!-- Actions -->
      <button onclick="sendRichNotification()" id="sendButton">üöÄ Send Rich Notification</button>
      <button class="secondary" onclick="sendSimpleNotification()">üì§ Send Simple (Message Only)</button>

      <div id="status" class="status"></div>
    </div>
  </div>

  <script src="webpusher-crypto.js"></script>
  <script src="protocol-handler.js"></script>
  <script>
let tags = [];
let actions = [];
// Connection sync functionality
// Connection sync functionality
let myConnections = [];

// Sync connections from server
async function syncConnections() {
    const myUserId = localStorage.getItem('my_user_id');
    const signingKeyJson = localStorage.getItem('signing_key');
    let workerUrl = localStorage.getItem('worker_url');
    
    // Try to get from input field if not in localStorage
    if (!workerUrl) {
        const urlInput = document.getElementById('workerUrl');
        if (urlInput) {
            workerUrl = urlInput.value.trim();
        }
    }
    
    if (!myUserId || !signingKeyJson || !workerUrl) {
        console.log('Cannot sync connections: missing credentials', {
            hasUserId: !!myUserId,
            hasSigningKey: !!signingKeyJson,
            hasWorkerUrl: !!workerUrl
        });
        return null;
    }

    try {
        const signingKey = JSON.parse(signingKeyJson);
        
        const timestamp = Date.now();
        const requestData = {
            userId: myUserId,
            timestamp: timestamp
        };

        const signature = await signRequest(requestData, signingKey);

        let url = workerUrl;
        if (!url.startsWith('http')) url = 'https://' + url;
        url = url.replace(/\/$/, '');

        const response = await fetch(`${url}/connections/list`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                ...requestData,
                signature: signature
            })
        });

        if (!response.ok) {
            throw new Error(`Failed to sync connections: ${response.status}`);
        }

        const data = await response.json();
        myConnections = data.connections || [];
        
        // Store in localStorage for persistence
        localStorage.setItem('my_connections', JSON.stringify(myConnections));
        
        console.log(`‚úÖ Synced ${myConnections.length} connections:`, myConnections);
        
        // Update UI if needed
        if (typeof updateConnectionsUI === 'function') {
            updateConnectionsUI();
        }
        
        return myConnections;
    } catch (error) {
        console.error('Error syncing connections:', error);
        
        // Fallback to cached connections
        const cached = localStorage.getItem('my_connections');
        if (cached) {
            myConnections = JSON.parse(cached);
            console.log('Using cached connections:', myConnections.length);
        }
        
        return myConnections;
    }
}


// Also sync when worker URL changes
const workerUrlInput = document.getElementById('workerUrl');
if (workerUrlInput) {
    workerUrlInput.addEventListener('blur', () => {
        const url = workerUrlInput.value.trim();
        if (url) {
            localStorage.setItem('worker_url', url);
            syncConnections().catch(err => {
                console.error('Failed to sync connections:', err);
            });
        }
    });
}

async function manualSync() {
    const statusDiv = document.getElementById('syncStatus');
    statusDiv.textContent = 'Syncing...';
    
    const result = await syncConnections();
    
    if (result === null) {
        statusDiv.textContent = '‚ùå Please register first (use test-admin.html or test-guest.html)';
    } else {
        statusDiv.textContent = `‚úÖ Synced ${result.length} connection(s)`;
        setTimeout(() => {
            statusDiv.textContent = '';
        }, 3000);
    }
}    
    
function showStatus(message, type = 'info') {
  const statusDiv = document.getElementById('status');
  statusDiv.textContent = message;
  statusDiv.className = `status ${type} show`;
}

// Helper: Recursively sort object keys (matches Go's behavior)
function sortKeysRecursively(obj) {
  if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
    return obj;
  }
  
  const sorted = {};
  Object.keys(obj).sort().forEach(key => {
    sorted[key] = sortKeysRecursively(obj[key]);
  });
  return sorted;
}

// Helper: base64url encode
function base64UrlEncode(buffer) {
  const base64 = btoa(String.fromCharCode(...buffer));
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

// Helper: Sign request with ECDSA
async function signRequest(data, privateKeyJwk) {
  const sortedData = sortKeysRecursively(data);
  const canonical = JSON.stringify(sortedData);
  
  console.log('Canonical JSON:', canonical);
  
  const privateKey = await crypto.subtle.importKey(
    'jwk',
    privateKeyJwk,
    { name: 'ECDSA', namedCurve: 'P-256' },
    false,
    ['sign']
  );

  const encoder = new TextEncoder();
  const dataBuffer = encoder.encode(canonical);
  
  const signatureBuffer = await crypto.subtle.sign(
    { name: 'ECDSA', hash: 'SHA-256' },
    privateKey,
    dataBuffer
  );

  return base64UrlEncode(new Uint8Array(signatureBuffer));
}
    
function updateConnectionsUI() {
    const recipientInput = document.getElementById('recipientUserId');
    
    if (!recipientInput) return;
    
    if (myConnections.length === 0) {
        // No connections - keep as text input
        recipientInput.placeholder = 'No connections yet - enter user ID manually';
        return;
    }
    
    // Replace text input with dropdown
    const container = recipientInput.parentElement;
    
    const select = document.createElement('select');
    select.id = 'recipientUserId';
    select.style = recipientInput.style;
    
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = 'Select a connection...';
    select.appendChild(defaultOption);
    
    myConnections.forEach(conn => {
        const option = document.createElement('option');
        option.value = conn.id;
        option.textContent = `${conn.name} (${conn.id})`;
        select.appendChild(option);
    });
    
    // Add manual entry option
    const manualOption = document.createElement('option');
    manualOption.value = '__manual__';
    manualOption.textContent = 'üìù Enter manually...';
    select.appendChild(manualOption);
    
    // Handle manual entry
    select.addEventListener('change', (e) => {
        if (e.target.value === '__manual__') {
            const manual = prompt('Enter recipient user ID:');
            if (manual) {
                const newOption = document.createElement('option');
                newOption.value = manual;
                newOption.textContent = `${manual} (manual)`;
                newOption.selected = true;
                select.insertBefore(newOption, manualOption);
            } else {
                select.value = '';
            }
        }
    });
    
    recipientInput.replaceWith(select);
}
// Detect role on page load
// Update DOMContentLoaded
window.addEventListener('DOMContentLoaded', () => {
    // Load from cache immediately (for instant UI)
    const cached = localStorage.getItem('my_connections');
    if (cached) {
        myConnections = JSON.parse(cached);
        updateConnectionsUI();
    }
    
    const myUserId = localStorage.getItem('my_user_id');
    const myName = localStorage.getItem('my_name');
    const workerUrl = localStorage.getItem('worker_url');
    
    if (myUserId && myName) {
        document.getElementById('roleBadge').textContent = myName;
        document.getElementById('roleBadge').className = myUserId === 'admin' ? 'role-badge admin' : 'role-badge guest';
        
        if (workerUrl) {
            document.getElementById('workerUrl').value = workerUrl;
        }
    }
    
    // Sync connections from server (non-blocking)
    syncConnections().catch(err => {
        console.error('Failed to sync connections:', err);
    });
});


// Tags management
document.getElementById('tagInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    const input = e.target;
    const value = input.value.trim();
    if (value && !tags.includes(value)) {
      tags.push(value);
      renderTags();
      input.value = '';
    }
  }
});

function removeTag(tag) {
  tags = tags.filter(t => t !== tag);
  renderTags();
}

function renderTags() {
  const container = document.getElementById('tagsContainer');
  const input = document.getElementById('tagInput');
  
  container.querySelectorAll('.tag-pill').forEach(el => el.remove());
  
  tags.forEach(tag => {
    const pill = document.createElement('div');
    pill.className = 'tag-pill';
    pill.innerHTML = `
      ${tag}
      <button onclick="removeTag('${tag}')" type="button">√ó</button>
    `;
    container.insertBefore(pill, input);
  });
}

// Actions management
function addAction() {
  const actionId = Date.now();
  actions.push({ id: actionId, action: '', title: '', url: '' });
  renderActions();
}

function removeAction(id) {
  actions = actions.filter(a => a.id !== id);
  renderActions();
}

function renderActions() {
  const container = document.getElementById('actionsList');
  const hint = container.querySelector('.hint');
  container.innerHTML = '';
  if (hint) container.appendChild(hint);
  
  actions.forEach(action => {
    const div = document.createElement('div');
    div.className = 'action-item';
    div.innerHTML = `
      <input type="text" placeholder="action" value="${action.action}" 
             onchange="updateAction(${action.id}, 'action', this.value)">
      <input type="text" placeholder="Title" value="${action.title}"
             onchange="updateAction(${action.id}, 'title', this.value)">
      <input type="url" placeholder="URL (optional)" value="${action.url}"
             onchange="updateAction(${action.id}, 'url', this.value)">
      <button type="button" onclick="removeAction(${action.id})">Remove</button>
    `;
    container.appendChild(div);
  });
}

function updateAction(id, field, value) {
  const action = actions.find(a => a.id === id);
  if (action) action[field] = value;
}

// Create rich message with sender tags
function createRichMessage(options) {
  const message = { ...options };
  
  if (!message.tags) {
    message.tags = [];
  } else if (!Array.isArray(message.tags)) {
    message.tags = [message.tags];
  }
  
  // Auto-add sender tags
  const myUserId = localStorage.getItem('my_user_id');
  const myName = localStorage.getItem('my_name');
  
  if (myUserId && myName) {
    message.tags.push(`sender:${myName}`);
    message.tags.push(`senderId:${myUserId}`);
  }
  
  // Remove undefined fields
  Object.keys(message).forEach(key => {
    if (message[key] === undefined) {
      delete message[key];
    }
  });
  
  return message;
}

async function sendRichNotification() {
  const message = document.getElementById('message').value.trim();
  if (!message) {
    showStatus('Message is required', 'error');
    return;
  }

  const richMessage = createRichMessage({
    message: message,
    title: document.getElementById('title').value.trim() || undefined,
    icon: document.getElementById('icon').value.trim() || undefined,
    badge: document.getElementById('badge').value.trim() || undefined,
    image: document.getElementById('image').value.trim() || undefined,
    click: document.getElementById('click').value.trim() || undefined,
    tag: document.getElementById('tag').value.trim() || undefined,
    tags: tags.length > 0 ? tags : undefined,
    requireInteraction: document.getElementById('requireInteraction').checked || undefined,
    silent: document.getElementById('silent').checked || undefined,
    actions: actions.length > 0 ? actions.filter(a => a.action && a.title).map(a => ({
      action: a.action,
      title: a.title,
      url: a.url || undefined
    })) : undefined
  });

  await sendNotification(richMessage);
}

async function sendSimpleNotification() {
  const message = document.getElementById('message').value.trim();
  if (!message) {
    showStatus('Message is required', 'error');
    return;
  }

  const myUserId = localStorage.getItem('my_user_id');
  const myName = localStorage.getItem('my_name');
  
  const simpleMessage = {
    message: message,
    tags: [
      `sender:${myName}`,
      `senderId:${myUserId}`
    ]
  };

  await sendNotification(simpleMessage);
}

async function sendNotification(messageData) {
  let workerUrl = document.getElementById('workerUrl').value.trim();
  const recipientId = document.getElementById('recipientUserId').value.trim();

  if (!workerUrl) {
    showStatus('Worker URL is required', 'error');
    return;
  }

  if (!recipientId) {
    showStatus('Recipient User ID is required', 'error');
    return;
  }

  if (!workerUrl.startsWith('http')) {
    workerUrl = 'https://' + workerUrl;
  }
  workerUrl = workerUrl.replace(/\/$/, '');

  try {
    document.getElementById('sendButton').disabled = true;

    // Get user credentials
    const myUserId = localStorage.getItem('my_user_id');
    const signingKeyJson = localStorage.getItem('signing_key');
    
    if (!myUserId || !signingKeyJson) {
      showStatus('You must be registered first (use test-admin.html or test-guest.html)', 'error');
      document.getElementById('sendButton').disabled = false;
      return;
    }

    const signingKey = JSON.parse(signingKeyJson);

    showStatus('Sending notification...', 'info');

    // Build and sign request
    const timestamp = Date.now();
    const requestData = {
      userId: myUserId,
      toUserId: recipientId,
      timestamp: timestamp,
      payload: messageData
    };

    const signature = await signRequest(requestData, signingKey);

    const response = await fetch(`${workerUrl}/send`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        ...requestData,
        signature: signature
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to send (${response.status}): ${error}`);
    }

    const result = await response.json();
    showStatus(`‚úÖ Notification sent! (${result.sent} devices)`, 'success');

    console.log('Sent message:', messageData);
  } catch (error) {
    console.error('Send error:', error);
    showStatus(`‚ùå Error: ${error.message}`, 'error');
  } finally {
    document.getElementById('sendButton').disabled = false;
  }
}
</script>
</body>
</html>

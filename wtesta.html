<!DOCTYPE html>
<html>
<head>
    <title>Admin Test</title>
</head>
<body>
    <h1>Admin Registration Test</h1>
    <button onclick="testAdmin()">Register Admin</button>
    <div id="output"></div>
<button onclick="createInvite()">Create Invite</button>
<div id="invite-output"></div>

<script>
// Connection sync functionality
let myConnections = [];

// Sync connections from server
async function syncConnections() {
    const myUserId = localStorage.getItem('my_user_id');
    const signingKeyJson = localStorage.getItem('signing_key');
    const workerUrl = localStorage.getItem('worker_url') || document.getElementById('workerUrl')?.value;
    
    if (!myUserId || !signingKeyJson || !workerUrl) {
        console.log('Cannot sync connections: missing credentials');
        return;
    }

    try {
        const signingKey = JSON.parse(signingKeyJson);
        
        const timestamp = Date.now();
        const requestData = {
            userId: myUserId,
            timestamp: timestamp
        };

        const signature = await signRequest(requestData, signingKey);

        let url = workerUrl;
        if (!url.startsWith('http')) url = 'https://' + url;
        url = url.replace(/\/$/, '');

        const response = await fetch(`${url}/connections/list`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                ...requestData,
                signature: signature
            })
        });

        if (!response.ok) {
            throw new Error(`Failed to sync connections: ${response.status}`);
        }

        const data = await response.json();
        myConnections = data.connections || [];
        
        // Store in localStorage for persistence
        localStorage.setItem('my_connections', JSON.stringify(myConnections));
        
        console.log(`‚úÖ Synced ${myConnections.length} connections:`, myConnections);
        
        // Update UI if needed
        if (typeof updateConnectionsUI === 'function') {
            updateConnectionsUI();
        }
        
        return myConnections;
    } catch (error) {
        console.error('Error syncing connections:', error);
        
        // Fallback to cached connections
        const cached = localStorage.getItem('my_connections');
        if (cached) {
            myConnections = JSON.parse(cached);
            console.log('Using cached connections:', myConnections.length);
        }
        
        return myConnections;
    }
}
   
async function createInvite() {
    const output = document.getElementById('invite-output');
    
    try {
        const response = await fetch(`${WORKER_URL}/admin/invite`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-admin-secret': ADMIN_SECRET
            },
            body: JSON.stringify({
                ttlMinutes: 60
            })
        });

        const result = await response.json();
        const inviteUrl = `https://marko-app.netlify.app/wtestg.html?invite=${result.invite}`;
        
        output.innerHTML = `
            ‚úÖ Invite created!<br>
            <a href="${inviteUrl}" target="_blank">${inviteUrl}</a><br>
            <small>Invite UUID: ${result.invite}</small>
        `;

    } catch (error) {
        output.innerHTML = `‚ùå Error: ${error.message}`;
    }
}
</script>
    <input type="text" id="recipient" placeholder="Recipient user ID">
<input type="text" id="message" placeholder="Message">
<button onclick="sendMessage()">Send Message</button>
<div id="send-output"></div>

<script>
async function sendMessage() {
    const recipientId = document.getElementById('recipient').value;
    const message = document.getElementById('message').value;
    const myUserId = localStorage.getItem('my_user_id');
    const myName = localStorage.getItem('my_name');
    
    // Get SIGNING key (not encryption key!)
    const signingPrivateKeyJwk = JSON.parse(localStorage.getItem('signing_key'));

    // Simple payload (no E2EE for testing)
    const payload = {
        message: message,
        title: "New Message",
        tags: [
            "sender:" + myName,
            "senderId:" + myUserId
        ]
    };

    const timestamp = Date.now();
    const requestData = {
        userId: myUserId,
        toUserId: recipientId,
        timestamp: timestamp,
        payload: payload
    };

    // Sign with SIGNING key
    const signature = await signRequest(requestData, signingPrivateKeyJwk);

    const response = await fetch(`${WORKER_URL}/send`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            ...requestData,
            signature: signature
        })
    });

    const result = await response.json();
    document.getElementById('send-output').innerHTML = `‚úÖ Message sent: ${JSON.stringify(result)}<br>`;
}

async function signRequest(data, privateKeyJwk) {
    // Recursively sort all object keys (matches Go's behavior)
    function sortKeysRecursively(obj) {
        if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
            return obj;
        }
        
        const sorted = {};
        Object.keys(obj).sort().forEach(key => {
            sorted[key] = sortKeysRecursively(obj[key]);
        });
        return sorted;
    }
    
    // Create canonical JSON with ALL keys sorted
    const sortedData = sortKeysRecursively(data);
    const canonical = JSON.stringify(sortedData);
    
    console.log('Canonical JSON:', canonical); // Debug
    
    // Import SIGNING private key (ECDSA, not ECDH!)
    const privateKey = await crypto.subtle.importKey(
        'jwk',
        privateKeyJwk,
        { name: 'ECDSA', namedCurve: 'P-256' },
        false,
        ['sign']
    );

    // Sign
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(canonical);
    
    const signatureBuffer = await crypto.subtle.sign(
        { name: 'ECDSA', hash: 'SHA-256' },
        privateKey,
        dataBuffer
    );

    // Encode as base64url
    return base64UrlEncode(new Uint8Array(signatureBuffer));
}

function base64UrlEncode(buffer) {
    const base64 = btoa(String.fromCharCode(...buffer));
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
</script>
    <script>
    const WORKER_URL = 'https://f03262192045.ngrok-free.app';
    const ADMIN_SECRET = '123';
    const VAPID_PUBLIC_KEY = 'BMhLLoH3-WWIIo-FsZitpf4utuD1X9O8tLGZqxll_hKwlthK4jek6vhuxts00AGdMsO-u7qm0Zvy1w-LgNAhNeM';

async function testAdmin() {
    const output = document.getElementById('output');
    output.innerHTML = 'Testing...<br>';

    try {
        // 1. Request notification permission
        const permission = await Notification.requestPermission();
        if (permission !== 'granted') {
            output.innerHTML += '‚ùå Notification permission denied<br>';
            return;
        }
        output.innerHTML += '‚úÖ Notification permission granted<br>';

        // 2. Register service worker
        const registration = await navigator.serviceWorker.register('/sw.js');
        await navigator.serviceWorker.ready;
        output.innerHTML += '‚úÖ Service worker registered<br>';

        // 3. Subscribe to push
        const subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
        });
        output.innerHTML += '‚úÖ Push subscription created<br>';

        // 4. Generate TWO keypairs: one for encryption (ECDH), one for signing (ECDSA)
        
        // For E2EE encryption (ECDH)
        const encryptionKeypair = await crypto.subtle.generateKey(
            { name: 'ECDH', namedCurve: 'P-256' },
            true,
            ['deriveKey']
        );

        // For signing requests (ECDSA)
        const signingKeypair = await crypto.subtle.generateKey(
            { name: 'ECDSA', namedCurve: 'P-256' },
            true,
            ['sign', 'verify']
        );

        // Export all keys
        const encryptionPublicKeyJwk = await crypto.subtle.exportKey('jwk', encryptionKeypair.publicKey);
        const encryptionPrivateKeyJwk = await crypto.subtle.exportKey('jwk', encryptionKeypair.privateKey);
        
        const signingPublicKeyJwk = await crypto.subtle.exportKey('jwk', signingKeypair.publicKey);
        const signingPrivateKeyJwk = await crypto.subtle.exportKey('jwk', signingKeypair.privateKey);

        output.innerHTML += '‚úÖ Keypairs generated (encryption + signing)<br>';

        // 5. Store keys locally
        localStorage.setItem('encryption_key', JSON.stringify(encryptionPrivateKeyJwk));
        localStorage.setItem('public_key', JSON.stringify(encryptionPublicKeyJwk));
        localStorage.setItem('signing_key', JSON.stringify(signingPrivateKeyJwk));
        localStorage.setItem('signing_public_key', JSON.stringify(signingPublicKeyJwk));
        localStorage.setItem('my_user_id', 'admin');
        localStorage.setItem('my_name', 'Admin');

        // 6. Register with server (send SIGNING public key for authentication)
        const response = await fetch(`${WORKER_URL}/admin/register`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-admin-secret': ADMIN_SECRET
            },
            body: JSON.stringify({
                publicKeyJwk: signingPublicKeyJwk,  // ‚Üê Send signing key to server
                subscription: subscription,
                deviceName: 'Test Browser'
            })
        });

        const result = await response.json();
        output.innerHTML += `‚úÖ Admin registered: ${JSON.stringify(result, null, 2)}<br>`;

        localStorage.setItem('device_id', result.deviceId);

        // NEW: Store encryption key in IndexedDB for service worker
        await storeEncryptionKeyInServiceWorker();
        output.innerHTML += '‚úÖ Encryption key stored in service worker<br>';
        
    } catch (error) {
        output.innerHTML += `‚ùå Error: ${error.message}<br>`;
        console.error(error);
    }
}

// Store encryption key in service worker's IndexedDB
// Store encryption key in service worker's IndexedDB
async function storeEncryptionKeyInServiceWorker() {
    const encryptionPrivateKeyJwk = JSON.parse(localStorage.getItem('encryption_key'));
    
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('webpusher-keys', 1);
        
        request.onerror = () => reject(request.error);
        
        request.onsuccess = () => {
            const db = request.result;
            const tx = db.transaction(['keys'], 'readwrite');
            const store = tx.objectStore('keys');
            
            // Wrap in object with 'key' property (service worker expects this)
            store.put({ key: encryptionPrivateKeyJwk }, 'privateKey');
            
            tx.oncomplete = () => {
                console.log('‚úÖ Encryption key stored in service worker DB');
                resolve();
            };
            
            tx.onerror = () => reject(tx.error);
        };
        
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('keys')) {
                db.createObjectStore('keys');
            }
        };
    });
}
    function urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding)
            .replace(/\-/g, '+')
            .replace(/_/g, '/');
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }
    </script>
    <h3>Encrypted Messaging</h3>
<input type="text" id="encrypted-recipient" placeholder="Recipient user ID">
<input type="text" id="encrypted-message" placeholder="Encrypted message">
<button onclick="sendEncryptedMessage()">Send Encrypted Message</button>
<div id="encrypted-output"></div>

<script>
// Helper: base64url encode
function base64UrlEncode(buffer) {
    const base64 = btoa(String.fromCharCode(...buffer));
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}

// Helper: base64url decode
function base64UrlDecode(str) {
    str = str.replace(/-/g, '+').replace(/_/g, '/');
    while (str.length % 4) {
        str += '=';
    }
    const binary = atob(str);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}

async function sendEncryptedMessage() {
    const output = document.getElementById('encrypted-output');
    const recipientId = document.getElementById('encrypted-recipient').value;
    const message = document.getElementById('encrypted-message').value;
    const myUserId = localStorage.getItem('my_user_id');
    const myName = localStorage.getItem('my_name');
    
    output.innerHTML = 'üîê Starting E2EE message send...<br>';

    try {
        // 1. Get recipient's ENCRYPTION public key
        output.innerHTML += 'üì° Fetching recipient public key...<br>';
        
        const keysResponse = await fetch(`${WORKER_URL}/connections/keys/batch`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                connectionIds: [recipientId]
            })
        });
        
        const keysData = await keysResponse.json();
        
        if (!keysData.keys || keysData.keys.length === 0) {
            output.innerHTML += '‚ùå Recipient not found<br>';
            return;
        }
        
        const recipientPublicKeyJwk = keysData.keys[0].publicKey;
        output.innerHTML += '‚úÖ Got recipient public key<br>';

        // 2. Create inner message (what gets encrypted)
        const innerMessage = {
            message: message,
            title: "Encrypted Message",
            tags: [
                "sender:" + myName,
                "senderId:" + myUserId
            ],
            timestamp: Date.now()
        };

        output.innerHTML += 'üîê Encrypting message...<br>';

        // 3. Generate ephemeral keypair for this message (forward secrecy)
        const ephemeralKeypair = await crypto.subtle.generateKey(
            { name: 'ECDH', namedCurve: 'P-256' },
            true,
            ['deriveKey']
        );

        // 4. Import recipient's public key
        const recipientPublicKey = await crypto.subtle.importKey(
            'jwk',
            recipientPublicKeyJwk,
            { name: 'ECDH', namedCurve: 'P-256' },
            false,
            []
        );

        // 5. Derive shared secret
        const sharedSecret = await crypto.subtle.deriveKey(
            { name: 'ECDH', public: recipientPublicKey },
            ephemeralKeypair.privateKey,
            { name: 'AES-GCM', length: 256 },
            false,
            ['encrypt']
        );

        // 6. Encrypt the inner message
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const encoder = new TextEncoder();
        const messageBytes = encoder.encode(JSON.stringify(innerMessage));

        const ciphertext = await crypto.subtle.encrypt(
            { name: 'AES-GCM', iv: iv },
            sharedSecret,
            messageBytes
        );

        // 7. Export ephemeral public key
        const ephemeralPublicKeyJwk = await crypto.subtle.exportKey('jwk', ephemeralKeypair.publicKey);

        // 8. Create encrypted payload
        const encryptedPayload = {
            encrypted: true,
            ephemeralPublicKey: ephemeralPublicKeyJwk,
            iv: base64UrlEncode(iv),
            ciphertext: base64UrlEncode(new Uint8Array(ciphertext))
        };

        output.innerHTML += '‚úÖ Message encrypted<br>';
        output.innerHTML += 'üì§ Sending to server...<br>';

        // 9. Sign the API request (with ECDSA signing key)
        const signingPrivateKeyJwk = JSON.parse(localStorage.getItem('signing_key'));
        
        const timestamp = Date.now();
        const requestData = {
            userId: myUserId,
            toUserId: recipientId,
            timestamp: timestamp,
            payload: encryptedPayload
        };

        const signature = await signRequest(requestData, signingPrivateKeyJwk);

        // 10. Send to server
        const response = await fetch(`${WORKER_URL}/send`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                ...requestData,
                signature: signature
            })
        });

        const result = await response.json();
        
        output.innerHTML += `‚úÖ Encrypted message sent!<br>`;
        output.innerHTML += `Result: ${JSON.stringify(result)}<br>`;
        output.innerHTML += `<small>Encrypted payload size: ${JSON.stringify(encryptedPayload).length} bytes</small><br>`;

    } catch (error) {
        output.innerHTML += `‚ùå Error: ${error.message}<br>`;
        console.error(error);
    }
}
window.addEventListener('DOMContentLoaded', async () => {
    await syncConnections();
});    
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <title>Admin Test</title>
</head>
<body>
    <h1>Admin Registration Test</h1>
    <button onclick="testAdmin()">Register Admin</button>
    <div id="output"></div>
<button onclick="createInvite()">Create Invite</button>
<div id="invite-output"></div>

<script>
async function createInvite() {
    const output = document.getElementById('invite-output');
    
    try {
        const response = await fetch(`${WORKER_URL}/admin/invite`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-admin-secret': ADMIN_SECRET
            },
            body: JSON.stringify({
                ttlMinutes: 60
            })
        });

        const result = await response.json();
        const inviteUrl = `https://marko-app.netlify.app/wtestg.html?invite=${result.invite}`;
        
        output.innerHTML = `
            ✅ Invite created!<br>
            <a href="${inviteUrl}" target="_blank">${inviteUrl}</a><br>
            <small>Invite UUID: ${result.invite}</small>
        `;

    } catch (error) {
        output.innerHTML = `❌ Error: ${error.message}`;
    }
}
</script>
    <input type="text" id="recipient" placeholder="Recipient user ID">
<input type="text" id="message" placeholder="Message">
<button onclick="sendMessage()">Send Message</button>
<div id="send-output"></div>

<script>
async function sendMessage() {
    const recipientId = document.getElementById('recipient').value;
    const message = document.getElementById('message').value;
    const myUserId = localStorage.getItem('my_user_id');
    const myName = localStorage.getItem('my_name');
    
    // Get SIGNING key (not encryption key!)
    const signingPrivateKeyJwk = JSON.parse(localStorage.getItem('signing_key'));

    // Simple payload (no E2EE for testing)
    const payload = {
        message: message,
        title: "New Message",
        tags: [
            "sender:" + myName,
            "senderId:" + myUserId
        ]
    };

    const timestamp = Date.now();
    const requestData = {
        userId: myUserId,
        toUserId: recipientId,
        timestamp: timestamp,
        payload: payload
    };

    // Sign with SIGNING key
    const signature = await signRequest(requestData, signingPrivateKeyJwk);

    const response = await fetch(`${WORKER_URL}/send`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            ...requestData,
            signature: signature
        })
    });

    const result = await response.json();
    document.getElementById('send-output').innerHTML = `✅ Message sent: ${JSON.stringify(result)}<br>`;
}

async function signRequest(data, privateKeyJwk) {
    // Create canonical JSON
    const canonical = JSON.stringify(data, Object.keys(data).sort());
    
    // Import SIGNING private key (ECDSA, not ECDH!)
    const privateKey = await crypto.subtle.importKey(
        'jwk',
        privateKeyJwk,
        { name: 'ECDSA', namedCurve: 'P-256' },  // ← ECDSA for signing
        false,
        ['sign']
    );

    // Sign
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(canonical);
    
    const signatureBuffer = await crypto.subtle.sign(
        { name: 'ECDSA', hash: 'SHA-256' },
        privateKey,
        dataBuffer
    );

    // Encode as base64url
    return base64UrlEncode(new Uint8Array(signatureBuffer));
}

function base64UrlEncode(buffer) {
    const base64 = btoa(String.fromCharCode(...buffer));
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
</script>
    <script>
    const WORKER_URL = 'https://f03262192045.ngrok-free.app';
    const ADMIN_SECRET = '123';
    const VAPID_PUBLIC_KEY = 'BMhLLoH3-WWIIo-FsZitpf4utuD1X9O8tLGZqxll_hKwlthK4jek6vhuxts00AGdMsO-u7qm0Zvy1w-LgNAhNeM';

async function testAdmin() {
    const output = document.getElementById('output');
    output.innerHTML = 'Testing...<br>';

    try {
        // 1. Request notification permission
        const permission = await Notification.requestPermission();
        if (permission !== 'granted') {
            output.innerHTML += '❌ Notification permission denied<br>';
            return;
        }
        output.innerHTML += '✅ Notification permission granted<br>';

        // 2. Register service worker
        const registration = await navigator.serviceWorker.register('/sw.js');
        await navigator.serviceWorker.ready;
        output.innerHTML += '✅ Service worker registered<br>';

        // 3. Subscribe to push
        const subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
        });
        output.innerHTML += '✅ Push subscription created<br>';

        // 4. Generate TWO keypairs: one for encryption (ECDH), one for signing (ECDSA)
        
        // For E2EE encryption (ECDH)
        const encryptionKeypair = await crypto.subtle.generateKey(
            { name: 'ECDH', namedCurve: 'P-256' },
            true,
            ['deriveKey']
        );

        // For signing requests (ECDSA)
        const signingKeypair = await crypto.subtle.generateKey(
            { name: 'ECDSA', namedCurve: 'P-256' },
            true,
            ['sign', 'verify']
        );

        // Export all keys
        const encryptionPublicKeyJwk = await crypto.subtle.exportKey('jwk', encryptionKeypair.publicKey);
        const encryptionPrivateKeyJwk = await crypto.subtle.exportKey('jwk', encryptionKeypair.privateKey);
        
        const signingPublicKeyJwk = await crypto.subtle.exportKey('jwk', signingKeypair.publicKey);
        const signingPrivateKeyJwk = await crypto.subtle.exportKey('jwk', signingKeypair.privateKey);

        output.innerHTML += '✅ Keypairs generated (encryption + signing)<br>';

        // 5. Store keys locally
        localStorage.setItem('encryption_key', JSON.stringify(encryptionPrivateKeyJwk));
        localStorage.setItem('public_key', JSON.stringify(encryptionPublicKeyJwk));
        localStorage.setItem('signing_key', JSON.stringify(signingPrivateKeyJwk));
        localStorage.setItem('signing_public_key', JSON.stringify(signingPublicKeyJwk));
        localStorage.setItem('my_user_id', 'admin');
        localStorage.setItem('my_name', 'Admin');

        // 6. Register with server (send SIGNING public key for authentication)
        const response = await fetch(`${WORKER_URL}/admin/register`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-admin-secret': ADMIN_SECRET
            },
            body: JSON.stringify({
                publicKeyJwk: signingPublicKeyJwk,  // ← Send signing key to server
                subscription: subscription,
                deviceName: 'Test Browser'
            })
        });

        const result = await response.json();
        output.innerHTML += `✅ Admin registered: ${JSON.stringify(result, null, 2)}<br>`;

        localStorage.setItem('device_id', result.deviceId);

    } catch (error) {
        output.innerHTML += `❌ Error: ${error.message}<br>`;
        console.error(error);
    }
}

    function urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding)
            .replace(/\-/g, '+')
            .replace(/_/g, '/');
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }
    </script>
</body>
</html>

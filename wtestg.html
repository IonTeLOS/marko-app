<!DOCTYPE html>
<html>
<head>
    <title>Guest Test</title>
</head>
<body>
    <h1>Guest Registration Test</h1>
    <input type="text" id="name" placeholder="Your name" value="Alice">
    <button onclick="registerGuest()">Register as Guest</button>
    <div id="output"></div>

    <script>
    const WORKER_URL = 'https://f03262192045.ngrok-free.app';
    const VAPID_PUBLIC_KEY = 'BMhLLoH3-WWIIo-FsZitpf4utuD1X9O8tLGZqxll_hKwlthK4jek6vhuxts00AGdMsO-u7qm0Zvy1w-LgNAhNeM';

async function registerGuest() {
    const output = document.getElementById('output');
    const name = document.getElementById('name').value;
    
    // Get invite from URL
    const params = new URLSearchParams(window.location.search);
    const inviteUUID = params.get('invite');
    
    if (!inviteUUID) {
        output.innerHTML = '❌ No invite UUID in URL';
        return;
    }

    try {
        // Request permission
        const permission = await Notification.requestPermission();
        if (permission !== 'granted') {
            output.innerHTML = '❌ Permission denied';
            return;
        }
        output.innerHTML += '✅ Notification permission granted<br>';

        // Register service worker
        const registration = await navigator.serviceWorker.register('/sw.js');
        await navigator.serviceWorker.ready;
        output.innerHTML += '✅ Service worker registered<br>';

        // Subscribe to push
        const subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: urlBase64ToUint8Array(VAPID_PUBLIC_KEY)
        });
        output.innerHTML += '✅ Push subscription created<br>';

        // Generate TWO keypairs: one for encryption (ECDH), one for signing (ECDSA)
        
        // For E2EE encryption (ECDH)
        const encryptionKeypair = await crypto.subtle.generateKey(
            { name: 'ECDH', namedCurve: 'P-256' },
            true,
            ['deriveKey']
        );

        // For signing requests (ECDSA)
        const signingKeypair = await crypto.subtle.generateKey(
            { name: 'ECDSA', namedCurve: 'P-256' },
            true,
            ['sign', 'verify']
        );

        // Export all keys
        const encryptionPublicKeyJwk = await crypto.subtle.exportKey('jwk', encryptionKeypair.publicKey);
        const encryptionPrivateKeyJwk = await crypto.subtle.exportKey('jwk', encryptionKeypair.privateKey);
        
        const signingPublicKeyJwk = await crypto.subtle.exportKey('jwk', signingKeypair.publicKey);
        const signingPrivateKeyJwk = await crypto.subtle.exportKey('jwk', signingKeypair.privateKey);

        output.innerHTML += '✅ Keypairs generated (encryption + signing)<br>';

        // Store keys locally
        localStorage.setItem('encryption_key', JSON.stringify(encryptionPrivateKeyJwk));
        localStorage.setItem('public_key', JSON.stringify(encryptionPublicKeyJwk));
        localStorage.setItem('signing_key', JSON.stringify(signingPrivateKeyJwk));
        localStorage.setItem('signing_public_key', JSON.stringify(signingPublicKeyJwk));
        localStorage.setItem('my_name', name);
        localStorage.setItem('worker_url', WORKER_URL);

        // Store encryption key in service worker's IndexedDB
        await storeEncryptionKeyInServiceWorker();
        output.innerHTML += '✅ Encryption key stored in service worker<br>';

        // Register with server (send SIGNING public key for authentication)
        const response = await fetch(`${WORKER_URL}/guest/register/${inviteUUID}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                name: name,
                publicKeyJwk: signingPublicKeyJwk,  // ← Send signing key to server
                subscription: subscription,
                deviceName: 'Guest Browser'
            })
        });

        if (!response.ok) {
            throw new Error(`Registration failed: ${response.status}`);
        }

        const result = await response.json();
        localStorage.setItem('my_user_id', result.userId);
        localStorage.setItem('device_id', result.deviceId);

        output.innerHTML += `✅ Registered as guest!<br>
            User ID: ${result.userId}<br>
            Device ID: ${result.deviceId}<br>
            <br>
            <strong>Copy your User ID to send to others!</strong>`;

    } catch (error) {
        output.innerHTML += `❌ Error: ${error.message}<br>`;
        console.error(error);
    }
}

    // Store encryption key in service worker's IndexedDB
async function storeEncryptionKeyInServiceWorker() {
    const encryptionPrivateKeyJwk = JSON.parse(localStorage.getItem('encryption_key'));
    
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('webpusher-keys', 1);
        
        request.onerror = () => reject(request.error);
        
        request.onsuccess = () => {
            const db = request.result;
            const tx = db.transaction(['keys'], 'readwrite');
            const store = tx.objectStore('keys');
            
            // Wrap in object with 'key' property (service worker expects this)
            store.put({ key: encryptionPrivateKeyJwk }, 'privateKey');
            
            tx.oncomplete = () => {
                console.log('✅ Encryption key stored in service worker DB');
                resolve();
            };
            
            tx.onerror = () => reject(tx.error);
        };
        
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('keys')) {
                db.createObjectStore('keys');
            }
        };
    });
}
    function urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - base64String.length % 4) % 4);
        const base64 = (base64String + padding)
            .replace(/\-/g, '+')
            .replace(/_/g, '/');
        const rawData = window.atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray;
    }
    </script>
</body>
</html>

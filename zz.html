<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZK Email Prover - Real Cryptographic Proofs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.2em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            min-height: 600px;
        }

        .upload-section {
            padding: 40px;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .step {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .step-number {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #667eea;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
        }

        .step-number.completed {
            background: #38a169;
        }

        .step-number.active {
            background: #f56565;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .step-content h3 {
            margin-bottom: 5px;
            color: #2d3748;
        }

        .step-content p {
            color: #666;
            font-size: 14px;
        }

        .upload-area {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: #667eea;
            background: #f7fafc;
        }

        .upload-area.has-file {
            border-color: #38a169;
            background: #f0fff4;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 20px;
            color: #a0aec0;
        }

        .upload-area.has-file .upload-icon {
            color: #38a169;
        }

        .upload-text {
            font-size: 18px;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .upload-subtext {
            color: #a0aec0;
            font-size: 14px;
        }

        .file-input {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
        }

        .file-info {
            background: #e6fffa;
            border: 1px solid #81e6d9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            display: none;
        }

        .file-info.show {
            display: block;
        }

        .prove-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .prove-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .prove-button:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }

        .prove-button.loading {
            background: #fbb434;
            position: relative;
            overflow: hidden;
        }

        .prove-button.loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .sidebar {
            background: #1a202c;
            color: white;
            padding: 40px;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .info-card h3 {
            margin-bottom: 15px;
            color: #81e6d9;
            font-size: 1.1em;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #38a169, #68d391);
            width: 0%;
            transition: width 0.3s ease;
        }

        .log-area {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }

        .result-area {
            background: rgba(72, 187, 120, 0.1);
            border: 1px solid rgba(72, 187, 120, 0.3);
            border-radius: 8px;
            padding: 20px;
            display: none;
        }

        .result-area.show {
            display: block;
        }

        .result-data {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            margin: 10px 0;
            word-break: break-all;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            background: #4299e1;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
        }

        .btn:hover {
            background: #3182ce;
        }

        .btn.success {
            background: #38a169;
        }

        .notice {
            background: rgba(72, 187, 120, 0.1);
            border: 1px solid rgba(72, 187, 120, 0.3);
            border-radius: 8px;
            padding: 15px;
            color: #81e6d9;
            font-size: 14px;
        }

        .error {
            background: rgba(245, 101, 101, 0.1);
            border: 1px solid rgba(245, 101, 101, 0.3);
            border-radius: 8px;
            padding: 15px;
            color: #fc8181;
            font-size: 14px;
            margin: 10px 0;
        }

        .proof-details {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .sidebar {
                order: -1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê ZK Email Prover</h1>
            <p>Generate Real Cryptographic Zero-Knowledge Proofs</p>
        </div>

        <div class="main-content">
            <div class="upload-section">
                <!-- Step Progress -->
                <div class="steps">
                    <div class="step">
                        <div class="step-number active" id="step1">1</div>
                        <div class="step-content">
                            <h3>Upload Email File</h3>
                            <p>Select or drag & drop your .eml email file</p>
                        </div>
                    </div>

                    <div class="step">
                        <div class="step-number" id="step2">2</div>
                        <div class="step-content">
                            <h3>Generate Proof</h3>
                            <p>Create cryptographic proof using ZK Email API</p>
                        </div>
                    </div>

                    <div class="step">
                        <div class="step-number" id="step3">3</div>
                        <div class="step-content">
                            <h3>Download Results</h3>
                            <p>Get your verifiable proof data</p>
                        </div>
                    </div>
                </div>

                <!-- File Upload Area -->
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üìß</div>
                    <div class="upload-text">Click to select email file or drag & drop</div>
                    <div class="upload-subtext">Supports .eml files from any email provider</div>
                    <input type="file" class="file-input" id="fileInput" accept=".eml,.txt,.msg">
                </div>

                <div class="file-info" id="fileInfo">
                    <h4>üìÅ Selected File:</h4>
                    <p id="fileName"></p>
                    <p id="fileSize"></p>
                </div>

                <!-- Prove Button -->
                <button class="prove-button" id="proveButton" disabled>
                    üöÄ Generate Cryptographic Proof (Server-Side)
                </button>

                <!-- Results Area -->
                <div class="result-area" id="resultArea">
                    <h3>‚úÖ Cryptographic Proof Generated!</h3>
                    <div class="result-data" id="resultData"></div>
                    <div class="proof-details" id="proofDetails"></div>
                    <div class="action-buttons">
                        <button class="btn" id="downloadJson">üì• Download Proof JSON</button>
                        <button class="btn" id="copyProofId">üìã Copy Proof ID</button>
                        <button class="btn" id="viewProof">üîó View Full Proof</button>
                        <button class="btn" id="verifyProof">üîç Verify Proof</button>
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <div class="info-card">
                    <h3>üõ°Ô∏è Real ZK Proofs</h3>
                    <div class="notice">
                        <strong>Cryptographically Valid:</strong> This generates real zero-knowledge proofs using the ZK Email protocol. Proofs are verifiable on-chain and can be used in smart contracts.
                    </div>
                </div>

                <div class="info-card">
                    <h3>üìä Progress</h3>
                    <div id="progressText">Ready to upload email file...</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>

                <div class="info-card">
                    <h3>üìù Activity Log</h3>
                    <div class="log-area" id="logArea">
                        <div>ZK Email Prover initialized</div>
                        <div>Ready for real proof generation</div>
                        <div>API endpoints configured</div>
                    </div>
                </div>

                <div class="info-card">
                    <h3>‚ÑπÔ∏è Blueprint Info</h3>
                    <div style="font-size: 12px; opacity: 0.8;">
                        <p><strong>Blueprint ID:</strong><br>e7d84ab3-68f3-46b4-a1af-f6c87611d423</p>
                        <p style="margin-top: 10px;"><strong>Extracts:</strong></p>
                        <ul style="margin-left: 15px; margin-top: 5px;">
                            <li>Subject</li>
                            <li>Sender Domain</li>
                            <li>Email Recipient</li>
                            <li>DKIM Timestamp</li>
                        </ul>
                        <p style="margin-top: 10px;"><strong>Proof Type:</strong> Groth16</p>
                        <p><strong>Proving:</strong> Server-side (reliable)</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Real ZK Email API Implementation -->
    <script>
        // Updated JavaScript class for ZK Email Prover using proper SDK integration
// This replaces the existing ZKEmailProver class in your HTML

// Browser-optimized ZK Email Prover for Netlify hosting
// This version works directly in the browser without Node.js dependencies

class ZKEmailProver {
    constructor() {
        this.blueprintId = 'e7d84ab3-68f3-46b4-a1af-f6c87611d423';
        this.selectedFile = null;
        this.proofResult = null;
        this.emailContent = null;
        
        // Browser-specific configuration
        this.backendEndpoint = '/.netlify/functions/generate-zk-proof';
        this.registryUrl = 'https://registry.zkregex.com';
        
        // Try to detect if we can use the ZK Email SDK directly in browser
        this.browserSDKAvailable = false;
        this.checkBrowserSDKAvailability();
        
        this.initializeEventListeners();
        this.log('ZK Email Prover initialized for browser');
        this.log('‚úÖ Optimized for Netlify frontend hosting');
    }

    async checkBrowserSDKAvailability() {
        try {
            // Check if ZK Email SDK is available via CDN or bundled
            if (typeof window !== 'undefined' && window.zkEmail) {
                this.browserSDKAvailable = true;
                this.log('‚úÖ ZK Email SDK available in browser');
            } else {
                this.log('‚ÑπÔ∏è ZK Email SDK not available in browser - using backend proxy');
            }
        } catch (error) {
            this.log('‚ÑπÔ∏è Browser SDK check failed - using backend proxy');
        }
    }

    initializeEventListeners() {
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const proveButton = document.getElementById('proveButton');

        if (!uploadArea || !fileInput || !proveButton) {
            this.log('‚ùå Required DOM elements not found');
            return;
        }

        // File upload handling
        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                this.handleFileSelect(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                this.handleFileSelect(e.target.files[0]);
            }
        });

        proveButton.addEventListener('click', () => {
            this.generateProof();
        });

        // Result actions - add null checks
        const downloadBtn = document.getElementById('downloadJson');
        const copyBtn = document.getElementById('copyProofId');
        const viewBtn = document.getElementById('viewProof');
        const verifyBtn = document.getElementById('verifyProof');

        if (downloadBtn) downloadBtn.addEventListener('click', () => this.downloadJSON());
        if (copyBtn) copyBtn.addEventListener('click', () => this.copyProofId());
        if (viewBtn) viewBtn.addEventListener('click', () => this.viewFullProof());
        if (verifyBtn) verifyBtn.addEventListener('click', () => this.verifyProof());
    }

    handleFileSelect(file) {
        const validExtensions = ['.eml', '.txt', '.msg'];
        const hasValidExtension = validExtensions.some(ext => 
            file.name.toLowerCase().endsWith(ext)
        );

        if (!hasValidExtension) {
            this.log('‚ùå Please select an email file (.eml, .txt, .msg)');
            this.showUserMessage('Please select an email file (.eml, .txt, .msg)', 'error');
            return;
        }

        // Check file size (reasonable limit for email files)
        const maxSize = 10 * 1024 * 1024; // 10MB
        if (file.size > maxSize) {
            this.log('‚ùå File too large (max 10MB)');
            this.showUserMessage('File too large. Please select a file smaller than 10MB.', 'error');
            return;
        }

        this.selectedFile = file;

        // Update UI safely
        this.safeUpdateElement('uploadArea', (el) => el.classList.add('has-file'));
        this.safeUpdateElement('fileInfo', (el) => el.classList.add('show'));
        this.safeUpdateElement('fileName', (el) => el.textContent = file.name);
        this.safeUpdateElement('fileSize', (el) => el.textContent = `${(file.size / 1024).toFixed(1)} KB`);
        this.safeUpdateElement('proveButton', (el) => el.disabled = false);

        // Update steps
        this.safeUpdateElement('step1', (el) => {
            el.classList.remove('active');
            el.classList.add('completed');
        });
        this.safeUpdateElement('step2', (el) => el.classList.add('active'));

        this.updateProgress(33, 'Email file selected - Ready to generate proof');
        this.log(`‚úÖ File selected: ${file.name} (${(file.size / 1024).toFixed(1)} KB)`);
    }

    async generateProof() {
        if (!this.selectedFile) {
            this.log('‚ùå No file selected');
            return;
        }

        try {
            const proveButton = document.getElementById('proveButton');
            if (proveButton) {
                proveButton.classList.add('loading');
                proveButton.textContent = '‚è≥ Generating Cryptographic Proof...';
                proveButton.disabled = true;
            }

            this.updateProgress(50, 'Reading email content...');
            this.log('üìß Reading email file...');

            // Read file content
            this.emailContent = await this.readFileContent(this.selectedFile);
            this.log('‚úÖ Email content read successfully');

            // Basic email validation
            const validation = this.validateEmailContent(this.emailContent);
            if (!validation.isValid) {
                throw new Error('Invalid email format - missing required headers');
            }

            if (!validation.hasDKIM) {
                this.log('‚ö†Ô∏è Warning: No DKIM signature found in email');
                this.showUserMessage('Warning: Email may not have DKIM signature required for ZK proof', 'warning');
            }

            this.updateProgress(60, 'Connecting to ZK Email service...');
            this.log('üöÄ Starting proof generation...');

            // Try browser SDK first if available, then fallback to backend
            let result;
            if (this.browserSDKAvailable) {
                result = await this.tryBrowserSDK();
            } else {
                result = await this.callBackendService();
            }

            this.proofResult = result;
            this.showResults(result);

        } catch (error) {
            this.log(`‚ùå Error generating proof: ${error.message}`);
            this.showError(error.message);
            this.resetProveButton();
        }
    }

    async tryBrowserSDK() {
        this.log('üîÑ Attempting browser SDK proof generation...');
        this.updateProgress(70, 'Using browser ZK Email SDK...');

        try {
            // This would only work if the SDK is properly loaded via CDN
            if (window.zkEmail && window.zkEmail.generateProof) {
                const result = await window.zkEmail.generateProof({
                    email: this.emailContent,
                    blueprint: this.blueprintId,
                    proving: 'server' // Use server proving for speed
                });

                if (result && result.id) {
                    this.log('‚úÖ Proof generated via browser SDK!');
                    this.updateProgress(100, 'Cryptographic proof generated!');
                    return result;
                }
            }
            
            throw new Error('Browser SDK not properly configured');

        } catch (error) {
            this.log(`‚ùå Browser SDK failed: ${error.message}`);
            // Fallback to backend
            return await this.callBackendService();
        }
    }

    async callBackendService() {
        this.log('üîß Using backend service for proof generation...');
        this.updateProgress(70, 'Connecting to backend service...');

        try {
            const response = await fetch(this.backendEndpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    emailContent: this.emailContent,
                    blueprintId: this.blueprintId,
                    fileName: this.selectedFile.name
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Backend error (${response.status}): ${errorText}`);
            }

            const result = await response.json();

            if (result.success && result.proof) {
                this.log('‚úÖ Proof generated successfully via backend!');
                this.updateProgress(100, 'Cryptographic proof generated!');
                return result.proof;
            } else if (result.status === 'processing' && result.jobId) {
                this.log('‚è≥ Proof generation in progress...');
                return await this.pollForCompletion(result.jobId, result.pollUrl);
            } else if (result.status === 'api_unavailable' || result.status === 'redirect_required') {
                this.log('üîÑ API unavailable, preparing registry redirect...');
                return this.handleRegistryRedirect(result);
            } else {
                throw new Error(result.error || result.message || 'Unknown backend error');
            }

        } catch (error) {
            this.log(`‚ùå Backend service failed: ${error.message}`);
            
            // Final fallback: registry redirect
            return this.handleRegistryRedirect({
                blueprintId: this.blueprintId,
                registryUrl: `${this.registryUrl}/${this.blueprintId}`,
                fileName: this.selectedFile.name,
                status: 'redirect_required',
                message: 'Backend service unavailable'
            });
        }
    }

    async pollForCompletion(jobId, pollUrl, maxAttempts = 15) {
        this.log(`üîÑ Polling for proof completion (job: ${jobId})...`);

        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                this.updateProgress(80 + (attempt / maxAttempts) * 15, `Checking proof status (${attempt}/${maxAttempts})...`);

                const statusResponse = await fetch(pollUrl);
                
                if (statusResponse.ok) {
                    const result = await statusResponse.json();
                    
                    if (result.status === 'completed' || result.status === 'success') {
                        this.log('‚úÖ Async proof generation completed!');
                        this.updateProgress(100, 'Proof generation completed!');
                        return result;
                    } else if (result.status === 'failed' || result.status === 'error') {
                        throw new Error(`Proof generation failed: ${result.error || 'Unknown error'}`);
                    }
                    
                    this.log(`‚è≥ Proof status: ${result.status} (attempt ${attempt})`);
                }

                // Wait before next poll
                await this.sleep(3000);

            } catch (error) {
                this.log(`‚ùå Polling attempt ${attempt} failed: ${error.message}`);
                
                if (attempt === maxAttempts) {
                    throw new Error('Proof generation timed out');
                }
            }
        }

        throw new Error('Maximum polling attempts reached');
    }

    handleRegistryRedirect(result) {
        this.log('üöÄ Preparing registry redirect...');
        this.updateProgress(90, 'Preparing registry access...');

        // Create download for the email file
        const emailBlob = new Blob([this.emailContent], { type: 'text/plain' });
        const downloadUrl = URL.createObjectURL(emailBlob);
        
        // Create and show instructions
        this.showRegistryInstructions(downloadUrl, result);

        // Auto-download the file
        setTimeout(() => {
            this.downloadEmailFile(downloadUrl, this.selectedFile.name);
        }, 1000);

        // Return redirect result
        return {
            id: 'redirect-' + Date.now(),
            status: 'redirected',
            message: 'Please complete proof generation in ZK Email registry',
            registryUrl: result.registryUrl || `${this.registryUrl}/${this.blueprintId}`,
            fileName: this.selectedFile.name,
            redirected: true
        };
    }

    showRegistryInstructions(downloadUrl, result) {
        const instructionsHTML = `
            <div class="notice" style="margin: 20px 0; padding: 20px; background: rgba(72, 187, 120, 0.1); border: 1px solid rgba(72, 187, 120, 0.3); border-radius: 8px;">
                <strong>üöÄ ZK Email Registry Required</strong><br><br>
                Direct API access is limited. Please use the ZK Email registry:<br><br>
                <strong>üìã Steps:</strong><br>
                1. <button id="downloadEmailBtn" style="background: #4299e1; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; margin: 5px 0;">üì• Download Email File</button><br>
                2. <button id="openRegistryBtn" style="background: #38a169; color: white; border: none; padding: 12px 20px; border-radius: 6px; cursor: pointer; font-size: 16px; margin: 5px 0;">üöÄ Open ZK Email Registry</button><br>
                3. Upload the email file in the registry<br>
                4. Select "Server Proving" for best performance<br>
                5. Generate your cryptographic proof<br><br>
                <em>The registry will create a real, verifiable zero-knowledge proof.</em>
            </div>
        `;

        const uploadSection = document.querySelector('.upload-section');
        if (uploadSection) {
            uploadSection.insertAdjacentHTML('beforeend', instructionsHTML);

            // Add event listeners
            const downloadBtn = document.getElementById('downloadEmailBtn');
            const openBtn = document.getElementById('openRegistryBtn');

            if (downloadBtn) {
                downloadBtn.addEventListener('click', () => {
                    this.downloadEmailFile(downloadUrl, this.selectedFile.name);
                });
            }

            if (openBtn) {
                openBtn.addEventListener('click', () => {
                    const registryUrl = result.registryUrl || `${this.registryUrl}/${this.blueprintId}`;
                    window.open(registryUrl, '_blank', 'width=1200,height=800');
                    this.log('üöÄ ZK Email registry opened in new tab');
                });
            }
        }
    }

    downloadEmailFile(url, filename) {
        const downloadLink = document.createElement('a');
        downloadLink.href = url;
        downloadLink.download = filename;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        this.log('üì• Email file downloaded for registry upload');
    }

    // Utility functions
    async readFileContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(new Error('Failed to read file'));
            reader.readAsText(file);
        });
    }

    validateEmailContent(emailContent) {
        const hasHeaders = emailContent.includes('From:') || emailContent.includes('Subject:');
        const hasDKIM = emailContent.includes('DKIM-Signature:');
        const hasMessageId = emailContent.includes('Message-ID:');
        
        return {
            isValid: hasHeaders,
            hasDKIM: hasDKIM,
            hasMessageId: hasMessageId
        };
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    safeUpdateElement(id, updateFn) {
        const element = document.getElementById(id);
        if (element && typeof updateFn === 'function') {
            try {
                updateFn(element);
            } catch (error) {
                this.log(`‚ùå Error updating element ${id}: ${error.message}`);
            }
        }
    }

    showUserMessage(message, type = 'info') {
        // Create a user-friendly notification
        const alertClass = type === 'error' ? 'error' : type === 'warning' ? 'warning' : 'notice';
        const icon = type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
        
        const messageDiv = document.createElement('div');
        messageDiv.className = alertClass;
        messageDiv.style.margin = '10px 0';
        messageDiv.style.padding = '10px';
        messageDiv.style.borderRadius = '4px';
        messageDiv.innerHTML = `${icon} ${message}`;

        const uploadSection = document.querySelector('.upload-section');
        if (uploadSection) {
            uploadSection.appendChild(messageDiv);
            
            // Remove after 10 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.remove();
                }
            }, 10000);
        }
    }

    resetProveButton() {
        const proveButton = document.getElementById('proveButton');
        if (proveButton) {
            proveButton.classList.remove('loading');
            proveButton.textContent = 'üöÄ Generate Cryptographic Proof (Server-Side)';
            proveButton.disabled = false;
        }
        this.updateProgress(0, 'Ready to try again');
    }

    // Results display methods (simplified for browser)
    showResults(result) {
        // Update progress steps
        this.safeUpdateElement('step2', (el) => {
            el.classList.remove('active');
            el.classList.add('completed');
        });
        this.safeUpdateElement('step3', (el) => el.classList.add('completed'));

        this.updateProgress(100, 'Process completed!');

        // Show results area
        const resultArea = document.getElementById('resultArea');
        const resultData = document.getElementById('resultData');
        const proofDetails = document.getElementById('proofDetails');

        if (!resultArea) return;

        if (result.redirected) {
            this.showRedirectResults(result, resultData, proofDetails);
        } else {
            this.showProofResults(result, resultData, proofDetails);
        }

        resultArea.classList.add('show');
        this.updateProveButtonFinal(result);
    }

    showRedirectResults(result, resultData, proofDetails) {
        const resultArea = document.getElementById('resultArea');
        if (resultArea) {
            const titleEl = resultArea.querySelector('h3');
            if (titleEl) titleEl.textContent = 'üöÄ Ready for ZK Email Registry';
        }

        if (resultData) {
            resultData.innerHTML = `
                <div><strong>Status:</strong> Redirected to ZK Email Registry</div>
                <div><strong>File:</strong> ${result.fileName}</div>
                <div><strong>Registry URL:</strong> <a href="${result.registryUrl}" target="_blank" rel="noopener">${result.registryUrl}</a></div>
                <div><strong>Blueprint ID:</strong> ${this.blueprintId}</div>
                <div><strong>Next Steps:</strong> Complete proof generation in the registry</div>
            `;
        }

        if (proofDetails) {
            proofDetails.innerHTML = `
                <strong>üìã Registry Instructions:</strong><br>
                1. Email file has been downloaded<br>
                2. Upload it in the ZK Email registry<br>
                3. Select "Server Proving" for reliability<br>
                4. Generate your cryptographic proof<br>
                5. Download the proof JSON from the registry<br>
                <br>
                <em>The registry creates real, verifiable zero-knowledge proofs.</em>
            `;
        }

        this.updateResultButtons(result);
    }

    showProofResults(result, resultData, proofDetails) {
        const extractedData = this.extractProofData(result.publicData || {});
        
        if (resultData) {
            resultData.innerHTML = `
                <div><strong>Proof ID:</strong> ${result.id || 'N/A'}</div>
                <div><strong>Subject:</strong> ${extractedData.subject || 'N/A'}</div>
                <div><strong>Sender Domain:</strong> ${extractedData.senderDomain || 'N/A'}</div>
                <div><strong>Email Recipient:</strong> ${extractedData.emailRecipient || 'N/A'}</div>
                <div><strong>Timestamp:</strong> ${extractedData.timestamp || 'N/A'}</div>
                <div><strong>Status:</strong> ${result.status || 'completed'}</div>
                <div><strong>Verified:</strong> ${result.verified ? '‚úÖ Valid' : result.verified === false ? '‚ùå Invalid' : '‚è≥ Pending'}</div>
            `;
        }

        if (proofDetails) {
            proofDetails.innerHTML = `
                <strong>Cryptographic Proof Data (ZK-SNARK):</strong><br>
                ${this.formatProofData(result.proofData || {})}<br>
                <br>
                <em>Real, verifiable zero-knowledge proof generated successfully.</em>
            `;
        }

        this.log('‚úÖ Cryptographic proof generation completed');
    }

    updateResultButtons(result) {
        // Update download button
        this.safeUpdateElement('downloadJson', (btn) => {
            if (result.redirected) {
                btn.textContent = 'üîó Open Registry';
                btn.onclick = () => window.open(result.registryUrl, '_blank');
            }
        });

        // Hide/show other buttons based on result type
        if (result.redirected) {
            this.safeUpdateElement('copyProofId', (btn) => btn.style.display = 'none');
            this.safeUpdateElement('verifyProof', (btn) => btn.style.display = 'none');
            this.safeUpdateElement('viewProof', (btn) => {
                btn.textContent = 'üìß Re-download Email';
                btn.onclick = () => this.redownloadEmail();
            });
        }
    }

    updateProveButtonFinal(result) {
        const proveButton = document.getElementById('proveButton');
        if (proveButton) {
            proveButton.classList.remove('loading');
            
            if (result.redirected) {
                proveButton.textContent = 'üöÄ Registry Opened - Complete There';
                proveButton.style.background = '#4285f4';
            } else {
                proveButton.textContent = '‚úÖ ZK Proof Generated!';
                proveButton.style.background = '#38a169';
            }
        }
    }

    // Helper methods for result processing
    extractProofData(publicData) {
        return {
            subject: publicData.subject?.[0] || publicData.email_subject?.[0] || 'N/A',
            senderDomain: publicData.sender_domain?.[0] || publicData.domain?.[0] || 'N/A',
            emailRecipient: publicData.email_recipient?.[0] || publicData.recipient?.[0] || 'N/A',
            timestamp: publicData.email_timestamp?.[0] ? 
                new Date(parseInt(publicData.email_timestamp[0]) * 1000).toLocaleString() : 
                publicData.timestamp || 'N/A'
        };
    }

    formatProofData(proofData) {
        if (!proofData || typeof proofData !== 'object') {
            return 'Proof data structure not available';
        }

        const keys = Object.keys(proofData);
        if (keys.length === 0) {
            return 'No proof data available';
        }

        let formatted = '';
        if (proofData.pi_a) {
            formatted += `pi_a: [${proofData.pi_a.slice(0, 2).join(', ')}, ...]<br>`;
        }
        if (proofData.pi_b) {
            formatted += `pi_b: [[${proofData.pi_b[0]?.slice(0, 2).join(', ') || 'N/A'}, ...], ...]<br>`;
        }
        if (proofData.pi_c) {
            formatted += `pi_c: [${proofData.pi_c.slice(0, 2).join(', ')}, ...]<br>`;
        }

        return formatted || `Available keys: ${keys.join(', ')}`;
    }

    // Action methods
    downloadJSON() {
        if (!this.proofResult) return;

        const jsonStr = JSON.stringify(this.proofResult, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `zk-email-proof-${this.proofResult.id || Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        this.log('üì• Cryptographic proof JSON downloaded');
    }

    copyProofId() {
        if (!this.proofResult || !this.proofResult.id) {
            this.showUserMessage('No proof ID available', 'error');
            return;
        }

        if (navigator.clipboard) {
            navigator.clipboard.writeText(this.proofResult.id).then(() => {
                this.log('üìã Proof ID copied to clipboard');
                this.showUserMessage('Proof ID copied to clipboard!', 'info');
            }).catch(() => {
                this.showUserMessage(`Proof ID: ${this.proofResult.id}`, 'info');
            });
        } else {
            this.showUserMessage(`Proof ID: ${this.proofResult.id}`, 'info');
        }
    }

    viewFullProof() {
        if (!this.proofResult || !this.proofResult.id) {
            this.showUserMessage('No proof ID available', 'error');
            return;
        }

        const proofUrl = `${this.registryUrl}/${this.blueprintId}/proofs/${this.proofResult.id}`;
        window.open(proofUrl, '_blank', 'noopener,noreferrer');
        this.log('üîó Opened full proof verification page');
    }

    async verifyProof() {
        if (!this.proofResult) {
            this.showUserMessage('No proof available to verify', 'error');
            return;
        }

        this.log('üîç Verifying cryptographic proof...');
        this.showUserMessage('Verifying proof...', 'info');

        // Basic validation for now (can be enhanced with actual verification)
        const isValid = this.basicProofValidation();
        if (isValid) {
            this.log('‚úÖ Basic proof validation passed');
            this.showUserMessage('‚úÖ Proof structure is valid!', 'info');
        } else {
            this.log('‚ùå Basic proof validation failed');
            this.showUserMessage('‚ùå Proof structure validation failed', 'error');
        }
    }

    basicProofValidation() {
        if (!this.proofResult) return false;

        const proof = this.proofResult.proofData || this.proofResult.proof;
        const publicData = this.proofResult.publicData || this.proofResult.public_data;

        const hasProofElements = proof && Object.keys(proof).length > 0;
        const hasPublicData = publicData && Object.keys(publicData).length > 0;
        const hasProofId = this.proofResult.id && this.proofResult.id.length > 5;

        return hasProofElements && hasPublicData && hasProofId;
    }

    redownloadEmail() {
        if (this.emailContent && this.selectedFile) {
            this.downloadEmailFile(
                URL.createObjectURL(new Blob([this.emailContent], { type: 'text/plain' })),
                this.selectedFile.name
            );
        }
    }

    showError(message) {
        const uploadSection = document.querySelector('.upload-section');
        if (!uploadSection) return;

        const errorDiv = document.createElement('div');
        errorDiv.className = 'error';
        errorDiv.style.margin = '20px 0';
        errorDiv.style.padding = '15px';
        errorDiv.style.borderRadius = '8px';
        errorDiv.innerHTML = `
            <strong>‚ùå ZK Proof Generation Failed:</strong> ${message}<br>
            <small>Common causes:</small><br>
            <small>‚Ä¢ Invalid email format or missing DKIM signature</small><br>
            <small>‚Ä¢ Blueprint not found in the ZK Email registry</small><br>
            <small>‚Ä¢ Network connectivity issues</small><br>
            <small>‚Ä¢ Temporary service limitations</small><br>
            <small>Try using the registry directly or check your email format.</small>
        `;

        uploadSection.appendChild(errorDiv);

        // Remove error after 20 seconds
        setTimeout(() => {
            if (errorDiv.parentNode) {
                errorDiv.remove();
            }
        }, 20000);
    }

    updateProgress(percentage, text) {
        this.safeUpdateElement('progressFill', (el) => el.style.width = `${percentage}%`);
        this.safeUpdateElement('progressText', (el) => el.textContent = text);
    }

    log(message) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = document.createElement('div');
        logEntry.textContent = `[${timestamp}] ${message}`;

        const logArea = document.getElementById('logArea');
        if (logArea) {
            logArea.appendChild(logEntry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        console.log(`[ZK Email] ${message}`);
    }
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.zkEmailProver = new ZKEmailProver();
    });
} else {
    window.zkEmailProver = new ZKEmailProver();
}

// Global error handler for uncaught promise rejections
window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    if (window.zkEmailProver) {
        window.zkEmailProver.log(`‚ùå Uncaught error: ${event.reason.message || event.reason}`);
        window.zkEmailProver.showUserMessage('An unexpected error occurred. Please try again.', 'error');
    }
    event.preventDefault();
});

// Helper function to check if all required DOM elements exist
function validateDOMElements() {
    const requiredElements = [
        'uploadArea', 'fileInput', 'proveButton', 'progressFill', 
        'progressText', 'logArea', 'step1', 'step2', 'step3'
    ];
    
    const missing = requiredElements.filter(id => !document.getElementById(id));
    
    if (missing.length > 0) {
        console.warn('Missing required DOM elements:', missing);
        return false;
    }
    
    return true;
}

// Export for potential use in other scripts
if (typeof window !== 'undefined') {
    window.ZKEmailProver = ZKEmailProver;
    window.validateDOMElements = validateDOMElements;
}
    </script>
</body>
</html>
